
FREE_RTOS_test_rev.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003948  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000038  00800060  00003948  000039dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000107  00800098  00800098  00003a14  2**0
                  ALLOC
  3 .stab         000073d4  00000000  00000000  00003a14  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000048b5  00000000  00000000  0000ade8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 73 15 	jmp	0x2ae6	; 0x2ae6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e4       	ldi	r30, 0x48	; 72
      68:	f9 e3       	ldi	r31, 0x39	; 57
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 39       	cpi	r26, 0x98	; 152
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	a8 e9       	ldi	r26, 0x98	; 152
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 39       	cpi	r26, 0x9F	; 159
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 9d 18 	call	0x313a	; 0x313a <main>
      8a:	0c 94 a2 1c 	jmp	0x3944	; 0x3944 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xCoRoutineRemoveFromEventList>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	dc 01       	movw	r26, r24
      9c:	15 96       	adiw	r26, 0x05	; 5
      9e:	ed 91       	ld	r30, X+
      a0:	fc 91       	ld	r31, X
      a2:	16 97       	sbiw	r26, 0x06	; 6
      a4:	e6 80       	ldd	r14, Z+6	; 0x06
      a6:	f7 80       	ldd	r15, Z+7	; 0x07
      a8:	87 01       	movw	r16, r14
      aa:	04 5f       	subi	r16, 0xF4	; 244
      ac:	1f 4f       	sbci	r17, 0xFF	; 255
      ae:	c8 01       	movw	r24, r16
      b0:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
      b4:	89 ec       	ldi	r24, 0xC9	; 201
      b6:	90 e0       	ldi	r25, 0x00	; 0
      b8:	b8 01       	movw	r22, r16
      ba:	0e 94 23 02 	call	0x446	; 0x446 <vListInsertEnd>
      be:	20 e0       	ldi	r18, 0x00	; 0
      c0:	e0 91 98 00 	lds	r30, 0x0098
      c4:	f0 91 99 00 	lds	r31, 0x0099
      c8:	d7 01       	movw	r26, r14
      ca:	56 96       	adiw	r26, 0x16	; 22
      cc:	9c 91       	ld	r25, X
      ce:	86 89       	ldd	r24, Z+22	; 0x16
      d0:	98 17       	cp	r25, r24
      d2:	08 f0       	brcs	.+2      	; 0xd6 <xCoRoutineRemoveFromEventList+0x44>
      d4:	21 e0       	ldi	r18, 0x01	; 1
      d6:	82 2f       	mov	r24, r18
      d8:	1f 91       	pop	r17
      da:	0f 91       	pop	r16
      dc:	ff 90       	pop	r15
      de:	ef 90       	pop	r14
      e0:	08 95       	ret

000000e2 <vCoRoutineSchedule>:
        xLastTickCount = xCoRoutineTickCount;
    }
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
      e2:	ff 92       	push	r15
      e4:	0f 93       	push	r16
      e6:	1f 93       	push	r17
      e8:	cf 93       	push	r28
      ea:	df 93       	push	r29
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
      ec:	80 91 9a 00 	lds	r24, 0x009A
      f0:	90 91 9b 00 	lds	r25, 0x009B
      f4:	89 2b       	or	r24, r25
      f6:	19 f5       	brne	.+70     	; 0x13e <vCoRoutineSchedule+0x5c>
      f8:	d5 c0       	rjmp	.+426    	; 0x2a4 <vCoRoutineSchedule+0x1c2>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
      fa:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
      fc:	e0 91 ce 00 	lds	r30, 0x00CE
     100:	f0 91 cf 00 	lds	r31, 0x00CF
     104:	06 81       	ldd	r16, Z+6	; 0x06
     106:	17 81       	ldd	r17, Z+7	; 0x07
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     108:	c8 01       	movw	r24, r16
     10a:	0c 96       	adiw	r24, 0x0c	; 12
     10c:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
     110:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     112:	e8 01       	movw	r28, r16
     114:	22 96       	adiw	r28, 0x02	; 2
     116:	ce 01       	movw	r24, r28
     118:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     11c:	f8 01       	movw	r30, r16
     11e:	96 89       	ldd	r25, Z+22	; 0x16
     120:	80 91 9c 00 	lds	r24, 0x009C
     124:	89 17       	cp	r24, r25
     126:	10 f4       	brcc	.+4      	; 0x12c <vCoRoutineSchedule+0x4a>
     128:	90 93 9c 00 	sts	0x009C, r25
     12c:	9f 9d       	mul	r25, r15
     12e:	c0 01       	movw	r24, r0
     130:	11 24       	eor	r1, r1
     132:	8b 55       	subi	r24, 0x5B	; 91
     134:	9f 4f       	sbci	r25, 0xFF	; 255
     136:	be 01       	movw	r22, r28
     138:	0e 94 23 02 	call	0x446	; 0x446 <vListInsertEnd>
     13c:	02 c0       	rjmp	.+4      	; 0x142 <vCoRoutineSchedule+0x60>
     13e:	99 e0       	ldi	r25, 0x09	; 9
     140:	f9 2e       	mov	r15, r25
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     142:	80 91 c9 00 	lds	r24, 0x00C9
     146:	88 23       	and	r24, r24
     148:	c1 f6       	brne	.-80     	; 0xfa <vCoRoutineSchedule+0x18>

    static void prvCheckDelayedList( void )
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     14a:	0e 94 27 08 	call	0x104e	; 0x104e <xTaskGetTickCount>
     14e:	20 91 9d 00 	lds	r18, 0x009D
     152:	30 91 9e 00 	lds	r19, 0x009E
     156:	82 1b       	sub	r24, r18
     158:	93 0b       	sbc	r25, r19
     15a:	90 93 a0 00 	sts	0x00A0, r25
     15e:	80 93 9f 00 	sts	0x009F, r24
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
                    }
                }
                portENABLE_INTERRUPTS();

                prvAddCoRoutineToReadyQueue( pxCRCB );
     162:	89 e0       	ldi	r24, 0x09	; 9
     164:	f8 2e       	mov	r15, r24
     166:	53 c0       	rjmp	.+166    	; 0x20e <vCoRoutineSchedule+0x12c>

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
     168:	01 96       	adiw	r24, 0x01	; 1
     16a:	90 93 a2 00 	sts	0x00A2, r25
     16e:	80 93 a1 00 	sts	0x00A1, r24
            xPassedTicks--;
     172:	21 50       	subi	r18, 0x01	; 1
     174:	30 40       	sbci	r19, 0x00	; 0
     176:	30 93 a0 00 	sts	0x00A0, r19
     17a:	20 93 9f 00 	sts	0x009F, r18

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
     17e:	89 2b       	or	r24, r25
     180:	09 f0       	breq	.+2      	; 0x184 <vCoRoutineSchedule+0xa2>
     182:	3e c0       	rjmp	.+124    	; 0x200 <vCoRoutineSchedule+0x11e>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
     184:	20 91 9a 00 	lds	r18, 0x009A
     188:	30 91 9b 00 	lds	r19, 0x009B
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     18c:	80 91 a3 00 	lds	r24, 0x00A3
     190:	90 91 a4 00 	lds	r25, 0x00A4
     194:	90 93 9b 00 	sts	0x009B, r25
     198:	80 93 9a 00 	sts	0x009A, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
     19c:	30 93 a4 00 	sts	0x00A4, r19
     1a0:	20 93 a3 00 	sts	0x00A3, r18
     1a4:	2d c0       	rjmp	.+90     	; 0x200 <vCoRoutineSchedule+0x11e>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     1a6:	05 80       	ldd	r0, Z+5	; 0x05
     1a8:	f6 81       	ldd	r31, Z+6	; 0x06
     1aa:	e0 2d       	mov	r30, r0
     1ac:	c6 81       	ldd	r28, Z+6	; 0x06
     1ae:	d7 81       	ldd	r29, Z+7	; 0x07

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     1b0:	20 91 a1 00 	lds	r18, 0x00A1
     1b4:	30 91 a2 00 	lds	r19, 0x00A2
     1b8:	8a 81       	ldd	r24, Y+2	; 0x02
     1ba:	9b 81       	ldd	r25, Y+3	; 0x03
     1bc:	28 17       	cp	r18, r24
     1be:	39 07       	cpc	r19, r25
     1c0:	30 f1       	brcs	.+76     	; 0x20e <vCoRoutineSchedule+0x12c>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
     1c2:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     1c4:	8e 01       	movw	r16, r28
     1c6:	0e 5f       	subi	r16, 0xFE	; 254
     1c8:	1f 4f       	sbci	r17, 0xFF	; 255
     1ca:	c8 01       	movw	r24, r16
     1cc:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
     1d0:	8c 89       	ldd	r24, Y+20	; 0x14
     1d2:	9d 89       	ldd	r25, Y+21	; 0x15
     1d4:	89 2b       	or	r24, r25
     1d6:	21 f0       	breq	.+8      	; 0x1e0 <vCoRoutineSchedule+0xfe>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     1d8:	ce 01       	movw	r24, r28
     1da:	0c 96       	adiw	r24, 0x0c	; 12
     1dc:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
     1e0:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
     1e2:	9e 89       	ldd	r25, Y+22	; 0x16
     1e4:	80 91 9c 00 	lds	r24, 0x009C
     1e8:	89 17       	cp	r24, r25
     1ea:	10 f4       	brcc	.+4      	; 0x1f0 <vCoRoutineSchedule+0x10e>
     1ec:	90 93 9c 00 	sts	0x009C, r25
     1f0:	9f 9d       	mul	r25, r15
     1f2:	c0 01       	movw	r24, r0
     1f4:	11 24       	eor	r1, r1
     1f6:	8b 55       	subi	r24, 0x5B	; 91
     1f8:	9f 4f       	sbci	r25, 0xFF	; 255
     1fa:	b8 01       	movw	r22, r16
     1fc:	0e 94 23 02 	call	0x446	; 0x446 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     200:	e0 91 9a 00 	lds	r30, 0x009A
     204:	f0 91 9b 00 	lds	r31, 0x009B
     208:	80 81       	ld	r24, Z
     20a:	88 23       	and	r24, r24
     20c:	61 f6       	brne	.-104    	; 0x1a6 <vCoRoutineSchedule+0xc4>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
     20e:	20 91 9f 00 	lds	r18, 0x009F
     212:	30 91 a0 00 	lds	r19, 0x00A0
     216:	80 91 a1 00 	lds	r24, 0x00A1
     21a:	90 91 a2 00 	lds	r25, 0x00A2
     21e:	21 15       	cp	r18, r1
     220:	31 05       	cpc	r19, r1
     222:	09 f0       	breq	.+2      	; 0x226 <vCoRoutineSchedule+0x144>
     224:	a1 cf       	rjmp	.-190    	; 0x168 <vCoRoutineSchedule+0x86>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
     226:	90 93 9e 00 	sts	0x009E, r25
     22a:	80 93 9d 00 	sts	0x009D, r24
     22e:	90 91 9c 00 	lds	r25, 0x009C

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     232:	29 e0       	ldi	r18, 0x09	; 9
     234:	06 c0       	rjmp	.+12     	; 0x242 <vCoRoutineSchedule+0x160>
            {
                if( uxTopCoRoutineReadyPriority == 0 )
     236:	99 23       	and	r25, r25
     238:	19 f4       	brne	.+6      	; 0x240 <vCoRoutineSchedule+0x15e>
     23a:	10 92 9c 00 	sts	0x009C, r1
     23e:	32 c0       	rjmp	.+100    	; 0x2a4 <vCoRoutineSchedule+0x1c2>
     240:	91 50       	subi	r25, 0x01	; 1

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     242:	92 9f       	mul	r25, r18
     244:	d0 01       	movw	r26, r0
     246:	11 24       	eor	r1, r1
     248:	ab 55       	subi	r26, 0x5B	; 91
     24a:	bf 4f       	sbci	r27, 0xFF	; 255
     24c:	8c 91       	ld	r24, X
     24e:	88 23       	and	r24, r24
     250:	91 f3       	breq	.-28     	; 0x236 <vCoRoutineSchedule+0x154>
     252:	90 93 9c 00 	sts	0x009C, r25
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     256:	11 96       	adiw	r26, 0x01	; 1
     258:	ed 91       	ld	r30, X+
     25a:	fc 91       	ld	r31, X
     25c:	12 97       	sbiw	r26, 0x02	; 2
     25e:	02 80       	ldd	r0, Z+2	; 0x02
     260:	f3 81       	ldd	r31, Z+3	; 0x03
     262:	e0 2d       	mov	r30, r0
     264:	12 96       	adiw	r26, 0x02	; 2
     266:	fc 93       	st	X, r31
     268:	ee 93       	st	-X, r30
     26a:	11 97       	sbiw	r26, 0x01	; 1
     26c:	cd 01       	movw	r24, r26
     26e:	03 96       	adiw	r24, 0x03	; 3
     270:	e8 17       	cp	r30, r24
     272:	f9 07       	cpc	r31, r25
     274:	31 f4       	brne	.+12     	; 0x282 <vCoRoutineSchedule+0x1a0>
     276:	82 81       	ldd	r24, Z+2	; 0x02
     278:	93 81       	ldd	r25, Z+3	; 0x03
     27a:	12 96       	adiw	r26, 0x02	; 2
     27c:	9c 93       	st	X, r25
     27e:	8e 93       	st	-X, r24
     280:	11 97       	sbiw	r26, 0x01	; 1
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	ed 91       	ld	r30, X+
     286:	fc 91       	ld	r31, X
     288:	12 97       	sbiw	r26, 0x02	; 2
     28a:	06 80       	ldd	r0, Z+6	; 0x06
     28c:	f7 81       	ldd	r31, Z+7	; 0x07
     28e:	e0 2d       	mov	r30, r0
     290:	f0 93 99 00 	sts	0x0099, r31
     294:	e0 93 98 00 	sts	0x0098, r30

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     298:	20 81       	ld	r18, Z
     29a:	31 81       	ldd	r19, Z+1	; 0x01
     29c:	cf 01       	movw	r24, r30
     29e:	67 89       	ldd	r22, Z+23	; 0x17
     2a0:	f9 01       	movw	r30, r18
     2a2:	09 95       	icall
        }
    }
     2a4:	df 91       	pop	r29
     2a6:	cf 91       	pop	r28
     2a8:	1f 91       	pop	r17
     2aa:	0f 91       	pop	r16
     2ac:	ff 90       	pop	r15
     2ae:	08 95       	ret

000002b0 <vCoRoutineAddToDelayedList>:
    }
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
     2b0:	0f 93       	push	r16
     2b2:	1f 93       	push	r17
     2b4:	cf 93       	push	r28
     2b6:	df 93       	push	r29
     2b8:	eb 01       	movw	r28, r22
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     2ba:	00 91 a1 00 	lds	r16, 0x00A1
     2be:	10 91 a2 00 	lds	r17, 0x00A2
     2c2:	08 0f       	add	r16, r24
     2c4:	19 1f       	adc	r17, r25

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2c6:	80 91 98 00 	lds	r24, 0x0098
     2ca:	90 91 99 00 	lds	r25, 0x0099
     2ce:	02 96       	adiw	r24, 0x02	; 2
     2d0:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     2d4:	e0 91 98 00 	lds	r30, 0x0098
     2d8:	f0 91 99 00 	lds	r31, 0x0099
     2dc:	13 83       	std	Z+3, r17	; 0x03
     2de:	02 83       	std	Z+2, r16	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
     2e0:	80 91 a1 00 	lds	r24, 0x00A1
     2e4:	90 91 a2 00 	lds	r25, 0x00A2
     2e8:	bf 01       	movw	r22, r30
     2ea:	6e 5f       	subi	r22, 0xFE	; 254
     2ec:	7f 4f       	sbci	r23, 0xFF	; 255
     2ee:	08 17       	cp	r16, r24
     2f0:	19 07       	cpc	r17, r25
     2f2:	28 f4       	brcc	.+10     	; 0x2fe <vCoRoutineAddToDelayedList+0x4e>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2f4:	80 91 a3 00 	lds	r24, 0x00A3
     2f8:	90 91 a4 00 	lds	r25, 0x00A4
     2fc:	04 c0       	rjmp	.+8      	; 0x306 <vCoRoutineAddToDelayedList+0x56>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2fe:	80 91 9a 00 	lds	r24, 0x009A
     302:	90 91 9b 00 	lds	r25, 0x009B
     306:	0e 94 42 02 	call	0x484	; 0x484 <vListInsert>
        }

        if( pxEventList )
     30a:	20 97       	sbiw	r28, 0x00	; 0
     30c:	49 f0       	breq	.+18     	; 0x320 <vCoRoutineAddToDelayedList+0x70>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     30e:	60 91 98 00 	lds	r22, 0x0098
     312:	70 91 99 00 	lds	r23, 0x0099
     316:	64 5f       	subi	r22, 0xF4	; 244
     318:	7f 4f       	sbci	r23, 0xFF	; 255
     31a:	ce 01       	movw	r24, r28
     31c:	0e 94 42 02 	call	0x484	; 0x484 <vListInsert>
        }
    }
     320:	df 91       	pop	r29
     322:	cf 91       	pop	r28
     324:	1f 91       	pop	r17
     326:	0f 91       	pop	r16
     328:	08 95       	ret

0000032a <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
     32a:	af 92       	push	r10
     32c:	bf 92       	push	r11
     32e:	cf 92       	push	r12
     330:	df 92       	push	r13
     332:	ef 92       	push	r14
     334:	ff 92       	push	r15
     336:	0f 93       	push	r16
     338:	1f 93       	push	r17
     33a:	cf 93       	push	r28
     33c:	df 93       	push	r29
     33e:	6c 01       	movw	r12, r24
     340:	b6 2e       	mov	r11, r22
     342:	a4 2e       	mov	r10, r20
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     344:	8a e1       	ldi	r24, 0x1A	; 26
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <pvPortMalloc>
     34c:	ec 01       	movw	r28, r24

        if( pxCoRoutine )
     34e:	00 97       	sbiw	r24, 0x00	; 0
     350:	11 f4       	brne	.+4      	; 0x356 <xCoRoutineCreate+0x2c>
     352:	8f ef       	ldi	r24, 0xFF	; 255
     354:	59 c0       	rjmp	.+178    	; 0x408 <xCoRoutineCreate+0xde>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
     356:	80 91 98 00 	lds	r24, 0x0098
     35a:	90 91 99 00 	lds	r25, 0x0099
     35e:	89 2b       	or	r24, r25
     360:	21 f5       	brne	.+72     	; 0x3aa <xCoRoutineCreate+0x80>
            {
                pxCurrentCoRoutine = pxCoRoutine;
     362:	d0 93 99 00 	sts	0x0099, r29
     366:	c0 93 98 00 	sts	0x0098, r28
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     36a:	85 ea       	ldi	r24, 0xA5	; 165
     36c:	90 e0       	ldi	r25, 0x00	; 0
     36e:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
     372:	8e ea       	ldi	r24, 0xAE	; 174
     374:	90 e0       	ldi	r25, 0x00	; 0
     376:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     37a:	27 eb       	ldi	r18, 0xB7	; 183
     37c:	e2 2e       	mov	r14, r18
     37e:	20 e0       	ldi	r18, 0x00	; 0
     380:	f2 2e       	mov	r15, r18
     382:	c7 01       	movw	r24, r14
     384:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     388:	00 ec       	ldi	r16, 0xC0	; 192
     38a:	10 e0       	ldi	r17, 0x00	; 0
     38c:	c8 01       	movw	r24, r16
     38e:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     392:	89 ec       	ldi	r24, 0xC9	; 201
     394:	90 e0       	ldi	r25, 0x00	; 0
     396:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     39a:	f0 92 9b 00 	sts	0x009B, r15
     39e:	e0 92 9a 00 	sts	0x009A, r14
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     3a2:	10 93 a4 00 	sts	0x00A4, r17
     3a6:	00 93 a3 00 	sts	0x00A3, r16
     3aa:	eb 2c       	mov	r14, r11
     3ac:	bb 20       	and	r11, r11
     3ae:	11 f0       	breq	.+4      	; 0x3b4 <xCoRoutineCreate+0x8a>
     3b0:	ee 24       	eor	r14, r14
     3b2:	e3 94       	inc	r14
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
     3b4:	19 8e       	std	Y+25, r1	; 0x19
     3b6:	18 8e       	std	Y+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
     3b8:	ee 8a       	std	Y+22, r14	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
     3ba:	af 8a       	std	Y+23, r10	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     3bc:	fe 01       	movw	r30, r28
     3be:	c1 92       	st	Z+, r12
     3c0:	d1 92       	st	Z+, r13
     3c2:	8f 01       	movw	r16, r30

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     3c4:	cf 01       	movw	r24, r30
     3c6:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     3ca:	ce 01       	movw	r24, r28
     3cc:	0c 96       	adiw	r24, 0x0c	; 12
     3ce:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     3d2:	d9 87       	std	Y+9, r29	; 0x09
     3d4:	c8 87       	std	Y+8, r28	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     3d6:	db 8b       	std	Y+19, r29	; 0x13
     3d8:	ca 8b       	std	Y+18, r28	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     3da:	82 e0       	ldi	r24, 0x02	; 2
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	8e 19       	sub	r24, r14
     3e0:	91 09       	sbc	r25, r1
     3e2:	9d 87       	std	Y+13, r25	; 0x0d
     3e4:	8c 87       	std	Y+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
     3e6:	9e 89       	ldd	r25, Y+22	; 0x16
     3e8:	80 91 9c 00 	lds	r24, 0x009C
     3ec:	89 17       	cp	r24, r25
     3ee:	10 f4       	brcc	.+4      	; 0x3f4 <xCoRoutineCreate+0xca>
     3f0:	90 93 9c 00 	sts	0x009C, r25
     3f4:	89 e0       	ldi	r24, 0x09	; 9
     3f6:	98 9f       	mul	r25, r24
     3f8:	c0 01       	movw	r24, r0
     3fa:	11 24       	eor	r1, r1
     3fc:	8b 55       	subi	r24, 0x5B	; 91
     3fe:	9f 4f       	sbci	r25, 0xFF	; 255
     400:	b8 01       	movw	r22, r16
     402:	0e 94 23 02 	call	0x446	; 0x446 <vListInsertEnd>
     406:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
     408:	df 91       	pop	r29
     40a:	cf 91       	pop	r28
     40c:	1f 91       	pop	r17
     40e:	0f 91       	pop	r16
     410:	ff 90       	pop	r15
     412:	ef 90       	pop	r14
     414:	df 90       	pop	r13
     416:	cf 90       	pop	r12
     418:	bf 90       	pop	r11
     41a:	af 90       	pop	r10
     41c:	08 95       	ret

0000041e <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     41e:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     420:	9c 01       	movw	r18, r24
     422:	2d 5f       	subi	r18, 0xFD	; 253
     424:	3f 4f       	sbci	r19, 0xFF	; 255
     426:	32 83       	std	Z+2, r19	; 0x02
     428:	21 83       	std	Z+1, r18	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     42a:	8f ef       	ldi	r24, 0xFF	; 255
     42c:	9f ef       	ldi	r25, 0xFF	; 255
     42e:	94 83       	std	Z+4, r25	; 0x04
     430:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     432:	36 83       	std	Z+6, r19	; 0x06
     434:	25 83       	std	Z+5, r18	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     436:	30 87       	std	Z+8, r19	; 0x08
     438:	27 83       	std	Z+7, r18	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     43a:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     43c:	08 95       	ret

0000043e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     43e:	fc 01       	movw	r30, r24
     440:	11 86       	std	Z+9, r1	; 0x09
     442:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     444:	08 95       	ret

00000446 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
     446:	ac 01       	movw	r20, r24
    ListItem_t * const pxIndex = pxList->pxIndex;
     448:	fc 01       	movw	r30, r24
     44a:	a1 81       	ldd	r26, Z+1	; 0x01
     44c:	b2 81       	ldd	r27, Z+2	; 0x02
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     44e:	fb 01       	movw	r30, r22
     450:	b3 83       	std	Z+3, r27	; 0x03
     452:	a2 83       	std	Z+2, r26	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     454:	14 96       	adiw	r26, 0x04	; 4
     456:	8d 91       	ld	r24, X+
     458:	9c 91       	ld	r25, X
     45a:	15 97       	sbiw	r26, 0x05	; 5
     45c:	95 83       	std	Z+5, r25	; 0x05
     45e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     460:	14 96       	adiw	r26, 0x04	; 4
     462:	ed 91       	ld	r30, X+
     464:	fc 91       	ld	r31, X
     466:	15 97       	sbiw	r26, 0x05	; 5
     468:	73 83       	std	Z+3, r23	; 0x03
     46a:	62 83       	std	Z+2, r22	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
     46c:	15 96       	adiw	r26, 0x05	; 5
     46e:	7c 93       	st	X, r23
     470:	6e 93       	st	-X, r22
     472:	14 97       	sbiw	r26, 0x04	; 4

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     474:	fb 01       	movw	r30, r22
     476:	51 87       	std	Z+9, r21	; 0x09
     478:	40 87       	std	Z+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
     47a:	fa 01       	movw	r30, r20
     47c:	80 81       	ld	r24, Z
     47e:	8f 5f       	subi	r24, 0xFF	; 255
     480:	80 83       	st	Z, r24
}
     482:	08 95       	ret

00000484 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	9c 01       	movw	r18, r24
     48a:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     48c:	48 81       	ld	r20, Y
     48e:	59 81       	ldd	r21, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     490:	8f ef       	ldi	r24, 0xFF	; 255
     492:	4f 3f       	cpi	r20, 0xFF	; 255
     494:	58 07       	cpc	r21, r24
     496:	21 f4       	brne	.+8      	; 0x4a0 <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     498:	f9 01       	movw	r30, r18
     49a:	a7 81       	ldd	r26, Z+7	; 0x07
     49c:	b0 85       	ldd	r27, Z+8	; 0x08
     49e:	0d c0       	rjmp	.+26     	; 0x4ba <vListInsert+0x36>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     4a0:	d9 01       	movw	r26, r18
     4a2:	13 96       	adiw	r26, 0x03	; 3
     4a4:	12 96       	adiw	r26, 0x02	; 2
     4a6:	ed 91       	ld	r30, X+
     4a8:	fc 91       	ld	r31, X
     4aa:	13 97       	sbiw	r26, 0x03	; 3
     4ac:	80 81       	ld	r24, Z
     4ae:	91 81       	ldd	r25, Z+1	; 0x01
     4b0:	48 17       	cp	r20, r24
     4b2:	59 07       	cpc	r21, r25
     4b4:	10 f0       	brcs	.+4      	; 0x4ba <vListInsert+0x36>
     4b6:	df 01       	movw	r26, r30
     4b8:	f5 cf       	rjmp	.-22     	; 0x4a4 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     4ba:	12 96       	adiw	r26, 0x02	; 2
     4bc:	ed 91       	ld	r30, X+
     4be:	fc 91       	ld	r31, X
     4c0:	13 97       	sbiw	r26, 0x03	; 3
     4c2:	fb 83       	std	Y+3, r31	; 0x03
     4c4:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4c6:	d5 83       	std	Z+5, r29	; 0x05
     4c8:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     4ca:	bd 83       	std	Y+5, r27	; 0x05
     4cc:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
     4ce:	13 96       	adiw	r26, 0x03	; 3
     4d0:	dc 93       	st	X, r29
     4d2:	ce 93       	st	-X, r28
     4d4:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
     4d6:	39 87       	std	Y+9, r19	; 0x09
     4d8:	28 87       	std	Y+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
     4da:	f9 01       	movw	r30, r18
     4dc:	80 81       	ld	r24, Z
     4de:	8f 5f       	subi	r24, 0xFF	; 255
     4e0:	80 83       	st	Z, r24
}
     4e2:	df 91       	pop	r29
     4e4:	cf 91       	pop	r28
     4e6:	08 95       	ret

000004e8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4e8:	cf 93       	push	r28
     4ea:	df 93       	push	r29
     4ec:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
     4ee:	18 96       	adiw	r26, 0x08	; 8
     4f0:	cd 91       	ld	r28, X+
     4f2:	dc 91       	ld	r29, X
     4f4:	19 97       	sbiw	r26, 0x09	; 9

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4f6:	12 96       	adiw	r26, 0x02	; 2
     4f8:	4d 91       	ld	r20, X+
     4fa:	5c 91       	ld	r21, X
     4fc:	13 97       	sbiw	r26, 0x03	; 3
     4fe:	14 96       	adiw	r26, 0x04	; 4
     500:	8d 91       	ld	r24, X+
     502:	9c 91       	ld	r25, X
     504:	15 97       	sbiw	r26, 0x05	; 5
     506:	fa 01       	movw	r30, r20
     508:	95 83       	std	Z+5, r25	; 0x05
     50a:	84 83       	std	Z+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     50c:	14 96       	adiw	r26, 0x04	; 4
     50e:	2d 91       	ld	r18, X+
     510:	3c 91       	ld	r19, X
     512:	15 97       	sbiw	r26, 0x05	; 5
     514:	f9 01       	movw	r30, r18
     516:	53 83       	std	Z+3, r21	; 0x03
     518:	42 83       	std	Z+2, r20	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     51a:	89 81       	ldd	r24, Y+1	; 0x01
     51c:	9a 81       	ldd	r25, Y+2	; 0x02
     51e:	8a 17       	cp	r24, r26
     520:	9b 07       	cpc	r25, r27
     522:	11 f4       	brne	.+4      	; 0x528 <uxListRemove+0x40>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     524:	3a 83       	std	Y+2, r19	; 0x02
     526:	29 83       	std	Y+1, r18	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     528:	19 96       	adiw	r26, 0x09	; 9
     52a:	1c 92       	st	X, r1
     52c:	1e 92       	st	-X, r1
     52e:	18 97       	sbiw	r26, 0x08	; 8
    ( pxList->uxNumberOfItems )--;
     530:	88 81       	ld	r24, Y
     532:	81 50       	subi	r24, 0x01	; 1
     534:	88 83       	st	Y, r24

    return pxList->uxNumberOfItems;
     536:	88 81       	ld	r24, Y
}
     538:	df 91       	pop	r29
     53a:	cf 91       	pop	r28
     53c:	08 95       	ret

0000053e <uxQueueMessagesWaiting>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
     53e:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
     540:	0f b6       	in	r0, 0x3f	; 63
     542:	f8 94       	cli
     544:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
     546:	82 8d       	ldd	r24, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
     548:	0f 90       	pop	r0
     54a:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     54c:	08 95       	ret

0000054e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
     54e:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
     550:	0f b6       	in	r0, 0x3f	; 63
     552:	f8 94       	cli
     554:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
     556:	92 8d       	ldd	r25, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
     558:	0f 90       	pop	r0
     55a:	0f be       	out	0x3f, r0	; 63
     55c:	83 8d       	ldd	r24, Z+27	; 0x1b

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     55e:	89 1b       	sub	r24, r25
     560:	08 95       	ret

00000562 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
     562:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
     564:	82 8d       	ldd	r24, Z+26	; 0x1a

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     566:	08 95       	ret

00000568 <xQueueIsQueueEmptyFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
     568:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     56a:	82 8d       	ldd	r24, Z+26	; 0x1a
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	88 23       	and	r24, r24
     570:	09 f4       	brne	.+2      	; 0x574 <xQueueIsQueueEmptyFromISR+0xc>
     572:	91 e0       	ldi	r25, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     574:	89 2f       	mov	r24, r25
     576:	08 95       	ret

00000578 <xQueueIsQueueFullFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
     578:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     57a:	92 8d       	ldd	r25, Z+26	; 0x1a
     57c:	20 e0       	ldi	r18, 0x00	; 0
     57e:	83 8d       	ldd	r24, Z+27	; 0x1b
     580:	98 17       	cp	r25, r24
     582:	09 f4       	brne	.+2      	; 0x586 <xQueueIsQueueFullFromISR+0xe>
     584:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     586:	82 2f       	mov	r24, r18
     588:	08 95       	ret

0000058a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
     58a:	0f 93       	push	r16
     58c:	1f 93       	push	r17
     58e:	cf 93       	push	r28
     590:	df 93       	push	r29
     592:	ec 01       	movw	r28, r24
     594:	04 2f       	mov	r16, r20
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     596:	1a 8d       	ldd	r17, Y+26	; 0x1a

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     598:	4c 8d       	ldd	r20, Y+28	; 0x1c
     59a:	44 23       	and	r20, r20
     59c:	c1 f1       	breq	.+112    	; 0x60e <prvCopyDataToQueue+0x84>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
     59e:	00 23       	and	r16, r16
     5a0:	b1 f4       	brne	.+44     	; 0x5ce <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
     5a2:	8a 81       	ldd	r24, Y+2	; 0x02
     5a4:	9b 81       	ldd	r25, Y+3	; 0x03
     5a6:	50 e0       	ldi	r21, 0x00	; 0
     5a8:	0e 94 99 1c 	call	0x3932	; 0x3932 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
     5ac:	8c 8d       	ldd	r24, Y+28	; 0x1c
     5ae:	2a 81       	ldd	r18, Y+2	; 0x02
     5b0:	3b 81       	ldd	r19, Y+3	; 0x03
     5b2:	28 0f       	add	r18, r24
     5b4:	31 1d       	adc	r19, r1
     5b6:	3b 83       	std	Y+3, r19	; 0x03
     5b8:	2a 83       	std	Y+2, r18	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     5ba:	8c 81       	ldd	r24, Y+4	; 0x04
     5bc:	9d 81       	ldd	r25, Y+5	; 0x05
     5be:	28 17       	cp	r18, r24
     5c0:	39 07       	cpc	r19, r25
     5c2:	28 f1       	brcs	.+74     	; 0x60e <prvCopyDataToQueue+0x84>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
     5c4:	88 81       	ld	r24, Y
     5c6:	99 81       	ldd	r25, Y+1	; 0x01
     5c8:	9b 83       	std	Y+3, r25	; 0x03
     5ca:	8a 83       	std	Y+2, r24	; 0x02
     5cc:	20 c0       	rjmp	.+64     	; 0x60e <prvCopyDataToQueue+0x84>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
     5ce:	8e 81       	ldd	r24, Y+6	; 0x06
     5d0:	9f 81       	ldd	r25, Y+7	; 0x07
     5d2:	50 e0       	ldi	r21, 0x00	; 0
     5d4:	0e 94 99 1c 	call	0x3932	; 0x3932 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
     5d8:	8c 8d       	ldd	r24, Y+28	; 0x1c
     5da:	90 e0       	ldi	r25, 0x00	; 0
     5dc:	44 27       	eor	r20, r20
     5de:	55 27       	eor	r21, r21
     5e0:	48 1b       	sub	r20, r24
     5e2:	59 0b       	sbc	r21, r25
     5e4:	8e 81       	ldd	r24, Y+6	; 0x06
     5e6:	9f 81       	ldd	r25, Y+7	; 0x07
     5e8:	84 0f       	add	r24, r20
     5ea:	95 1f       	adc	r25, r21
     5ec:	9f 83       	std	Y+7, r25	; 0x07
     5ee:	8e 83       	std	Y+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     5f0:	28 81       	ld	r18, Y
     5f2:	39 81       	ldd	r19, Y+1	; 0x01
     5f4:	82 17       	cp	r24, r18
     5f6:	93 07       	cpc	r25, r19
     5f8:	30 f4       	brcc	.+12     	; 0x606 <prvCopyDataToQueue+0x7c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
     5fa:	8c 81       	ldd	r24, Y+4	; 0x04
     5fc:	9d 81       	ldd	r25, Y+5	; 0x05
     5fe:	84 0f       	add	r24, r20
     600:	95 1f       	adc	r25, r21
     602:	9f 83       	std	Y+7, r25	; 0x07
     604:	8e 83       	std	Y+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
     606:	02 30       	cpi	r16, 0x02	; 2
     608:	11 f4       	brne	.+4      	; 0x60e <prvCopyDataToQueue+0x84>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     60a:	11 11       	cpse	r17, r1
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
     60c:	11 50       	subi	r17, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     60e:	1f 5f       	subi	r17, 0xFF	; 255
     610:	1a 8f       	std	Y+26, r17	; 0x1a

    return xReturn;
}
     612:	80 e0       	ldi	r24, 0x00	; 0
     614:	df 91       	pop	r29
     616:	cf 91       	pop	r28
     618:	1f 91       	pop	r17
     61a:	0f 91       	pop	r16
     61c:	08 95       	ret

0000061e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
     61e:	fc 01       	movw	r30, r24
     620:	56 2f       	mov	r21, r22
     622:	a7 2f       	mov	r26, r23
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     624:	24 8d       	ldd	r18, Z+28	; 0x1c
     626:	22 23       	and	r18, r18
     628:	b9 f0       	breq	.+46     	; 0x658 <prvCopyDataFromQueue+0x3a>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
     62a:	86 81       	ldd	r24, Z+6	; 0x06
     62c:	97 81       	ldd	r25, Z+7	; 0x07
     62e:	82 0f       	add	r24, r18
     630:	91 1d       	adc	r25, r1
     632:	97 83       	std	Z+7, r25	; 0x07
     634:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     636:	24 81       	ldd	r18, Z+4	; 0x04
     638:	35 81       	ldd	r19, Z+5	; 0x05
     63a:	82 17       	cp	r24, r18
     63c:	93 07       	cpc	r25, r19
     63e:	20 f0       	brcs	.+8      	; 0x648 <prvCopyDataFromQueue+0x2a>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
     640:	80 81       	ld	r24, Z
     642:	91 81       	ldd	r25, Z+1	; 0x01
     644:	97 83       	std	Z+7, r25	; 0x07
     646:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
     648:	44 8d       	ldd	r20, Z+28	; 0x1c
     64a:	66 81       	ldd	r22, Z+6	; 0x06
     64c:	77 81       	ldd	r23, Z+7	; 0x07
     64e:	85 2f       	mov	r24, r21
     650:	9a 2f       	mov	r25, r26
     652:	50 e0       	ldi	r21, 0x00	; 0
     654:	0e 94 99 1c 	call	0x3932	; 0x3932 <memcpy>
     658:	08 95       	ret

0000065a <xQueuePeekFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
     65a:	0f 93       	push	r16
     65c:	1f 93       	push	r17
     65e:	cf 93       	push	r28
     660:	df 93       	push	r29
     662:	ec 01       	movw	r28, r24
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     664:	8a 8d       	ldd	r24, Y+26	; 0x1a
     666:	88 23       	and	r24, r24
     668:	41 f0       	breq	.+16     	; 0x67a <xQueuePeekFromISR+0x20>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
     66a:	0e 81       	ldd	r16, Y+6	; 0x06
     66c:	1f 81       	ldd	r17, Y+7	; 0x07
            prvCopyDataFromQueue( pxQueue, pvBuffer );
     66e:	ce 01       	movw	r24, r28
     670:	0e 94 0f 03 	call	0x61e	; 0x61e <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
     674:	1f 83       	std	Y+7, r17	; 0x07
     676:	0e 83       	std	Y+6, r16	; 0x06
     678:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
     67a:	df 91       	pop	r29
     67c:	cf 91       	pop	r28
     67e:	1f 91       	pop	r17
     680:	0f 91       	pop	r16
     682:	08 95       	ret

00000684 <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
     684:	0f 93       	push	r16
     686:	1f 93       	push	r17
     688:	cf 93       	push	r28
     68a:	df 93       	push	r29
     68c:	ec 01       	movw	r28, r24
     68e:	fb 01       	movw	r30, r22
     690:	8a 01       	movw	r16, r20
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     692:	8a 8d       	ldd	r24, Y+26	; 0x1a
     694:	88 23       	and	r24, r24
     696:	61 f1       	breq	.+88     	; 0x6f0 <xQueueCRReceiveFromISR+0x6c>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
     698:	8c 8d       	ldd	r24, Y+28	; 0x1c
     69a:	2e 81       	ldd	r18, Y+6	; 0x06
     69c:	3f 81       	ldd	r19, Y+7	; 0x07
     69e:	28 0f       	add	r18, r24
     6a0:	31 1d       	adc	r19, r1
     6a2:	3f 83       	std	Y+7, r19	; 0x07
     6a4:	2e 83       	std	Y+6, r18	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
     6a6:	8c 81       	ldd	r24, Y+4	; 0x04
     6a8:	9d 81       	ldd	r25, Y+5	; 0x05
     6aa:	28 17       	cp	r18, r24
     6ac:	39 07       	cpc	r19, r25
     6ae:	20 f0       	brcs	.+8      	; 0x6b8 <xQueueCRReceiveFromISR+0x34>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
     6b0:	88 81       	ld	r24, Y
     6b2:	99 81       	ldd	r25, Y+1	; 0x01
     6b4:	9f 83       	std	Y+7, r25	; 0x07
     6b6:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
     6b8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6ba:	81 50       	subi	r24, 0x01	; 1
     6bc:	8a 8f       	std	Y+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     6be:	4c 8d       	ldd	r20, Y+28	; 0x1c
     6c0:	6e 81       	ldd	r22, Y+6	; 0x06
     6c2:	7f 81       	ldd	r23, Y+7	; 0x07
     6c4:	cf 01       	movw	r24, r30
     6c6:	50 e0       	ldi	r21, 0x00	; 0
     6c8:	0e 94 99 1c 	call	0x3932	; 0x3932 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
     6cc:	f8 01       	movw	r30, r16
     6ce:	80 81       	ld	r24, Z
     6d0:	88 23       	and	r24, r24
     6d2:	69 f4       	brne	.+26     	; 0x6ee <xQueueCRReceiveFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     6d4:	88 85       	ldd	r24, Y+8	; 0x08
     6d6:	88 23       	and	r24, r24
     6d8:	51 f0       	breq	.+20     	; 0x6ee <xQueueCRReceiveFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     6da:	ce 01       	movw	r24, r28
     6dc:	08 96       	adiw	r24, 0x08	; 8
     6de:	0e 94 49 00 	call	0x92	; 0x92 <xCoRoutineRemoveFromEventList>
     6e2:	88 23       	and	r24, r24
     6e4:	21 f0       	breq	.+8      	; 0x6ee <xQueueCRReceiveFromISR+0x6a>
                    {
                        *pxCoRoutineWoken = pdTRUE;
     6e6:	81 e0       	ldi	r24, 0x01	; 1
     6e8:	f8 01       	movw	r30, r16
     6ea:	80 83       	st	Z, r24
     6ec:	01 c0       	rjmp	.+2      	; 0x6f0 <xQueueCRReceiveFromISR+0x6c>
     6ee:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = pdFAIL;
        }

        return xReturn;
    }
     6f0:	df 91       	pop	r29
     6f2:	cf 91       	pop	r28
     6f4:	1f 91       	pop	r17
     6f6:	0f 91       	pop	r16
     6f8:	08 95       	ret

000006fa <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
     6fa:	1f 93       	push	r17
     6fc:	cf 93       	push	r28
     6fe:	df 93       	push	r29
     700:	ec 01       	movw	r28, r24
     702:	14 2f       	mov	r17, r20
        Queue_t * const pxQueue = xQueue;

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     704:	9a 8d       	ldd	r25, Y+26	; 0x1a
     706:	8b 8d       	ldd	r24, Y+27	; 0x1b
     708:	98 17       	cp	r25, r24
     70a:	88 f4       	brcc	.+34     	; 0x72e <xQueueCRSendFromISR+0x34>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
     70c:	ce 01       	movw	r24, r28
     70e:	40 e0       	ldi	r20, 0x00	; 0
     710:	0e 94 c5 02 	call	0x58a	; 0x58a <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
     714:	11 23       	and	r17, r17
     716:	59 f4       	brne	.+22     	; 0x72e <xQueueCRSendFromISR+0x34>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     718:	89 89       	ldd	r24, Y+17	; 0x11
     71a:	88 23       	and	r24, r24
     71c:	41 f0       	breq	.+16     	; 0x72e <xQueueCRSendFromISR+0x34>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     71e:	ce 01       	movw	r24, r28
     720:	41 96       	adiw	r24, 0x11	; 17
     722:	0e 94 49 00 	call	0x92	; 0x92 <xCoRoutineRemoveFromEventList>
     726:	48 2f       	mov	r20, r24
     728:	81 11       	cpse	r24, r1
     72a:	41 e0       	ldi	r20, 0x01	; 1
     72c:	14 2f       	mov	r17, r20
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    }
     72e:	81 2f       	mov	r24, r17
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	08 95       	ret

00000738 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
     738:	cf 93       	push	r28
     73a:	df 93       	push	r29
     73c:	ec 01       	movw	r28, r24
     73e:	fb 01       	movw	r30, r22
        Queue_t * const pxQueue = xQueue;

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
     740:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     742:	8a 8d       	ldd	r24, Y+26	; 0x1a
     744:	88 23       	and	r24, r24
     746:	71 f4       	brne	.+28     	; 0x764 <xQueueCRReceive+0x2c>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
     748:	41 15       	cp	r20, r1
     74a:	51 05       	cpc	r21, r1
     74c:	41 f0       	breq	.+16     	; 0x75e <xQueueCRReceive+0x26>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
     74e:	61 96       	adiw	r28, 0x11	; 17
     750:	ca 01       	movw	r24, r20
     752:	be 01       	movw	r22, r28
     754:	0e 94 58 01 	call	0x2b0	; 0x2b0 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
     758:	78 94       	sei
     75a:	8c ef       	ldi	r24, 0xFC	; 252
     75c:	2f c0       	rjmp	.+94     	; 0x7bc <xQueueCRReceive+0x84>
                    return errQUEUE_BLOCKED;
                }
                else
                {
                    portENABLE_INTERRUPTS();
     75e:	78 94       	sei
     760:	80 e0       	ldi	r24, 0x00	; 0
     762:	2c c0       	rjmp	.+88     	; 0x7bc <xQueueCRReceive+0x84>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
     764:	78 94       	sei

        portDISABLE_INTERRUPTS();
     766:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     768:	8a 8d       	ldd	r24, Y+26	; 0x1a
     76a:	88 23       	and	r24, r24
     76c:	31 f1       	breq	.+76     	; 0x7ba <xQueueCRReceive+0x82>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
     76e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     770:	2e 81       	ldd	r18, Y+6	; 0x06
     772:	3f 81       	ldd	r19, Y+7	; 0x07
     774:	28 0f       	add	r18, r24
     776:	31 1d       	adc	r19, r1
     778:	3f 83       	std	Y+7, r19	; 0x07
     77a:	2e 83       	std	Y+6, r18	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
     77c:	8c 81       	ldd	r24, Y+4	; 0x04
     77e:	9d 81       	ldd	r25, Y+5	; 0x05
     780:	28 17       	cp	r18, r24
     782:	39 07       	cpc	r19, r25
     784:	20 f0       	brcs	.+8      	; 0x78e <xQueueCRReceive+0x56>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
     786:	88 81       	ld	r24, Y
     788:	99 81       	ldd	r25, Y+1	; 0x01
     78a:	9f 83       	std	Y+7, r25	; 0x07
     78c:	8e 83       	std	Y+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
     78e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     790:	81 50       	subi	r24, 0x01	; 1
     792:	8a 8f       	std	Y+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     794:	4c 8d       	ldd	r20, Y+28	; 0x1c
     796:	6e 81       	ldd	r22, Y+6	; 0x06
     798:	7f 81       	ldd	r23, Y+7	; 0x07
     79a:	cf 01       	movw	r24, r30
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	0e 94 99 1c 	call	0x3932	; 0x3932 <memcpy>

                xReturn = pdPASS;

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     7a2:	88 85       	ldd	r24, Y+8	; 0x08
     7a4:	88 23       	and	r24, r24
     7a6:	41 f0       	breq	.+16     	; 0x7b8 <xQueueCRReceive+0x80>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     7a8:	ce 01       	movw	r24, r28
     7aa:	08 96       	adiw	r24, 0x08	; 8
     7ac:	0e 94 49 00 	call	0x92	; 0x92 <xCoRoutineRemoveFromEventList>
     7b0:	88 23       	and	r24, r24
     7b2:	11 f0       	breq	.+4      	; 0x7b8 <xQueueCRReceive+0x80>
     7b4:	8b ef       	ldi	r24, 0xFB	; 251
     7b6:	01 c0       	rjmp	.+2      	; 0x7ba <xQueueCRReceive+0x82>
     7b8:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        portENABLE_INTERRUPTS();
     7ba:	78 94       	sei

        return xReturn;
    }
     7bc:	df 91       	pop	r29
     7be:	cf 91       	pop	r28
     7c0:	08 95       	ret

000007c2 <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
     7c2:	cf 93       	push	r28
     7c4:	df 93       	push	r29
     7c6:	ec 01       	movw	r28, r24
        Queue_t * const pxQueue = xQueue;

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
     7c8:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     7ca:	0f b6       	in	r0, 0x3f	; 63
     7cc:	f8 94       	cli
     7ce:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     7d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7d2:	9b 8d       	ldd	r25, Y+27	; 0x1b
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     7d4:	0f 90       	pop	r0
     7d6:	0f be       	out	0x3f, r0	; 63
        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
     7d8:	89 17       	cp	r24, r25
     7da:	71 f4       	brne	.+28     	; 0x7f8 <xQueueCRSend+0x36>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
     7dc:	41 15       	cp	r20, r1
     7de:	51 05       	cpc	r21, r1
     7e0:	41 f0       	breq	.+16     	; 0x7f2 <xQueueCRSend+0x30>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
     7e2:	28 96       	adiw	r28, 0x08	; 8
     7e4:	ca 01       	movw	r24, r20
     7e6:	be 01       	movw	r22, r28
     7e8:	0e 94 58 01 	call	0x2b0	; 0x2b0 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
     7ec:	78 94       	sei
     7ee:	8c ef       	ldi	r24, 0xFC	; 252
     7f0:	1b c0       	rjmp	.+54     	; 0x828 <xQueueCRSend+0x66>
                    return errQUEUE_BLOCKED;
                }
                else
                {
                    portENABLE_INTERRUPTS();
     7f2:	78 94       	sei
     7f4:	80 e0       	ldi	r24, 0x00	; 0
     7f6:	18 c0       	rjmp	.+48     	; 0x828 <xQueueCRSend+0x66>
                    return errQUEUE_FULL;
                }
            }
        }
        portENABLE_INTERRUPTS();
     7f8:	78 94       	sei

        portDISABLE_INTERRUPTS();
     7fa:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     7fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7fe:	89 17       	cp	r24, r25
     800:	10 f0       	brcs	.+4      	; 0x806 <xQueueCRSend+0x44>
     802:	80 e0       	ldi	r24, 0x00	; 0
     804:	10 c0       	rjmp	.+32     	; 0x826 <xQueueCRSend+0x64>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
     806:	ce 01       	movw	r24, r28
     808:	40 e0       	ldi	r20, 0x00	; 0
     80a:	0e 94 c5 02 	call	0x58a	; 0x58a <prvCopyDataToQueue>
                xReturn = pdPASS;

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     80e:	89 89       	ldd	r24, Y+17	; 0x11
     810:	88 23       	and	r24, r24
     812:	41 f0       	breq	.+16     	; 0x824 <xQueueCRSend+0x62>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     814:	ce 01       	movw	r24, r28
     816:	41 96       	adiw	r24, 0x11	; 17
     818:	0e 94 49 00 	call	0x92	; 0x92 <xCoRoutineRemoveFromEventList>
     81c:	88 23       	and	r24, r24
     81e:	11 f0       	breq	.+4      	; 0x824 <xQueueCRSend+0x62>
     820:	8b ef       	ldi	r24, 0xFB	; 251
     822:	01 c0       	rjmp	.+2      	; 0x826 <xQueueCRSend+0x64>
     824:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = errQUEUE_FULL;
            }
        }
        portENABLE_INTERRUPTS();
     826:	78 94       	sei

        return xReturn;
    }
     828:	df 91       	pop	r29
     82a:	cf 91       	pop	r28
     82c:	08 95       	ret

0000082e <vQueueDelete>:

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
     82e:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
     832:	08 95       	ret

00000834 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
     834:	ef 92       	push	r14
     836:	ff 92       	push	r15
     838:	0f 93       	push	r16
     83a:	1f 93       	push	r17
     83c:	cf 93       	push	r28
     83e:	df 93       	push	r29
     840:	ec 01       	movw	r28, r24
     842:	7a 01       	movw	r14, r20
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     844:	1a 8d       	ldd	r17, Y+26	; 0x1a

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     846:	11 23       	and	r17, r17
     848:	11 f4       	brne	.+4      	; 0x84e <xQueueReceiveFromISR+0x1a>
     84a:	80 e0       	ldi	r24, 0x00	; 0
     84c:	1a c0       	rjmp	.+52     	; 0x882 <__stack+0x23>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
     84e:	0d 8d       	ldd	r16, Y+29	; 0x1d

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
     850:	0e 94 0f 03 	call	0x61e	; 0x61e <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     854:	11 50       	subi	r17, 0x01	; 1
     856:	1a 8f       	std	Y+26, r17	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
     858:	0f 3f       	cpi	r16, 0xFF	; 255
     85a:	81 f4       	brne	.+32     	; 0x87c <__stack+0x1d>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     85c:	88 85       	ldd	r24, Y+8	; 0x08
     85e:	88 23       	and	r24, r24
     860:	79 f0       	breq	.+30     	; 0x880 <__stack+0x21>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     862:	ce 01       	movw	r24, r28
     864:	08 96       	adiw	r24, 0x08	; 8
     866:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     86a:	88 23       	and	r24, r24
     86c:	49 f0       	breq	.+18     	; 0x880 <__stack+0x21>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
     86e:	e1 14       	cp	r14, r1
     870:	f1 04       	cpc	r15, r1
     872:	31 f0       	breq	.+12     	; 0x880 <__stack+0x21>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	f7 01       	movw	r30, r14
     878:	80 83       	st	Z, r24
     87a:	03 c0       	rjmp	.+6      	; 0x882 <__stack+0x23>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
     87c:	0f 5f       	subi	r16, 0xFF	; 255
     87e:	0d 8f       	std	Y+29, r16	; 0x1d
     880:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
     882:	df 91       	pop	r29
     884:	cf 91       	pop	r28
     886:	1f 91       	pop	r17
     888:	0f 91       	pop	r16
     88a:	ff 90       	pop	r15
     88c:	ef 90       	pop	r14
     88e:	08 95       	ret

00000890 <xQueueGiveFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	fc 01       	movw	r30, r24
     896:	eb 01       	movw	r28, r22
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     898:	92 8d       	ldd	r25, Z+26	; 0x1a

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
     89a:	83 8d       	ldd	r24, Z+27	; 0x1b
     89c:	98 17       	cp	r25, r24
     89e:	10 f0       	brcs	.+4      	; 0x8a4 <xQueueGiveFromISR+0x14>
     8a0:	80 e0       	ldi	r24, 0x00	; 0
     8a2:	16 c0       	rjmp	.+44     	; 0x8d0 <xQueueGiveFromISR+0x40>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
     8a4:	86 8d       	ldd	r24, Z+30	; 0x1e
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     8a6:	9f 5f       	subi	r25, 0xFF	; 255
     8a8:	92 8f       	std	Z+26, r25	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
     8aa:	8f 3f       	cpi	r24, 0xFF	; 255
     8ac:	71 f4       	brne	.+28     	; 0x8ca <xQueueGiveFromISR+0x3a>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     8ae:	81 89       	ldd	r24, Z+17	; 0x11
     8b0:	88 23       	and	r24, r24
     8b2:	69 f0       	breq	.+26     	; 0x8ce <xQueueGiveFromISR+0x3e>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     8b4:	cf 01       	movw	r24, r30
     8b6:	41 96       	adiw	r24, 0x11	; 17
     8b8:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     8bc:	88 23       	and	r24, r24
     8be:	39 f0       	breq	.+14     	; 0x8ce <xQueueGiveFromISR+0x3e>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
     8c0:	20 97       	sbiw	r28, 0x00	; 0
     8c2:	29 f0       	breq	.+10     	; 0x8ce <xQueueGiveFromISR+0x3e>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
     8c4:	81 e0       	ldi	r24, 0x01	; 1
     8c6:	88 83       	st	Y, r24
     8c8:	03 c0       	rjmp	.+6      	; 0x8d0 <xQueueGiveFromISR+0x40>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     8ca:	8f 5f       	subi	r24, 0xFF	; 255
     8cc:	86 8f       	std	Z+30, r24	; 0x1e
     8ce:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	08 95       	ret

000008d6 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
     8d6:	ef 92       	push	r14
     8d8:	ff 92       	push	r15
     8da:	1f 93       	push	r17
     8dc:	cf 93       	push	r28
     8de:	df 93       	push	r29
     8e0:	ec 01       	movw	r28, r24
     8e2:	7a 01       	movw	r14, r20
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     8e4:	9a 8d       	ldd	r25, Y+26	; 0x1a
     8e6:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8e8:	98 17       	cp	r25, r24
     8ea:	20 f0       	brcs	.+8      	; 0x8f4 <xQueueGenericSendFromISR+0x1e>
     8ec:	22 30       	cpi	r18, 0x02	; 2
     8ee:	11 f0       	breq	.+4      	; 0x8f4 <xQueueGenericSendFromISR+0x1e>
     8f0:	80 e0       	ldi	r24, 0x00	; 0
     8f2:	1b c0       	rjmp	.+54     	; 0x92a <xQueueGenericSendFromISR+0x54>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
     8f4:	1e 8d       	ldd	r17, Y+30	; 0x1e
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
     8f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     8f8:	ce 01       	movw	r24, r28
     8fa:	42 2f       	mov	r20, r18
     8fc:	0e 94 c5 02 	call	0x58a	; 0x58a <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
     900:	1f 3f       	cpi	r17, 0xFF	; 255
     902:	81 f4       	brne	.+32     	; 0x924 <xQueueGenericSendFromISR+0x4e>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     904:	89 89       	ldd	r24, Y+17	; 0x11
     906:	88 23       	and	r24, r24
     908:	79 f0       	breq	.+30     	; 0x928 <xQueueGenericSendFromISR+0x52>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     90a:	ce 01       	movw	r24, r28
     90c:	41 96       	adiw	r24, 0x11	; 17
     90e:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     912:	88 23       	and	r24, r24
     914:	49 f0       	breq	.+18     	; 0x928 <xQueueGenericSendFromISR+0x52>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
     916:	e1 14       	cp	r14, r1
     918:	f1 04       	cpc	r15, r1
     91a:	31 f0       	breq	.+12     	; 0x928 <xQueueGenericSendFromISR+0x52>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
     91c:	81 e0       	ldi	r24, 0x01	; 1
     91e:	f7 01       	movw	r30, r14
     920:	80 83       	st	Z, r24
     922:	03 c0       	rjmp	.+6      	; 0x92a <xQueueGenericSendFromISR+0x54>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     924:	1f 5f       	subi	r17, 0xFF	; 255
     926:	1e 8f       	std	Y+30, r17	; 0x1e
     928:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
     92a:	df 91       	pop	r29
     92c:	cf 91       	pop	r28
     92e:	1f 91       	pop	r17
     930:	ff 90       	pop	r15
     932:	ef 90       	pop	r14
     934:	08 95       	ret

00000936 <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     936:	ef 92       	push	r14
     938:	ff 92       	push	r15
     93a:	1f 93       	push	r17
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	ec 01       	movw	r28, r24

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
     942:	0f b6       	in	r0, 0x3f	; 63
     944:	f8 94       	cli
     946:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
     948:	1e 8d       	ldd	r17, Y+30	; 0x1e
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     94a:	91 e1       	ldi	r25, 0x11	; 17
     94c:	e9 2e       	mov	r14, r25
     94e:	f1 2c       	mov	r15, r1
     950:	ec 0e       	add	r14, r28
     952:	fd 1e       	adc	r15, r29
     954:	0b c0       	rjmp	.+22     	; 0x96c <prvUnlockQueue+0x36>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     956:	89 89       	ldd	r24, Y+17	; 0x11
     958:	88 23       	and	r24, r24
     95a:	51 f0       	breq	.+20     	; 0x970 <prvUnlockQueue+0x3a>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     95c:	c7 01       	movw	r24, r14
     95e:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     962:	88 23       	and	r24, r24
     964:	11 f0       	breq	.+4      	; 0x96a <prvUnlockQueue+0x34>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
     966:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
     96a:	11 50       	subi	r17, 0x01	; 1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
     96c:	11 16       	cp	r1, r17
     96e:	9c f3       	brlt	.-26     	; 0x956 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
     970:	8f ef       	ldi	r24, 0xFF	; 255
     972:	8e 8f       	std	Y+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
     974:	0f 90       	pop	r0
     976:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
     978:	0f b6       	in	r0, 0x3f	; 63
     97a:	f8 94       	cli
     97c:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
     97e:	1d 8d       	ldd	r17, Y+29	; 0x1d

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     980:	88 e0       	ldi	r24, 0x08	; 8
     982:	e8 2e       	mov	r14, r24
     984:	f1 2c       	mov	r15, r1
     986:	ec 0e       	add	r14, r28
     988:	fd 1e       	adc	r15, r29
     98a:	0b c0       	rjmp	.+22     	; 0x9a2 <prvUnlockQueue+0x6c>
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     98c:	88 85       	ldd	r24, Y+8	; 0x08
     98e:	88 23       	and	r24, r24
     990:	51 f0       	breq	.+20     	; 0x9a6 <prvUnlockQueue+0x70>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     992:	c7 01       	movw	r24, r14
     994:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     998:	88 23       	and	r24, r24
     99a:	11 f0       	breq	.+4      	; 0x9a0 <prvUnlockQueue+0x6a>
                {
                    vTaskMissedYield();
     99c:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
     9a0:	11 50       	subi	r17, 0x01	; 1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
     9a2:	11 16       	cp	r1, r17
     9a4:	9c f3       	brlt	.-26     	; 0x98c <prvUnlockQueue+0x56>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
     9a6:	8f ef       	ldi	r24, 0xFF	; 255
     9a8:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
     9aa:	0f 90       	pop	r0
     9ac:	0f be       	out	0x3f, r0	; 63
}
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	1f 91       	pop	r17
     9b4:	ff 90       	pop	r15
     9b6:	ef 90       	pop	r14
     9b8:	08 95       	ret

000009ba <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
     9ba:	8f 92       	push	r8
     9bc:	9f 92       	push	r9
     9be:	af 92       	push	r10
     9c0:	bf 92       	push	r11
     9c2:	cf 92       	push	r12
     9c4:	df 92       	push	r13
     9c6:	ef 92       	push	r14
     9c8:	ff 92       	push	r15
     9ca:	0f 93       	push	r16
     9cc:	1f 93       	push	r17
     9ce:	df 93       	push	r29
     9d0:	cf 93       	push	r28
     9d2:	00 d0       	rcall	.+0      	; 0x9d4 <xQueuePeek+0x1a>
     9d4:	00 d0       	rcall	.+0      	; 0x9d6 <xQueuePeek+0x1c>
     9d6:	0f 92       	push	r0
     9d8:	cd b7       	in	r28, 0x3d	; 61
     9da:	de b7       	in	r29, 0x3e	; 62
     9dc:	7c 01       	movw	r14, r24
     9de:	5b 01       	movw	r10, r22
     9e0:	5d 83       	std	Y+5, r21	; 0x05
     9e2:	4c 83       	std	Y+4, r20	; 0x04
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     9e4:	41 e1       	ldi	r20, 0x11	; 17
     9e6:	c4 2e       	mov	r12, r20
     9e8:	d1 2c       	mov	r13, r1
     9ea:	c8 0e       	add	r12, r24
     9ec:	d9 1e       	adc	r13, r25
     9ee:	20 e0       	ldi	r18, 0x00	; 0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     9f0:	8e 01       	movw	r16, r28
     9f2:	0f 5f       	subi	r16, 0xFF	; 255
     9f4:	1f 4f       	sbci	r17, 0xFF	; 255

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     9f6:	34 e0       	ldi	r19, 0x04	; 4
     9f8:	83 2e       	mov	r8, r19
     9fa:	91 2c       	mov	r9, r1
     9fc:	8c 0e       	add	r8, r28
     9fe:	9d 1e       	adc	r9, r29
     a00:	01 c0       	rjmp	.+2      	; 0xa04 <xQueuePeek+0x4a>
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a02:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
     a04:	0f b6       	in	r0, 0x3f	; 63
     a06:	f8 94       	cli
     a08:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     a0a:	f7 01       	movw	r30, r14
     a0c:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     a0e:	88 23       	and	r24, r24
     a10:	b9 f0       	breq	.+46     	; 0xa40 <xQueuePeek+0x86>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
     a12:	06 81       	ldd	r16, Z+6	; 0x06
     a14:	17 81       	ldd	r17, Z+7	; 0x07

                prvCopyDataFromQueue( pxQueue, pvBuffer );
     a16:	c7 01       	movw	r24, r14
     a18:	b5 01       	movw	r22, r10
     a1a:	0e 94 0f 03 	call	0x61e	; 0x61e <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
     a1e:	f7 01       	movw	r30, r14
     a20:	17 83       	std	Z+7, r17	; 0x07
     a22:	06 83       	std	Z+6, r16	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a24:	81 89       	ldd	r24, Z+17	; 0x11
     a26:	88 23       	and	r24, r24
     a28:	39 f0       	breq	.+14     	; 0xa38 <xQueuePeek+0x7e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a2a:	c6 01       	movw	r24, r12
     a2c:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     a30:	88 23       	and	r24, r24
     a32:	11 f0       	breq	.+4      	; 0xa38 <xQueuePeek+0x7e>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
     a34:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
     a38:	0f 90       	pop	r0
     a3a:	0f be       	out	0x3f, r0	; 63
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	54 c0       	rjmp	.+168    	; 0xae8 <xQueuePeek+0x12e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
     a40:	8c 81       	ldd	r24, Y+4	; 0x04
     a42:	9d 81       	ldd	r25, Y+5	; 0x05
     a44:	89 2b       	or	r24, r25
     a46:	21 f4       	brne	.+8      	; 0xa50 <xQueuePeek+0x96>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
     a48:	0f 90       	pop	r0
     a4a:	0f be       	out	0x3f, r0	; 63
     a4c:	80 e0       	ldi	r24, 0x00	; 0
     a4e:	4c c0       	rjmp	.+152    	; 0xae8 <xQueuePeek+0x12e>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
     a50:	22 23       	and	r18, r18
     a52:	19 f4       	brne	.+6      	; 0xa5a <xQueuePeek+0xa0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     a54:	c8 01       	movw	r24, r16
     a56:	0e 94 bb 0a 	call	0x1576	; 0x1576 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
     a5a:	0f 90       	pop	r0
     a5c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
     a5e:	0e 94 21 08 	call	0x1042	; 0x1042 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
     a62:	0f b6       	in	r0, 0x3f	; 63
     a64:	f8 94       	cli
     a66:	0f 92       	push	r0
     a68:	f7 01       	movw	r30, r14
     a6a:	85 8d       	ldd	r24, Z+29	; 0x1d
     a6c:	8f 3f       	cpi	r24, 0xFF	; 255
     a6e:	09 f4       	brne	.+2      	; 0xa72 <xQueuePeek+0xb8>
     a70:	15 8e       	std	Z+29, r1	; 0x1d
     a72:	f7 01       	movw	r30, r14
     a74:	86 8d       	ldd	r24, Z+30	; 0x1e
     a76:	8f 3f       	cpi	r24, 0xFF	; 255
     a78:	09 f4       	brne	.+2      	; 0xa7c <xQueuePeek+0xc2>
     a7a:	16 8e       	std	Z+30, r1	; 0x1e
     a7c:	0f 90       	pop	r0
     a7e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     a80:	c8 01       	movw	r24, r16
     a82:	b4 01       	movw	r22, r8
     a84:	0e 94 c6 0a 	call	0x158c	; 0x158c <xTaskCheckForTimeOut>
     a88:	88 23       	and	r24, r24
     a8a:	f9 f4       	brne	.+62     	; 0xaca <xQueuePeek+0x110>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     a8c:	0f b6       	in	r0, 0x3f	; 63
     a8e:	f8 94       	cli
     a90:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     a92:	f7 01       	movw	r30, r14
     a94:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     a96:	0f 90       	pop	r0
     a98:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     a9a:	88 23       	and	r24, r24
     a9c:	81 f4       	brne	.+32     	; 0xabe <xQueuePeek+0x104>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a9e:	6c 81       	ldd	r22, Y+4	; 0x04
     aa0:	7d 81       	ldd	r23, Y+5	; 0x05
     aa2:	c6 01       	movw	r24, r12
     aa4:	0e 94 60 11 	call	0x22c0	; 0x22c0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
     aa8:	c7 01       	movw	r24, r14
     aaa:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
     aae:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
     ab2:	88 23       	and	r24, r24
     ab4:	09 f0       	breq	.+2      	; 0xab8 <xQueuePeek+0xfe>
     ab6:	a5 cf       	rjmp	.-182    	; 0xa02 <xQueuePeek+0x48>
                {
                    portYIELD_WITHIN_API();
     ab8:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
     abc:	a2 cf       	rjmp	.-188    	; 0xa02 <xQueuePeek+0x48>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
     abe:	c7 01       	movw	r24, r14
     ac0:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
     ac4:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
     ac8:	9c cf       	rjmp	.-200    	; 0xa02 <xQueuePeek+0x48>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
     aca:	c7 01       	movw	r24, r14
     acc:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
     ad0:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     ad4:	0f b6       	in	r0, 0x3f	; 63
     ad6:	f8 94       	cli
     ad8:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     ada:	f7 01       	movw	r30, r14
     adc:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     ade:	0f 90       	pop	r0
     ae0:	0f be       	out	0x3f, r0	; 63
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ae2:	88 23       	and	r24, r24
     ae4:	09 f0       	breq	.+2      	; 0xae8 <xQueuePeek+0x12e>
     ae6:	8d cf       	rjmp	.-230    	; 0xa02 <xQueuePeek+0x48>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
     ae8:	0f 90       	pop	r0
     aea:	0f 90       	pop	r0
     aec:	0f 90       	pop	r0
     aee:	0f 90       	pop	r0
     af0:	0f 90       	pop	r0
     af2:	cf 91       	pop	r28
     af4:	df 91       	pop	r29
     af6:	1f 91       	pop	r17
     af8:	0f 91       	pop	r16
     afa:	ff 90       	pop	r15
     afc:	ef 90       	pop	r14
     afe:	df 90       	pop	r13
     b00:	cf 90       	pop	r12
     b02:	bf 90       	pop	r11
     b04:	af 90       	pop	r10
     b06:	9f 90       	pop	r9
     b08:	8f 90       	pop	r8
     b0a:	08 95       	ret

00000b0c <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
     b0c:	af 92       	push	r10
     b0e:	bf 92       	push	r11
     b10:	cf 92       	push	r12
     b12:	df 92       	push	r13
     b14:	ef 92       	push	r14
     b16:	ff 92       	push	r15
     b18:	0f 93       	push	r16
     b1a:	1f 93       	push	r17
     b1c:	df 93       	push	r29
     b1e:	cf 93       	push	r28
     b20:	00 d0       	rcall	.+0      	; 0xb22 <xQueueSemaphoreTake+0x16>
     b22:	00 d0       	rcall	.+0      	; 0xb24 <xQueueSemaphoreTake+0x18>
     b24:	0f 92       	push	r0
     b26:	cd b7       	in	r28, 0x3d	; 61
     b28:	de b7       	in	r29, 0x3e	; 62
     b2a:	8c 01       	movw	r16, r24
     b2c:	7d 83       	std	Y+5, r23	; 0x05
     b2e:	6c 83       	std	Y+4, r22	; 0x04
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b30:	61 e1       	ldi	r22, 0x11	; 17
     b32:	e6 2e       	mov	r14, r22
     b34:	f1 2c       	mov	r15, r1
     b36:	e8 0e       	add	r14, r24
     b38:	f9 1e       	adc	r15, r25
     b3a:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     b3c:	6e 01       	movw	r12, r28
     b3e:	08 94       	sec
     b40:	c1 1c       	adc	r12, r1
     b42:	d1 1c       	adc	r13, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b44:	54 e0       	ldi	r21, 0x04	; 4
     b46:	a5 2e       	mov	r10, r21
     b48:	b1 2c       	mov	r11, r1
     b4a:	ac 0e       	add	r10, r28
     b4c:	bd 1e       	adc	r11, r29
     b4e:	01 c0       	rjmp	.+2      	; 0xb52 <xQueueSemaphoreTake+0x46>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b50:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
     b52:	0f b6       	in	r0, 0x3f	; 63
     b54:	f8 94       	cli
     b56:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
     b58:	f8 01       	movw	r30, r16
     b5a:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
     b5c:	88 23       	and	r24, r24
     b5e:	89 f0       	breq	.+34     	; 0xb82 <xQueueSemaphoreTake+0x76>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
     b60:	81 50       	subi	r24, 0x01	; 1
     b62:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b64:	80 85       	ldd	r24, Z+8	; 0x08
     b66:	88 23       	and	r24, r24
     b68:	41 f0       	breq	.+16     	; 0xb7a <xQueueSemaphoreTake+0x6e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b6a:	c8 01       	movw	r24, r16
     b6c:	08 96       	adiw	r24, 0x08	; 8
     b6e:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     b72:	88 23       	and	r24, r24
     b74:	11 f0       	breq	.+4      	; 0xb7a <xQueueSemaphoreTake+0x6e>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
     b76:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
     b7a:	0f 90       	pop	r0
     b7c:	0f be       	out	0x3f, r0	; 63
     b7e:	81 e0       	ldi	r24, 0x01	; 1
     b80:	54 c0       	rjmp	.+168    	; 0xc2a <xQueueSemaphoreTake+0x11e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
     b82:	8c 81       	ldd	r24, Y+4	; 0x04
     b84:	9d 81       	ldd	r25, Y+5	; 0x05
     b86:	89 2b       	or	r24, r25
     b88:	21 f4       	brne	.+8      	; 0xb92 <xQueueSemaphoreTake+0x86>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
     b8a:	0f 90       	pop	r0
     b8c:	0f be       	out	0x3f, r0	; 63
     b8e:	80 e0       	ldi	r24, 0x00	; 0
     b90:	4c c0       	rjmp	.+152    	; 0xc2a <xQueueSemaphoreTake+0x11e>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
     b92:	22 23       	and	r18, r18
     b94:	19 f4       	brne	.+6      	; 0xb9c <xQueueSemaphoreTake+0x90>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     b96:	c6 01       	movw	r24, r12
     b98:	0e 94 bb 0a 	call	0x1576	; 0x1576 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
     b9c:	0f 90       	pop	r0
     b9e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
     ba0:	0e 94 21 08 	call	0x1042	; 0x1042 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
     ba4:	0f b6       	in	r0, 0x3f	; 63
     ba6:	f8 94       	cli
     ba8:	0f 92       	push	r0
     baa:	f8 01       	movw	r30, r16
     bac:	85 8d       	ldd	r24, Z+29	; 0x1d
     bae:	8f 3f       	cpi	r24, 0xFF	; 255
     bb0:	09 f4       	brne	.+2      	; 0xbb4 <xQueueSemaphoreTake+0xa8>
     bb2:	15 8e       	std	Z+29, r1	; 0x1d
     bb4:	f8 01       	movw	r30, r16
     bb6:	86 8d       	ldd	r24, Z+30	; 0x1e
     bb8:	8f 3f       	cpi	r24, 0xFF	; 255
     bba:	09 f4       	brne	.+2      	; 0xbbe <xQueueSemaphoreTake+0xb2>
     bbc:	16 8e       	std	Z+30, r1	; 0x1e
     bbe:	0f 90       	pop	r0
     bc0:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     bc2:	c6 01       	movw	r24, r12
     bc4:	b5 01       	movw	r22, r10
     bc6:	0e 94 c6 0a 	call	0x158c	; 0x158c <xTaskCheckForTimeOut>
     bca:	88 23       	and	r24, r24
     bcc:	f9 f4       	brne	.+62     	; 0xc0c <xQueueSemaphoreTake+0x100>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     bce:	0f b6       	in	r0, 0x3f	; 63
     bd0:	f8 94       	cli
     bd2:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     bd4:	f8 01       	movw	r30, r16
     bd6:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     bdc:	88 23       	and	r24, r24
     bde:	81 f4       	brne	.+32     	; 0xc00 <xQueueSemaphoreTake+0xf4>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     be0:	6c 81       	ldd	r22, Y+4	; 0x04
     be2:	7d 81       	ldd	r23, Y+5	; 0x05
     be4:	c7 01       	movw	r24, r14
     be6:	0e 94 60 11 	call	0x22c0	; 0x22c0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
     bea:	c8 01       	movw	r24, r16
     bec:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
     bf0:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
     bf4:	88 23       	and	r24, r24
     bf6:	09 f0       	breq	.+2      	; 0xbfa <xQueueSemaphoreTake+0xee>
     bf8:	ab cf       	rjmp	.-170    	; 0xb50 <xQueueSemaphoreTake+0x44>
                {
                    portYIELD_WITHIN_API();
     bfa:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
     bfe:	a8 cf       	rjmp	.-176    	; 0xb50 <xQueueSemaphoreTake+0x44>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
     c00:	c8 01       	movw	r24, r16
     c02:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
     c06:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
     c0a:	a2 cf       	rjmp	.-188    	; 0xb50 <xQueueSemaphoreTake+0x44>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
     c0c:	c8 01       	movw	r24, r16
     c0e:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
     c12:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     c16:	0f b6       	in	r0, 0x3f	; 63
     c18:	f8 94       	cli
     c1a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     c1c:	f8 01       	movw	r30, r16
     c1e:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     c20:	0f 90       	pop	r0
     c22:	0f be       	out	0x3f, r0	; 63

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     c24:	88 23       	and	r24, r24
     c26:	09 f0       	breq	.+2      	; 0xc2a <xQueueSemaphoreTake+0x11e>
     c28:	93 cf       	rjmp	.-218    	; 0xb50 <xQueueSemaphoreTake+0x44>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
     c2a:	0f 90       	pop	r0
     c2c:	0f 90       	pop	r0
     c2e:	0f 90       	pop	r0
     c30:	0f 90       	pop	r0
     c32:	0f 90       	pop	r0
     c34:	cf 91       	pop	r28
     c36:	df 91       	pop	r29
     c38:	1f 91       	pop	r17
     c3a:	0f 91       	pop	r16
     c3c:	ff 90       	pop	r15
     c3e:	ef 90       	pop	r14
     c40:	df 90       	pop	r13
     c42:	cf 90       	pop	r12
     c44:	bf 90       	pop	r11
     c46:	af 90       	pop	r10
     c48:	08 95       	ret

00000c4a <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
     c4a:	6f 92       	push	r6
     c4c:	7f 92       	push	r7
     c4e:	8f 92       	push	r8
     c50:	9f 92       	push	r9
     c52:	af 92       	push	r10
     c54:	bf 92       	push	r11
     c56:	cf 92       	push	r12
     c58:	df 92       	push	r13
     c5a:	ff 92       	push	r15
     c5c:	0f 93       	push	r16
     c5e:	1f 93       	push	r17
     c60:	df 93       	push	r29
     c62:	cf 93       	push	r28
     c64:	00 d0       	rcall	.+0      	; 0xc66 <xQueueReceive+0x1c>
     c66:	00 d0       	rcall	.+0      	; 0xc68 <xQueueReceive+0x1e>
     c68:	0f 92       	push	r0
     c6a:	cd b7       	in	r28, 0x3d	; 61
     c6c:	de b7       	in	r29, 0x3e	; 62
     c6e:	8c 01       	movw	r16, r24
     c70:	5b 01       	movw	r10, r22
     c72:	5d 83       	std	Y+5, r21	; 0x05
     c74:	4c 83       	std	Y+4, r20	; 0x04
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c76:	e1 e1       	ldi	r30, 0x11	; 17
     c78:	ce 2e       	mov	r12, r30
     c7a:	d1 2c       	mov	r13, r1
     c7c:	c8 0e       	add	r12, r24
     c7e:	d9 1e       	adc	r13, r25
     c80:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     c82:	4e 01       	movw	r8, r28
     c84:	08 94       	sec
     c86:	81 1c       	adc	r8, r1
     c88:	91 1c       	adc	r9, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c8a:	74 e0       	ldi	r23, 0x04	; 4
     c8c:	67 2e       	mov	r6, r23
     c8e:	71 2c       	mov	r7, r1
     c90:	6c 0e       	add	r6, r28
     c92:	7d 1e       	adc	r7, r29
     c94:	01 c0       	rjmp	.+2      	; 0xc98 <xQueueReceive+0x4e>
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c96:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
     c98:	0f b6       	in	r0, 0x3f	; 63
     c9a:	f8 94       	cli
     c9c:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     c9e:	f8 01       	movw	r30, r16
     ca0:	f2 8c       	ldd	r15, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     ca2:	ff 20       	and	r15, r15
     ca4:	b1 f0       	breq	.+44     	; 0xcd2 <xQueueReceive+0x88>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
     ca6:	c8 01       	movw	r24, r16
     ca8:	b5 01       	movw	r22, r10
     caa:	0e 94 0f 03 	call	0x61e	; 0x61e <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
     cae:	fa 94       	dec	r15
     cb0:	f8 01       	movw	r30, r16
     cb2:	f2 8e       	std	Z+26, r15	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cb4:	80 85       	ldd	r24, Z+8	; 0x08
     cb6:	88 23       	and	r24, r24
     cb8:	41 f0       	breq	.+16     	; 0xcca <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     cba:	c8 01       	movw	r24, r16
     cbc:	08 96       	adiw	r24, 0x08	; 8
     cbe:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     cc2:	88 23       	and	r24, r24
     cc4:	11 f0       	breq	.+4      	; 0xcca <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
     cc6:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
     cca:	0f 90       	pop	r0
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	81 e0       	ldi	r24, 0x01	; 1
     cd0:	54 c0       	rjmp	.+168    	; 0xd7a <xQueueReceive+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
     cd2:	8c 81       	ldd	r24, Y+4	; 0x04
     cd4:	9d 81       	ldd	r25, Y+5	; 0x05
     cd6:	89 2b       	or	r24, r25
     cd8:	21 f4       	brne	.+8      	; 0xce2 <xQueueReceive+0x98>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
     cda:	0f 90       	pop	r0
     cdc:	0f be       	out	0x3f, r0	; 63
     cde:	80 e0       	ldi	r24, 0x00	; 0
     ce0:	4c c0       	rjmp	.+152    	; 0xd7a <xQueueReceive+0x130>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
     ce2:	22 23       	and	r18, r18
     ce4:	19 f4       	brne	.+6      	; 0xcec <xQueueReceive+0xa2>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     ce6:	c4 01       	movw	r24, r8
     ce8:	0e 94 bb 0a 	call	0x1576	; 0x1576 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
     cec:	0f 90       	pop	r0
     cee:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
     cf0:	0e 94 21 08 	call	0x1042	; 0x1042 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
     cf4:	0f b6       	in	r0, 0x3f	; 63
     cf6:	f8 94       	cli
     cf8:	0f 92       	push	r0
     cfa:	f8 01       	movw	r30, r16
     cfc:	85 8d       	ldd	r24, Z+29	; 0x1d
     cfe:	8f 3f       	cpi	r24, 0xFF	; 255
     d00:	09 f4       	brne	.+2      	; 0xd04 <xQueueReceive+0xba>
     d02:	15 8e       	std	Z+29, r1	; 0x1d
     d04:	f8 01       	movw	r30, r16
     d06:	86 8d       	ldd	r24, Z+30	; 0x1e
     d08:	8f 3f       	cpi	r24, 0xFF	; 255
     d0a:	09 f4       	brne	.+2      	; 0xd0e <xQueueReceive+0xc4>
     d0c:	16 8e       	std	Z+30, r1	; 0x1e
     d0e:	0f 90       	pop	r0
     d10:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d12:	c4 01       	movw	r24, r8
     d14:	b3 01       	movw	r22, r6
     d16:	0e 94 c6 0a 	call	0x158c	; 0x158c <xTaskCheckForTimeOut>
     d1a:	88 23       	and	r24, r24
     d1c:	f9 f4       	brne	.+62     	; 0xd5c <xQueueReceive+0x112>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     d1e:	0f b6       	in	r0, 0x3f	; 63
     d20:	f8 94       	cli
     d22:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     d24:	f8 01       	movw	r30, r16
     d26:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     d28:	0f 90       	pop	r0
     d2a:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     d2c:	88 23       	and	r24, r24
     d2e:	81 f4       	brne	.+32     	; 0xd50 <xQueueReceive+0x106>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d30:	6c 81       	ldd	r22, Y+4	; 0x04
     d32:	7d 81       	ldd	r23, Y+5	; 0x05
     d34:	c6 01       	movw	r24, r12
     d36:	0e 94 60 11 	call	0x22c0	; 0x22c0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
     d3a:	c8 01       	movw	r24, r16
     d3c:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
     d40:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
     d44:	88 23       	and	r24, r24
     d46:	09 f0       	breq	.+2      	; 0xd4a <xQueueReceive+0x100>
     d48:	a6 cf       	rjmp	.-180    	; 0xc96 <xQueueReceive+0x4c>
                {
                    portYIELD_WITHIN_API();
     d4a:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
     d4e:	a3 cf       	rjmp	.-186    	; 0xc96 <xQueueReceive+0x4c>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
     d50:	c8 01       	movw	r24, r16
     d52:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
     d56:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
     d5a:	9d cf       	rjmp	.-198    	; 0xc96 <xQueueReceive+0x4c>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
     d5c:	c8 01       	movw	r24, r16
     d5e:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
     d62:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     d66:	0f b6       	in	r0, 0x3f	; 63
     d68:	f8 94       	cli
     d6a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     d6c:	f8 01       	movw	r30, r16
     d6e:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     d70:	0f 90       	pop	r0
     d72:	0f be       	out	0x3f, r0	; 63
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     d74:	88 23       	and	r24, r24
     d76:	09 f0       	breq	.+2      	; 0xd7a <xQueueReceive+0x130>
     d78:	8e cf       	rjmp	.-228    	; 0xc96 <xQueueReceive+0x4c>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
     d7a:	0f 90       	pop	r0
     d7c:	0f 90       	pop	r0
     d7e:	0f 90       	pop	r0
     d80:	0f 90       	pop	r0
     d82:	0f 90       	pop	r0
     d84:	cf 91       	pop	r28
     d86:	df 91       	pop	r29
     d88:	1f 91       	pop	r17
     d8a:	0f 91       	pop	r16
     d8c:	ff 90       	pop	r15
     d8e:	df 90       	pop	r13
     d90:	cf 90       	pop	r12
     d92:	bf 90       	pop	r11
     d94:	af 90       	pop	r10
     d96:	9f 90       	pop	r9
     d98:	8f 90       	pop	r8
     d9a:	7f 90       	pop	r7
     d9c:	6f 90       	pop	r6
     d9e:	08 95       	ret

00000da0 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
     da0:	6f 92       	push	r6
     da2:	7f 92       	push	r7
     da4:	9f 92       	push	r9
     da6:	af 92       	push	r10
     da8:	bf 92       	push	r11
     daa:	cf 92       	push	r12
     dac:	df 92       	push	r13
     dae:	ef 92       	push	r14
     db0:	ff 92       	push	r15
     db2:	0f 93       	push	r16
     db4:	1f 93       	push	r17
     db6:	df 93       	push	r29
     db8:	cf 93       	push	r28
     dba:	00 d0       	rcall	.+0      	; 0xdbc <xQueueGenericSend+0x1c>
     dbc:	00 d0       	rcall	.+0      	; 0xdbe <xQueueGenericSend+0x1e>
     dbe:	0f 92       	push	r0
     dc0:	cd b7       	in	r28, 0x3d	; 61
     dc2:	de b7       	in	r29, 0x3e	; 62
     dc4:	8c 01       	movw	r16, r24
     dc6:	6b 01       	movw	r12, r22
     dc8:	5d 83       	std	Y+5, r21	; 0x05
     dca:	4c 83       	std	Y+4, r20	; 0x04
     dcc:	92 2e       	mov	r9, r18
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     dce:	a8 e0       	ldi	r26, 0x08	; 8
     dd0:	ea 2e       	mov	r14, r26
     dd2:	f1 2c       	mov	r15, r1
     dd4:	e8 0e       	add	r14, r24
     dd6:	f9 1e       	adc	r15, r25
     dd8:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     dda:	5e 01       	movw	r10, r28
     ddc:	08 94       	sec
     dde:	a1 1c       	adc	r10, r1
     de0:	b1 1c       	adc	r11, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     de2:	f4 e0       	ldi	r31, 0x04	; 4
     de4:	6f 2e       	mov	r6, r31
     de6:	71 2c       	mov	r7, r1
     de8:	6c 0e       	add	r6, r28
     dea:	7d 1e       	adc	r7, r29
     dec:	01 c0       	rjmp	.+2      	; 0xdf0 <xQueueGenericSend+0x50>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     dee:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
     df0:	0f b6       	in	r0, 0x3f	; 63
     df2:	f8 94       	cli
     df4:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     df6:	f8 01       	movw	r30, r16
     df8:	92 8d       	ldd	r25, Z+26	; 0x1a
     dfa:	83 8d       	ldd	r24, Z+27	; 0x1b
     dfc:	98 17       	cp	r25, r24
     dfe:	18 f0       	brcs	.+6      	; 0xe06 <xQueueGenericSend+0x66>
     e00:	f2 e0       	ldi	r31, 0x02	; 2
     e02:	9f 16       	cp	r9, r31
     e04:	c9 f4       	brne	.+50     	; 0xe38 <xQueueGenericSend+0x98>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e06:	c8 01       	movw	r24, r16
     e08:	b6 01       	movw	r22, r12
     e0a:	49 2d       	mov	r20, r9
     e0c:	0e 94 c5 02 	call	0x58a	; 0x58a <prvCopyDataToQueue>
     e10:	98 2f       	mov	r25, r24

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e12:	f8 01       	movw	r30, r16
     e14:	81 89       	ldd	r24, Z+17	; 0x11
     e16:	88 23       	and	r24, r24
     e18:	39 f0       	breq	.+14     	; 0xe28 <xQueueGenericSend+0x88>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e1a:	c8 01       	movw	r24, r16
     e1c:	41 96       	adiw	r24, 0x11	; 17
     e1e:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     e22:	88 23       	and	r24, r24
     e24:	29 f0       	breq	.+10     	; 0xe30 <xQueueGenericSend+0x90>
     e26:	02 c0       	rjmp	.+4      	; 0xe2c <xQueueGenericSend+0x8c>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
     e28:	99 23       	and	r25, r25
     e2a:	11 f0       	breq	.+4      	; 0xe30 <xQueueGenericSend+0x90>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
     e2c:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
     e30:	0f 90       	pop	r0
     e32:	0f be       	out	0x3f, r0	; 63
     e34:	81 e0       	ldi	r24, 0x01	; 1
     e36:	4c c0       	rjmp	.+152    	; 0xed0 <xQueueGenericSend+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
     e38:	8c 81       	ldd	r24, Y+4	; 0x04
     e3a:	9d 81       	ldd	r25, Y+5	; 0x05
     e3c:	89 2b       	or	r24, r25
     e3e:	19 f4       	brne	.+6      	; 0xe46 <xQueueGenericSend+0xa6>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
     e40:	0f 90       	pop	r0
     e42:	0f be       	out	0x3f, r0	; 63
     e44:	44 c0       	rjmp	.+136    	; 0xece <xQueueGenericSend+0x12e>
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
     e46:	22 23       	and	r18, r18
     e48:	19 f4       	brne	.+6      	; 0xe50 <xQueueGenericSend+0xb0>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
     e4a:	c5 01       	movw	r24, r10
     e4c:	0e 94 bb 0a 	call	0x1576	; 0x1576 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
     e50:	0f 90       	pop	r0
     e52:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
     e54:	0e 94 21 08 	call	0x1042	; 0x1042 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
     e58:	0f b6       	in	r0, 0x3f	; 63
     e5a:	f8 94       	cli
     e5c:	0f 92       	push	r0
     e5e:	f8 01       	movw	r30, r16
     e60:	85 8d       	ldd	r24, Z+29	; 0x1d
     e62:	8f 3f       	cpi	r24, 0xFF	; 255
     e64:	09 f4       	brne	.+2      	; 0xe68 <xQueueGenericSend+0xc8>
     e66:	15 8e       	std	Z+29, r1	; 0x1d
     e68:	f8 01       	movw	r30, r16
     e6a:	86 8d       	ldd	r24, Z+30	; 0x1e
     e6c:	8f 3f       	cpi	r24, 0xFF	; 255
     e6e:	09 f4       	brne	.+2      	; 0xe72 <xQueueGenericSend+0xd2>
     e70:	16 8e       	std	Z+30, r1	; 0x1e
     e72:	0f 90       	pop	r0
     e74:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e76:	c5 01       	movw	r24, r10
     e78:	b3 01       	movw	r22, r6
     e7a:	0e 94 c6 0a 	call	0x158c	; 0x158c <xTaskCheckForTimeOut>
     e7e:	88 23       	and	r24, r24
     e80:	09 f5       	brne	.+66     	; 0xec4 <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
     e82:	0f b6       	in	r0, 0x3f	; 63
     e84:	f8 94       	cli
     e86:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     e88:	f8 01       	movw	r30, r16
     e8a:	92 8d       	ldd	r25, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
     e8c:	0f 90       	pop	r0
     e8e:	0f be       	out	0x3f, r0	; 63
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
     e90:	f8 01       	movw	r30, r16
     e92:	83 8d       	ldd	r24, Z+27	; 0x1b
     e94:	98 17       	cp	r25, r24
     e96:	81 f4       	brne	.+32     	; 0xeb8 <xQueueGenericSend+0x118>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e98:	6c 81       	ldd	r22, Y+4	; 0x04
     e9a:	7d 81       	ldd	r23, Y+5	; 0x05
     e9c:	c7 01       	movw	r24, r14
     e9e:	0e 94 60 11 	call	0x22c0	; 0x22c0 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
     ea2:	c8 01       	movw	r24, r16
     ea4:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
     ea8:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
     eac:	88 23       	and	r24, r24
     eae:	09 f0       	breq	.+2      	; 0xeb2 <xQueueGenericSend+0x112>
     eb0:	9e cf       	rjmp	.-196    	; 0xdee <xQueueGenericSend+0x4e>
                {
                    portYIELD_WITHIN_API();
     eb2:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
     eb6:	9b cf       	rjmp	.-202    	; 0xdee <xQueueGenericSend+0x4e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
     eb8:	c8 01       	movw	r24, r16
     eba:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
     ebe:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
     ec2:	95 cf       	rjmp	.-214    	; 0xdee <xQueueGenericSend+0x4e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
     ec4:	c8 01       	movw	r24, r16
     ec6:	0e 94 9b 04 	call	0x936	; 0x936 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
     eca:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
     ece:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
     ed0:	0f 90       	pop	r0
     ed2:	0f 90       	pop	r0
     ed4:	0f 90       	pop	r0
     ed6:	0f 90       	pop	r0
     ed8:	0f 90       	pop	r0
     eda:	cf 91       	pop	r28
     edc:	df 91       	pop	r29
     ede:	1f 91       	pop	r17
     ee0:	0f 91       	pop	r16
     ee2:	ff 90       	pop	r15
     ee4:	ef 90       	pop	r14
     ee6:	df 90       	pop	r13
     ee8:	cf 90       	pop	r12
     eea:	bf 90       	pop	r11
     eec:	af 90       	pop	r10
     eee:	9f 90       	pop	r9
     ef0:	7f 90       	pop	r7
     ef2:	6f 90       	pop	r6
     ef4:	08 95       	ret

00000ef6 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
     ef6:	cf 93       	push	r28
     ef8:	df 93       	push	r29
     efa:	ec 01       	movw	r28, r24
     efc:	e6 2f       	mov	r30, r22
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
     efe:	00 97       	sbiw	r24, 0x00	; 0
     f00:	09 f4       	brne	.+2      	; 0xf04 <xQueueGenericReset+0xe>
     f02:	4f c0       	rjmp	.+158    	; 0xfa2 <xQueueGenericReset+0xac>
     f04:	2b 8d       	ldd	r18, Y+27	; 0x1b
     f06:	22 23       	and	r18, r18
     f08:	09 f4       	brne	.+2      	; 0xf0c <xQueueGenericReset+0x16>
     f0a:	4b c0       	rjmp	.+150    	; 0xfa2 <xQueueGenericReset+0xac>
     f0c:	3c 8d       	ldd	r19, Y+28	; 0x1c
     f0e:	8f ef       	ldi	r24, 0xFF	; 255
     f10:	9f e7       	ldi	r25, 0x7F	; 127
     f12:	62 2f       	mov	r22, r18
     f14:	70 e0       	ldi	r23, 0x00	; 0
     f16:	0e 94 80 1b 	call	0x3700	; 0x3700 <__udivmodhi4>
     f1a:	83 2f       	mov	r24, r19
     f1c:	90 e0       	ldi	r25, 0x00	; 0
     f1e:	68 17       	cp	r22, r24
     f20:	79 07       	cpc	r23, r25
     f22:	08 f4       	brcc	.+2      	; 0xf26 <xQueueGenericReset+0x30>
     f24:	3e c0       	rjmp	.+124    	; 0xfa2 <xQueueGenericReset+0xac>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
     f26:	0f b6       	in	r0, 0x3f	; 63
     f28:	f8 94       	cli
     f2a:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
     f2c:	32 9f       	mul	r19, r18
     f2e:	c0 01       	movw	r24, r0
     f30:	11 24       	eor	r1, r1
     f32:	48 81       	ld	r20, Y
     f34:	59 81       	ldd	r21, Y+1	; 0x01
     f36:	84 0f       	add	r24, r20
     f38:	95 1f       	adc	r25, r21
     f3a:	9d 83       	std	Y+5, r25	; 0x05
     f3c:	8c 83       	std	Y+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     f3e:	1a 8e       	std	Y+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
     f40:	5b 83       	std	Y+3, r21	; 0x03
     f42:	4a 83       	std	Y+2, r20	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
     f44:	2b 8d       	ldd	r18, Y+27	; 0x1b
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	21 50       	subi	r18, 0x01	; 1
     f4a:	30 40       	sbci	r19, 0x00	; 0
     f4c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	bc 01       	movw	r22, r24
     f52:	26 9f       	mul	r18, r22
     f54:	c0 01       	movw	r24, r0
     f56:	27 9f       	mul	r18, r23
     f58:	90 0d       	add	r25, r0
     f5a:	36 9f       	mul	r19, r22
     f5c:	90 0d       	add	r25, r0
     f5e:	11 24       	eor	r1, r1
     f60:	48 0f       	add	r20, r24
     f62:	59 1f       	adc	r21, r25
     f64:	5f 83       	std	Y+7, r21	; 0x07
     f66:	4e 83       	std	Y+6, r20	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
     f68:	8f ef       	ldi	r24, 0xFF	; 255
     f6a:	8d 8f       	std	Y+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
     f6c:	8e 8f       	std	Y+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
     f6e:	ee 23       	and	r30, r30
     f70:	61 f4       	brne	.+24     	; 0xf8a <xQueueGenericReset+0x94>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f72:	88 85       	ldd	r24, Y+8	; 0x08
     f74:	88 23       	and	r24, r24
     f76:	89 f0       	breq	.+34     	; 0xf9a <xQueueGenericReset+0xa4>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     f78:	ce 01       	movw	r24, r28
     f7a:	08 96       	adiw	r24, 0x08	; 8
     f7c:	0e 94 5e 09 	call	0x12bc	; 0x12bc <xTaskRemoveFromEventList>
     f80:	88 23       	and	r24, r24
     f82:	59 f0       	breq	.+22     	; 0xf9a <xQueueGenericReset+0xa4>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
     f84:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
     f88:	08 c0       	rjmp	.+16     	; 0xf9a <xQueueGenericReset+0xa4>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     f8a:	ce 01       	movw	r24, r28
     f8c:	08 96       	adiw	r24, 0x08	; 8
     f8e:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     f92:	ce 01       	movw	r24, r28
     f94:	41 96       	adiw	r24, 0x11	; 17
     f96:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
     f9a:	0f 90       	pop	r0
     f9c:	0f be       	out	0x3f, r0	; 63
     f9e:	81 e0       	ldi	r24, 0x01	; 1
     fa0:	01 c0       	rjmp	.+2      	; 0xfa4 <xQueueGenericReset+0xae>
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
     fa2:	80 e0       	ldi	r24, 0x00	; 0
    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
}
     fa4:	df 91       	pop	r29
     fa6:	cf 91       	pop	r28
     fa8:	08 95       	ret

00000faa <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
     faa:	0f 93       	push	r16
     fac:	1f 93       	push	r17
     fae:	cf 93       	push	r28
     fb0:	df 93       	push	r29
     fb2:	18 2f       	mov	r17, r24
     fb4:	06 2f       	mov	r16, r22
        Queue_t * pxNewQueue = NULL;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
     fb6:	88 23       	and	r24, r24
     fb8:	41 f1       	breq	.+80     	; 0x100a <xQueueGenericCreate+0x60>
     fba:	8f ef       	ldi	r24, 0xFF	; 255
     fbc:	9f e7       	ldi	r25, 0x7F	; 127
     fbe:	61 2f       	mov	r22, r17
     fc0:	70 e0       	ldi	r23, 0x00	; 0
     fc2:	0e 94 80 1b 	call	0x3700	; 0x3700 <__udivmodhi4>
     fc6:	80 2f       	mov	r24, r16
     fc8:	90 e0       	ldi	r25, 0x00	; 0
     fca:	68 17       	cp	r22, r24
     fcc:	79 07       	cpc	r23, r25
     fce:	e8 f0       	brcs	.+58     	; 0x100a <xQueueGenericCreate+0x60>
     fd0:	01 9f       	mul	r16, r17
     fd2:	c0 01       	movw	r24, r0
     fd4:	11 24       	eor	r1, r1
     fd6:	2f e7       	ldi	r18, 0x7F	; 127
     fd8:	81 3e       	cpi	r24, 0xE1	; 225
     fda:	92 07       	cpc	r25, r18
     fdc:	b0 f4       	brcc	.+44     	; 0x100a <xQueueGenericCreate+0x60>
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
     fde:	4f 96       	adiw	r24, 0x1f	; 31
     fe0:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <pvPortMalloc>
     fe4:	fc 01       	movw	r30, r24
     fe6:	ec 01       	movw	r28, r24

            if( pxNewQueue != NULL )
     fe8:	00 97       	sbiw	r24, 0x00	; 0
     fea:	89 f0       	breq	.+34     	; 0x100e <xQueueGenericCreate+0x64>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
     fec:	00 23       	and	r16, r16
     fee:	19 f4       	brne	.+6      	; 0xff6 <xQueueGenericCreate+0x4c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     ff0:	91 83       	std	Z+1, r25	; 0x01
     ff2:	80 83       	st	Z, r24
     ff4:	03 c0       	rjmp	.+6      	; 0xffc <xQueueGenericCreate+0x52>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     ff6:	4f 96       	adiw	r24, 0x1f	; 31
     ff8:	91 83       	std	Z+1, r25	; 0x01
     ffa:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
     ffc:	13 8f       	std	Z+27, r17	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
     ffe:	04 8f       	std	Z+28, r16	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1000:	cf 01       	movw	r24, r30
    1002:	61 e0       	ldi	r22, 0x01	; 1
    1004:	0e 94 7b 07 	call	0xef6	; 0xef6 <xQueueGenericReset>
    1008:	02 c0       	rjmp	.+4      	; 0x100e <xQueueGenericCreate+0x64>
    100a:	c0 e0       	ldi	r28, 0x00	; 0
    100c:	d0 e0       	ldi	r29, 0x00	; 0
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
    100e:	ce 01       	movw	r24, r28
    1010:	df 91       	pop	r29
    1012:	cf 91       	pop	r28
    1014:	1f 91       	pop	r17
    1016:	0f 91       	pop	r16
    1018:	08 95       	ret

0000101a <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
    101a:	1f 93       	push	r17
    101c:	16 2f       	mov	r17, r22
        QueueHandle_t xHandle = NULL;

        if( ( uxMaxCount != 0 ) &&
    101e:	88 23       	and	r24, r24
    1020:	59 f0       	breq	.+22     	; 0x1038 <xQueueCreateCountingSemaphore+0x1e>
    1022:	86 17       	cp	r24, r22
    1024:	48 f0       	brcs	.+18     	; 0x1038 <xQueueCreateCountingSemaphore+0x1e>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    1026:	60 e0       	ldi	r22, 0x00	; 0
    1028:	42 e0       	ldi	r20, 0x02	; 2
    102a:	0e 94 d5 07 	call	0xfaa	; 0xfaa <xQueueGenericCreate>
    102e:	fc 01       	movw	r30, r24

            if( xHandle != NULL )
    1030:	00 97       	sbiw	r24, 0x00	; 0
    1032:	21 f0       	breq	.+8      	; 0x103c <xQueueCreateCountingSemaphore+0x22>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    1034:	12 8f       	std	Z+26, r17	; 0x1a
    1036:	02 c0       	rjmp	.+4      	; 0x103c <xQueueCreateCountingSemaphore+0x22>
    1038:	e0 e0       	ldi	r30, 0x00	; 0
    103a:	f0 e0       	ldi	r31, 0x00	; 0
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
    }
    103c:	cf 01       	movw	r24, r30
    103e:	1f 91       	pop	r17
    1040:	08 95       	ret

00001042 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    1042:	80 91 d4 00 	lds	r24, 0x00D4
    1046:	8f 5f       	subi	r24, 0xFF	; 255
    1048:	80 93 d4 00 	sts	0x00D4, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    104c:	08 95       	ret

0000104e <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    1054:	20 91 d7 00 	lds	r18, 0x00D7
    1058:	30 91 d8 00 	lds	r19, 0x00D8
    }
    portTICK_TYPE_EXIT_CRITICAL();
    105c:	0f 90       	pop	r0
    105e:	0f be       	out	0x3f, r0	; 63

    return xTicks;
}
    1060:	c9 01       	movw	r24, r18
    1062:	08 95       	ret

00001064 <xTaskGetTickCountFromISR>:
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    1064:	20 91 d7 00 	lds	r18, 0x00D7
    1068:	30 91 d8 00 	lds	r19, 0x00D8
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    106c:	c9 01       	movw	r24, r18
    106e:	08 95       	ret

00001070 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    1070:	80 91 de 00 	lds	r24, 0x00DE
}
    1074:	08 95       	ret

00001076 <pcTaskGetName>:
{
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1076:	00 97       	sbiw	r24, 0x00	; 0
    1078:	21 f4       	brne	.+8      	; 0x1082 <pcTaskGetName+0xc>
    107a:	80 91 d2 00 	lds	r24, 0x00D2
    107e:	90 91 d3 00 	lds	r25, 0x00D3
    1082:	9c 01       	movw	r18, r24
    1084:	27 5e       	subi	r18, 0xE7	; 231
    1086:	3f 4f       	sbci	r19, 0xFF	; 255
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
}
    1088:	c9 01       	movw	r24, r18
    108a:	08 95       	ret

0000108c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    108c:	ef 92       	push	r14
    108e:	ff 92       	push	r15
    1090:	0f 93       	push	r16
    1092:	1f 93       	push	r17
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1098:	80 91 d4 00 	lds	r24, 0x00D4
    109c:	88 23       	and	r24, r24
    109e:	09 f0       	breq	.+2      	; 0x10a2 <xTaskIncrementTick+0x16>
    10a0:	fb c0       	rjmp	.+502    	; 0x1298 <xTaskIncrementTick+0x20c>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    10a2:	00 91 d7 00 	lds	r16, 0x00D7
    10a6:	10 91 d8 00 	lds	r17, 0x00D8
    10aa:	0f 5f       	subi	r16, 0xFF	; 255
    10ac:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    10ae:	10 93 d8 00 	sts	0x00D8, r17
    10b2:	00 93 d7 00 	sts	0x00D7, r16

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    10b6:	01 15       	cp	r16, r1
    10b8:	11 05       	cpc	r17, r1
    10ba:	61 f5       	brne	.+88     	; 0x1114 <xTaskIncrementTick+0x88>
        {
            taskSWITCH_DELAYED_LISTS();
    10bc:	20 91 1a 01 	lds	r18, 0x011A
    10c0:	30 91 1b 01 	lds	r19, 0x011B
    10c4:	80 91 1c 01 	lds	r24, 0x011C
    10c8:	90 91 1d 01 	lds	r25, 0x011D
    10cc:	90 93 1b 01 	sts	0x011B, r25
    10d0:	80 93 1a 01 	sts	0x011A, r24
    10d4:	30 93 1d 01 	sts	0x011D, r19
    10d8:	20 93 1c 01 	sts	0x011C, r18
    10dc:	80 91 db 00 	lds	r24, 0x00DB
    10e0:	8f 5f       	subi	r24, 0xFF	; 255
    10e2:	80 93 db 00 	sts	0x00DB, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    10e6:	e0 91 1a 01 	lds	r30, 0x011A
    10ea:	f0 91 1b 01 	lds	r31, 0x011B
    10ee:	80 81       	ld	r24, Z
    10f0:	88 23       	and	r24, r24
    10f2:	19 f4       	brne	.+6      	; 0x10fa <xTaskIncrementTick+0x6e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    10f4:	8f ef       	ldi	r24, 0xFF	; 255
    10f6:	9f ef       	ldi	r25, 0xFF	; 255
    10f8:	09 c0       	rjmp	.+18     	; 0x110c <xTaskIncrementTick+0x80>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    10fa:	e0 91 1a 01 	lds	r30, 0x011A
    10fe:	f0 91 1b 01 	lds	r31, 0x011B
    1102:	05 80       	ldd	r0, Z+5	; 0x05
    1104:	f6 81       	ldd	r31, Z+6	; 0x06
    1106:	e0 2d       	mov	r30, r0
    1108:	80 81       	ld	r24, Z
    110a:	91 81       	ldd	r25, Z+1	; 0x01
    110c:	90 93 da 00 	sts	0x00DA, r25
    1110:	80 93 d9 00 	sts	0x00D9, r24

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    1114:	80 91 d9 00 	lds	r24, 0x00D9
    1118:	90 91 da 00 	lds	r25, 0x00DA
    111c:	08 17       	cp	r16, r24
    111e:	19 07       	cpc	r17, r25
    1120:	08 f4       	brcc	.+2      	; 0x1124 <xTaskIncrementTick+0x98>
    1122:	a2 c0       	rjmp	.+324    	; 0x1268 <xTaskIncrementTick+0x1dc>
    1124:	ff 24       	eor	r15, r15
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    1126:	39 e0       	ldi	r19, 0x09	; 9
    1128:	e3 2e       	mov	r14, r19
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    112a:	e0 91 1a 01 	lds	r30, 0x011A
    112e:	f0 91 1b 01 	lds	r31, 0x011B
    1132:	80 81       	ld	r24, Z
    1134:	88 23       	and	r24, r24
    1136:	19 f4       	brne	.+6      	; 0x113e <xTaskIncrementTick+0xb2>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1138:	8f ef       	ldi	r24, 0xFF	; 255
    113a:	9f ef       	ldi	r25, 0xFF	; 255
    113c:	0e c0       	rjmp	.+28     	; 0x115a <xTaskIncrementTick+0xce>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    113e:	e0 91 1a 01 	lds	r30, 0x011A
    1142:	f0 91 1b 01 	lds	r31, 0x011B
    1146:	05 80       	ldd	r0, Z+5	; 0x05
    1148:	f6 81       	ldd	r31, Z+6	; 0x06
    114a:	e0 2d       	mov	r30, r0
    114c:	c6 81       	ldd	r28, Z+6	; 0x06
    114e:	d7 81       	ldd	r29, Z+7	; 0x07
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1150:	8a 81       	ldd	r24, Y+2	; 0x02
    1152:	9b 81       	ldd	r25, Y+3	; 0x03

                    if( xConstTickCount < xItemValue )
    1154:	08 17       	cp	r16, r24
    1156:	19 07       	cpc	r17, r25
    1158:	28 f4       	brcc	.+10     	; 0x1164 <xTaskIncrementTick+0xd8>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    115a:	90 93 da 00 	sts	0x00DA, r25
    115e:	80 93 d9 00 	sts	0x00D9, r24
    1162:	83 c0       	rjmp	.+262    	; 0x126a <xTaskIncrementTick+0x1de>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1164:	aa 85       	ldd	r26, Y+10	; 0x0a
    1166:	bb 85       	ldd	r27, Y+11	; 0x0b
    1168:	4c 81       	ldd	r20, Y+4	; 0x04
    116a:	5d 81       	ldd	r21, Y+5	; 0x05
    116c:	8e 81       	ldd	r24, Y+6	; 0x06
    116e:	9f 81       	ldd	r25, Y+7	; 0x07
    1170:	fa 01       	movw	r30, r20
    1172:	95 83       	std	Z+5, r25	; 0x05
    1174:	84 83       	std	Z+4, r24	; 0x04
    1176:	2e 81       	ldd	r18, Y+6	; 0x06
    1178:	3f 81       	ldd	r19, Y+7	; 0x07
    117a:	f9 01       	movw	r30, r18
    117c:	53 83       	std	Z+3, r21	; 0x03
    117e:	42 83       	std	Z+2, r20	; 0x02
    1180:	be 01       	movw	r22, r28
    1182:	6e 5f       	subi	r22, 0xFE	; 254
    1184:	7f 4f       	sbci	r23, 0xFF	; 255
    1186:	11 96       	adiw	r26, 0x01	; 1
    1188:	8d 91       	ld	r24, X+
    118a:	9c 91       	ld	r25, X
    118c:	12 97       	sbiw	r26, 0x02	; 2
    118e:	86 17       	cp	r24, r22
    1190:	97 07       	cpc	r25, r23
    1192:	21 f4       	brne	.+8      	; 0x119c <xTaskIncrementTick+0x110>
    1194:	12 96       	adiw	r26, 0x02	; 2
    1196:	3c 93       	st	X, r19
    1198:	2e 93       	st	-X, r18
    119a:	11 97       	sbiw	r26, 0x01	; 1
    119c:	1b 86       	std	Y+11, r1	; 0x0b
    119e:	1a 86       	std	Y+10, r1	; 0x0a
    11a0:	8c 91       	ld	r24, X
    11a2:	81 50       	subi	r24, 0x01	; 1
    11a4:	8c 93       	st	X, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    11a6:	ac 89       	ldd	r26, Y+20	; 0x14
    11a8:	bd 89       	ldd	r27, Y+21	; 0x15
    11aa:	10 97       	sbiw	r26, 0x00	; 0
    11ac:	f9 f0       	breq	.+62     	; 0x11ec <xTaskIncrementTick+0x160>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    11ae:	2e 85       	ldd	r18, Y+14	; 0x0e
    11b0:	3f 85       	ldd	r19, Y+15	; 0x0f
    11b2:	88 89       	ldd	r24, Y+16	; 0x10
    11b4:	99 89       	ldd	r25, Y+17	; 0x11
    11b6:	f9 01       	movw	r30, r18
    11b8:	95 83       	std	Z+5, r25	; 0x05
    11ba:	84 83       	std	Z+4, r24	; 0x04
    11bc:	48 89       	ldd	r20, Y+16	; 0x10
    11be:	59 89       	ldd	r21, Y+17	; 0x11
    11c0:	fa 01       	movw	r30, r20
    11c2:	33 83       	std	Z+3, r19	; 0x03
    11c4:	22 83       	std	Z+2, r18	; 0x02
    11c6:	9e 01       	movw	r18, r28
    11c8:	24 5f       	subi	r18, 0xF4	; 244
    11ca:	3f 4f       	sbci	r19, 0xFF	; 255
    11cc:	11 96       	adiw	r26, 0x01	; 1
    11ce:	8d 91       	ld	r24, X+
    11d0:	9c 91       	ld	r25, X
    11d2:	12 97       	sbiw	r26, 0x02	; 2
    11d4:	82 17       	cp	r24, r18
    11d6:	93 07       	cpc	r25, r19
    11d8:	21 f4       	brne	.+8      	; 0x11e2 <xTaskIncrementTick+0x156>
    11da:	12 96       	adiw	r26, 0x02	; 2
    11dc:	5c 93       	st	X, r21
    11de:	4e 93       	st	-X, r20
    11e0:	11 97       	sbiw	r26, 0x01	; 1
    11e2:	1d 8a       	std	Y+21, r1	; 0x15
    11e4:	1c 8a       	std	Y+20, r1	; 0x14
    11e6:	8c 91       	ld	r24, X
    11e8:	81 50       	subi	r24, 0x01	; 1
    11ea:	8c 93       	st	X, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    11ec:	9e 89       	ldd	r25, Y+22	; 0x16
    11ee:	80 91 d5 00 	lds	r24, 0x00D5
    11f2:	89 17       	cp	r24, r25
    11f4:	10 f4       	brcc	.+4      	; 0x11fa <xTaskIncrementTick+0x16e>
    11f6:	90 93 d5 00 	sts	0x00D5, r25
    11fa:	89 2f       	mov	r24, r25
    11fc:	90 e0       	ldi	r25, 0x00	; 0
    11fe:	fc 01       	movw	r30, r24
    1200:	23 e0       	ldi	r18, 0x03	; 3
    1202:	ee 0f       	add	r30, r30
    1204:	ff 1f       	adc	r31, r31
    1206:	2a 95       	dec	r18
    1208:	e1 f7       	brne	.-8      	; 0x1202 <xTaskIncrementTick+0x176>
    120a:	e8 0f       	add	r30, r24
    120c:	f9 1f       	adc	r31, r25
    120e:	ec 51       	subi	r30, 0x1C	; 28
    1210:	ff 4f       	sbci	r31, 0xFF	; 255
    1212:	a1 81       	ldd	r26, Z+1	; 0x01
    1214:	b2 81       	ldd	r27, Z+2	; 0x02
    1216:	bd 83       	std	Y+5, r27	; 0x05
    1218:	ac 83       	std	Y+4, r26	; 0x04
    121a:	14 96       	adiw	r26, 0x04	; 4
    121c:	8d 91       	ld	r24, X+
    121e:	9c 91       	ld	r25, X
    1220:	15 97       	sbiw	r26, 0x05	; 5
    1222:	9f 83       	std	Y+7, r25	; 0x07
    1224:	8e 83       	std	Y+6, r24	; 0x06
    1226:	14 96       	adiw	r26, 0x04	; 4
    1228:	ed 91       	ld	r30, X+
    122a:	fc 91       	ld	r31, X
    122c:	15 97       	sbiw	r26, 0x05	; 5
    122e:	73 83       	std	Z+3, r23	; 0x03
    1230:	62 83       	std	Z+2, r22	; 0x02
    1232:	15 96       	adiw	r26, 0x05	; 5
    1234:	7c 93       	st	X, r23
    1236:	6e 93       	st	-X, r22
    1238:	14 97       	sbiw	r26, 0x04	; 4
    123a:	ee 89       	ldd	r30, Y+22	; 0x16
    123c:	ee 9d       	mul	r30, r14
    123e:	f0 01       	movw	r30, r0
    1240:	11 24       	eor	r1, r1
    1242:	ec 51       	subi	r30, 0x1C	; 28
    1244:	ff 4f       	sbci	r31, 0xFF	; 255
    1246:	fb 87       	std	Y+11, r31	; 0x0b
    1248:	ea 87       	std	Y+10, r30	; 0x0a
    124a:	80 81       	ld	r24, Z
    124c:	8f 5f       	subi	r24, 0xFF	; 255
    124e:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1250:	e0 91 d2 00 	lds	r30, 0x00D2
    1254:	f0 91 d3 00 	lds	r31, 0x00D3
    1258:	9e 89       	ldd	r25, Y+22	; 0x16
    125a:	86 89       	ldd	r24, Z+22	; 0x16
    125c:	98 17       	cp	r25, r24
    125e:	08 f4       	brcc	.+2      	; 0x1262 <xTaskIncrementTick+0x1d6>
    1260:	64 cf       	rjmp	.-312    	; 0x112a <xTaskIncrementTick+0x9e>
    1262:	ff 24       	eor	r15, r15
    1264:	f3 94       	inc	r15
    1266:	61 cf       	rjmp	.-318    	; 0x112a <xTaskIncrementTick+0x9e>
    1268:	ff 24       	eor	r15, r15
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    126a:	e0 91 d2 00 	lds	r30, 0x00D2
    126e:	f0 91 d3 00 	lds	r31, 0x00D3
    1272:	e6 89       	ldd	r30, Z+22	; 0x16
    1274:	89 e0       	ldi	r24, 0x09	; 9
    1276:	e8 9f       	mul	r30, r24
    1278:	f0 01       	movw	r30, r0
    127a:	11 24       	eor	r1, r1
    127c:	ec 51       	subi	r30, 0x1C	; 28
    127e:	ff 4f       	sbci	r31, 0xFF	; 255
    1280:	80 81       	ld	r24, Z
    1282:	82 30       	cpi	r24, 0x02	; 2
    1284:	10 f0       	brcs	.+4      	; 0x128a <xTaskIncrementTick+0x1fe>
    1286:	ff 24       	eor	r15, r15
    1288:	f3 94       	inc	r15
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    128a:	80 91 d6 00 	lds	r24, 0x00D6
    128e:	88 23       	and	r24, r24
    1290:	69 f0       	breq	.+26     	; 0x12ac <xTaskIncrementTick+0x220>
    1292:	ff 24       	eor	r15, r15
    1294:	f3 94       	inc	r15
    1296:	0a c0       	rjmp	.+20     	; 0x12ac <xTaskIncrementTick+0x220>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    1298:	80 91 dc 00 	lds	r24, 0x00DC
    129c:	90 91 dd 00 	lds	r25, 0x00DD
    12a0:	01 96       	adiw	r24, 0x01	; 1
    12a2:	90 93 dd 00 	sts	0x00DD, r25
    12a6:	80 93 dc 00 	sts	0x00DC, r24
    12aa:	ff 24       	eor	r15, r15
            }
        #endif
    }

    return xSwitchRequired;
}
    12ac:	8f 2d       	mov	r24, r15
    12ae:	df 91       	pop	r29
    12b0:	cf 91       	pop	r28
    12b2:	1f 91       	pop	r17
    12b4:	0f 91       	pop	r16
    12b6:	ff 90       	pop	r15
    12b8:	ef 90       	pop	r14
    12ba:	08 95       	ret

000012bc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    12bc:	cf 93       	push	r28
    12be:	df 93       	push	r29
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    12c0:	dc 01       	movw	r26, r24
    12c2:	15 96       	adiw	r26, 0x05	; 5
    12c4:	ed 91       	ld	r30, X+
    12c6:	fc 91       	ld	r31, X
    12c8:	16 97       	sbiw	r26, 0x06	; 6
    12ca:	c6 81       	ldd	r28, Z+6	; 0x06
    12cc:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    12ce:	ac 89       	ldd	r26, Y+20	; 0x14
    12d0:	bd 89       	ldd	r27, Y+21	; 0x15
    12d2:	4e 85       	ldd	r20, Y+14	; 0x0e
    12d4:	5f 85       	ldd	r21, Y+15	; 0x0f
    12d6:	88 89       	ldd	r24, Y+16	; 0x10
    12d8:	99 89       	ldd	r25, Y+17	; 0x11
    12da:	fa 01       	movw	r30, r20
    12dc:	95 83       	std	Z+5, r25	; 0x05
    12de:	84 83       	std	Z+4, r24	; 0x04
    12e0:	28 89       	ldd	r18, Y+16	; 0x10
    12e2:	39 89       	ldd	r19, Y+17	; 0x11
    12e4:	f9 01       	movw	r30, r18
    12e6:	53 83       	std	Z+3, r21	; 0x03
    12e8:	42 83       	std	Z+2, r20	; 0x02
    12ea:	ae 01       	movw	r20, r28
    12ec:	44 5f       	subi	r20, 0xF4	; 244
    12ee:	5f 4f       	sbci	r21, 0xFF	; 255
    12f0:	11 96       	adiw	r26, 0x01	; 1
    12f2:	8d 91       	ld	r24, X+
    12f4:	9c 91       	ld	r25, X
    12f6:	12 97       	sbiw	r26, 0x02	; 2
    12f8:	84 17       	cp	r24, r20
    12fa:	95 07       	cpc	r25, r21
    12fc:	21 f4       	brne	.+8      	; 0x1306 <xTaskRemoveFromEventList+0x4a>
    12fe:	12 96       	adiw	r26, 0x02	; 2
    1300:	3c 93       	st	X, r19
    1302:	2e 93       	st	-X, r18
    1304:	11 97       	sbiw	r26, 0x01	; 1
    1306:	1d 8a       	std	Y+21, r1	; 0x15
    1308:	1c 8a       	std	Y+20, r1	; 0x14
    130a:	8c 91       	ld	r24, X
    130c:	81 50       	subi	r24, 0x01	; 1
    130e:	8c 93       	st	X, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1310:	80 91 d4 00 	lds	r24, 0x00D4
    1314:	88 23       	and	r24, r24
    1316:	09 f0       	breq	.+2      	; 0x131a <xTaskRemoveFromEventList+0x5e>
    1318:	55 c0       	rjmp	.+170    	; 0x13c4 <xTaskRemoveFromEventList+0x108>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    131a:	aa 85       	ldd	r26, Y+10	; 0x0a
    131c:	bb 85       	ldd	r27, Y+11	; 0x0b
    131e:	4c 81       	ldd	r20, Y+4	; 0x04
    1320:	5d 81       	ldd	r21, Y+5	; 0x05
    1322:	8e 81       	ldd	r24, Y+6	; 0x06
    1324:	9f 81       	ldd	r25, Y+7	; 0x07
    1326:	fa 01       	movw	r30, r20
    1328:	95 83       	std	Z+5, r25	; 0x05
    132a:	84 83       	std	Z+4, r24	; 0x04
    132c:	2e 81       	ldd	r18, Y+6	; 0x06
    132e:	3f 81       	ldd	r19, Y+7	; 0x07
    1330:	f9 01       	movw	r30, r18
    1332:	53 83       	std	Z+3, r21	; 0x03
    1334:	42 83       	std	Z+2, r20	; 0x02
    1336:	ae 01       	movw	r20, r28
    1338:	4e 5f       	subi	r20, 0xFE	; 254
    133a:	5f 4f       	sbci	r21, 0xFF	; 255
    133c:	11 96       	adiw	r26, 0x01	; 1
    133e:	8d 91       	ld	r24, X+
    1340:	9c 91       	ld	r25, X
    1342:	12 97       	sbiw	r26, 0x02	; 2
    1344:	84 17       	cp	r24, r20
    1346:	95 07       	cpc	r25, r21
    1348:	21 f4       	brne	.+8      	; 0x1352 <xTaskRemoveFromEventList+0x96>
    134a:	12 96       	adiw	r26, 0x02	; 2
    134c:	3c 93       	st	X, r19
    134e:	2e 93       	st	-X, r18
    1350:	11 97       	sbiw	r26, 0x01	; 1
    1352:	1b 86       	std	Y+11, r1	; 0x0b
    1354:	1a 86       	std	Y+10, r1	; 0x0a
    1356:	8c 91       	ld	r24, X
    1358:	81 50       	subi	r24, 0x01	; 1
    135a:	8c 93       	st	X, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    135c:	9e 89       	ldd	r25, Y+22	; 0x16
    135e:	80 91 d5 00 	lds	r24, 0x00D5
    1362:	89 17       	cp	r24, r25
    1364:	10 f4       	brcc	.+4      	; 0x136a <xTaskRemoveFromEventList+0xae>
    1366:	90 93 d5 00 	sts	0x00D5, r25
    136a:	89 2f       	mov	r24, r25
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	fc 01       	movw	r30, r24
    1370:	63 e0       	ldi	r22, 0x03	; 3
    1372:	ee 0f       	add	r30, r30
    1374:	ff 1f       	adc	r31, r31
    1376:	6a 95       	dec	r22
    1378:	e1 f7       	brne	.-8      	; 0x1372 <xTaskRemoveFromEventList+0xb6>
    137a:	e8 0f       	add	r30, r24
    137c:	f9 1f       	adc	r31, r25
    137e:	ec 51       	subi	r30, 0x1C	; 28
    1380:	ff 4f       	sbci	r31, 0xFF	; 255
    1382:	a1 81       	ldd	r26, Z+1	; 0x01
    1384:	b2 81       	ldd	r27, Z+2	; 0x02
    1386:	bd 83       	std	Y+5, r27	; 0x05
    1388:	ac 83       	std	Y+4, r26	; 0x04
    138a:	14 96       	adiw	r26, 0x04	; 4
    138c:	8d 91       	ld	r24, X+
    138e:	9c 91       	ld	r25, X
    1390:	15 97       	sbiw	r26, 0x05	; 5
    1392:	9f 83       	std	Y+7, r25	; 0x07
    1394:	8e 83       	std	Y+6, r24	; 0x06
    1396:	14 96       	adiw	r26, 0x04	; 4
    1398:	ed 91       	ld	r30, X+
    139a:	fc 91       	ld	r31, X
    139c:	15 97       	sbiw	r26, 0x05	; 5
    139e:	53 83       	std	Z+3, r21	; 0x03
    13a0:	42 83       	std	Z+2, r20	; 0x02
    13a2:	15 96       	adiw	r26, 0x05	; 5
    13a4:	5c 93       	st	X, r21
    13a6:	4e 93       	st	-X, r20
    13a8:	14 97       	sbiw	r26, 0x04	; 4
    13aa:	ee 89       	ldd	r30, Y+22	; 0x16
    13ac:	89 e0       	ldi	r24, 0x09	; 9
    13ae:	e8 9f       	mul	r30, r24
    13b0:	f0 01       	movw	r30, r0
    13b2:	11 24       	eor	r1, r1
    13b4:	ec 51       	subi	r30, 0x1C	; 28
    13b6:	ff 4f       	sbci	r31, 0xFF	; 255
    13b8:	fb 87       	std	Y+11, r31	; 0x0b
    13ba:	ea 87       	std	Y+10, r30	; 0x0a
    13bc:	80 81       	ld	r24, Z
    13be:	8f 5f       	subi	r24, 0xFF	; 255
    13c0:	80 83       	st	Z, r24
    13c2:	1f c0       	rjmp	.+62     	; 0x1402 <xTaskRemoveFromEventList+0x146>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    13c4:	a0 91 1f 01 	lds	r26, 0x011F
    13c8:	b0 91 20 01 	lds	r27, 0x0120
    13cc:	bf 87       	std	Y+15, r27	; 0x0f
    13ce:	ae 87       	std	Y+14, r26	; 0x0e
    13d0:	14 96       	adiw	r26, 0x04	; 4
    13d2:	8d 91       	ld	r24, X+
    13d4:	9c 91       	ld	r25, X
    13d6:	15 97       	sbiw	r26, 0x05	; 5
    13d8:	99 8b       	std	Y+17, r25	; 0x11
    13da:	88 8b       	std	Y+16, r24	; 0x10
    13dc:	14 96       	adiw	r26, 0x04	; 4
    13de:	ed 91       	ld	r30, X+
    13e0:	fc 91       	ld	r31, X
    13e2:	15 97       	sbiw	r26, 0x05	; 5
    13e4:	53 83       	std	Z+3, r21	; 0x03
    13e6:	42 83       	std	Z+2, r20	; 0x02
    13e8:	15 96       	adiw	r26, 0x05	; 5
    13ea:	5c 93       	st	X, r21
    13ec:	4e 93       	st	-X, r20
    13ee:	14 97       	sbiw	r26, 0x04	; 4
    13f0:	8e e1       	ldi	r24, 0x1E	; 30
    13f2:	91 e0       	ldi	r25, 0x01	; 1
    13f4:	9d 8b       	std	Y+21, r25	; 0x15
    13f6:	8c 8b       	std	Y+20, r24	; 0x14
    13f8:	80 91 1e 01 	lds	r24, 0x011E
    13fc:	8f 5f       	subi	r24, 0xFF	; 255
    13fe:	80 93 1e 01 	sts	0x011E, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1402:	e0 91 d2 00 	lds	r30, 0x00D2
    1406:	f0 91 d3 00 	lds	r31, 0x00D3
    140a:	9e 89       	ldd	r25, Y+22	; 0x16
    140c:	86 89       	ldd	r24, Z+22	; 0x16
    140e:	89 17       	cp	r24, r25
    1410:	10 f0       	brcs	.+4      	; 0x1416 <xTaskRemoveFromEventList+0x15a>
    1412:	80 e0       	ldi	r24, 0x00	; 0
    1414:	03 c0       	rjmp	.+6      	; 0x141c <xTaskRemoveFromEventList+0x160>
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    1416:	81 e0       	ldi	r24, 0x01	; 1
    1418:	80 93 d6 00 	sts	0x00D6, r24
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	08 95       	ret

00001422 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	dc 01       	movw	r26, r24
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1428:	70 68       	ori	r23, 0x80	; 128
    142a:	11 96       	adiw	r26, 0x01	; 1
    142c:	7c 93       	st	X, r23
    142e:	6e 93       	st	-X, r22

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1430:	16 96       	adiw	r26, 0x06	; 6
    1432:	2d 91       	ld	r18, X+
    1434:	3c 91       	ld	r19, X
    1436:	17 97       	sbiw	r26, 0x07	; 7
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    1438:	18 96       	adiw	r26, 0x08	; 8
    143a:	cd 91       	ld	r28, X+
    143c:	dc 91       	ld	r29, X
    143e:	19 97       	sbiw	r26, 0x09	; 9
    1440:	12 96       	adiw	r26, 0x02	; 2
    1442:	6d 91       	ld	r22, X+
    1444:	7c 91       	ld	r23, X
    1446:	13 97       	sbiw	r26, 0x03	; 3
    1448:	14 96       	adiw	r26, 0x04	; 4
    144a:	8d 91       	ld	r24, X+
    144c:	9c 91       	ld	r25, X
    144e:	15 97       	sbiw	r26, 0x05	; 5
    1450:	fb 01       	movw	r30, r22
    1452:	95 83       	std	Z+5, r25	; 0x05
    1454:	84 83       	std	Z+4, r24	; 0x04
    1456:	14 96       	adiw	r26, 0x04	; 4
    1458:	4d 91       	ld	r20, X+
    145a:	5c 91       	ld	r21, X
    145c:	15 97       	sbiw	r26, 0x05	; 5
    145e:	fa 01       	movw	r30, r20
    1460:	73 83       	std	Z+3, r23	; 0x03
    1462:	62 83       	std	Z+2, r22	; 0x02
    1464:	89 81       	ldd	r24, Y+1	; 0x01
    1466:	9a 81       	ldd	r25, Y+2	; 0x02
    1468:	8a 17       	cp	r24, r26
    146a:	9b 07       	cpc	r25, r27
    146c:	11 f4       	brne	.+4      	; 0x1472 <vTaskRemoveFromUnorderedEventList+0x50>
    146e:	5a 83       	std	Y+2, r21	; 0x02
    1470:	49 83       	std	Y+1, r20	; 0x01
    1472:	19 96       	adiw	r26, 0x09	; 9
    1474:	1c 92       	st	X, r1
    1476:	1e 92       	st	-X, r1
    1478:	18 97       	sbiw	r26, 0x08	; 8
    147a:	88 81       	ld	r24, Y
    147c:	81 50       	subi	r24, 0x01	; 1
    147e:	88 83       	st	Y, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    1480:	e9 01       	movw	r28, r18
    1482:	aa 85       	ldd	r26, Y+10	; 0x0a
    1484:	bb 85       	ldd	r27, Y+11	; 0x0b
    1486:	4c 81       	ldd	r20, Y+4	; 0x04
    1488:	5d 81       	ldd	r21, Y+5	; 0x05
    148a:	8e 81       	ldd	r24, Y+6	; 0x06
    148c:	9f 81       	ldd	r25, Y+7	; 0x07
    148e:	fa 01       	movw	r30, r20
    1490:	95 83       	std	Z+5, r25	; 0x05
    1492:	84 83       	std	Z+4, r24	; 0x04
    1494:	0e 80       	ldd	r0, Y+6	; 0x06
    1496:	df 81       	ldd	r29, Y+7	; 0x07
    1498:	c0 2d       	mov	r28, r0
    149a:	5b 83       	std	Y+3, r21	; 0x03
    149c:	4a 83       	std	Y+2, r20	; 0x02
    149e:	a9 01       	movw	r20, r18
    14a0:	4e 5f       	subi	r20, 0xFE	; 254
    14a2:	5f 4f       	sbci	r21, 0xFF	; 255
    14a4:	11 96       	adiw	r26, 0x01	; 1
    14a6:	8d 91       	ld	r24, X+
    14a8:	9c 91       	ld	r25, X
    14aa:	12 97       	sbiw	r26, 0x02	; 2
    14ac:	84 17       	cp	r24, r20
    14ae:	95 07       	cpc	r25, r21
    14b0:	21 f4       	brne	.+8      	; 0x14ba <vTaskRemoveFromUnorderedEventList+0x98>
    14b2:	12 96       	adiw	r26, 0x02	; 2
    14b4:	dc 93       	st	X, r29
    14b6:	ce 93       	st	-X, r28
    14b8:	11 97       	sbiw	r26, 0x01	; 1
    14ba:	e9 01       	movw	r28, r18
    14bc:	1b 86       	std	Y+11, r1	; 0x0b
    14be:	1a 86       	std	Y+10, r1	; 0x0a
    14c0:	8c 91       	ld	r24, X
    14c2:	81 50       	subi	r24, 0x01	; 1
    14c4:	8c 93       	st	X, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    14c6:	9e 89       	ldd	r25, Y+22	; 0x16
    14c8:	80 91 d5 00 	lds	r24, 0x00D5
    14cc:	89 17       	cp	r24, r25
    14ce:	10 f4       	brcc	.+4      	; 0x14d4 <vTaskRemoveFromUnorderedEventList+0xb2>
    14d0:	90 93 d5 00 	sts	0x00D5, r25
    14d4:	89 2f       	mov	r24, r25
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	fc 01       	movw	r30, r24
    14da:	73 e0       	ldi	r23, 0x03	; 3
    14dc:	ee 0f       	add	r30, r30
    14de:	ff 1f       	adc	r31, r31
    14e0:	7a 95       	dec	r23
    14e2:	e1 f7       	brne	.-8      	; 0x14dc <vTaskRemoveFromUnorderedEventList+0xba>
    14e4:	e8 0f       	add	r30, r24
    14e6:	f9 1f       	adc	r31, r25
    14e8:	ec 51       	subi	r30, 0x1C	; 28
    14ea:	ff 4f       	sbci	r31, 0xFF	; 255
    14ec:	a1 81       	ldd	r26, Z+1	; 0x01
    14ee:	b2 81       	ldd	r27, Z+2	; 0x02
    14f0:	f9 01       	movw	r30, r18
    14f2:	b5 83       	std	Z+5, r27	; 0x05
    14f4:	a4 83       	std	Z+4, r26	; 0x04
    14f6:	14 96       	adiw	r26, 0x04	; 4
    14f8:	8d 91       	ld	r24, X+
    14fa:	9c 91       	ld	r25, X
    14fc:	15 97       	sbiw	r26, 0x05	; 5
    14fe:	97 83       	std	Z+7, r25	; 0x07
    1500:	86 83       	std	Z+6, r24	; 0x06
    1502:	14 96       	adiw	r26, 0x04	; 4
    1504:	ed 91       	ld	r30, X+
    1506:	fc 91       	ld	r31, X
    1508:	15 97       	sbiw	r26, 0x05	; 5
    150a:	53 83       	std	Z+3, r21	; 0x03
    150c:	42 83       	std	Z+2, r20	; 0x02
    150e:	15 96       	adiw	r26, 0x05	; 5
    1510:	5c 93       	st	X, r21
    1512:	4e 93       	st	-X, r20
    1514:	14 97       	sbiw	r26, 0x04	; 4
    1516:	d9 01       	movw	r26, r18
    1518:	56 96       	adiw	r26, 0x16	; 22
    151a:	ec 91       	ld	r30, X
    151c:	56 97       	sbiw	r26, 0x16	; 22
    151e:	89 e0       	ldi	r24, 0x09	; 9
    1520:	e8 9f       	mul	r30, r24
    1522:	f0 01       	movw	r30, r0
    1524:	11 24       	eor	r1, r1
    1526:	ec 51       	subi	r30, 0x1C	; 28
    1528:	ff 4f       	sbci	r31, 0xFF	; 255
    152a:	1b 96       	adiw	r26, 0x0b	; 11
    152c:	fc 93       	st	X, r31
    152e:	ee 93       	st	-X, r30
    1530:	1a 97       	sbiw	r26, 0x0a	; 10
    1532:	80 81       	ld	r24, Z
    1534:	8f 5f       	subi	r24, 0xFF	; 255
    1536:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1538:	e0 91 d2 00 	lds	r30, 0x00D2
    153c:	f0 91 d3 00 	lds	r31, 0x00D3
    1540:	56 96       	adiw	r26, 0x16	; 22
    1542:	9c 91       	ld	r25, X
    1544:	86 89       	ldd	r24, Z+22	; 0x16
    1546:	89 17       	cp	r24, r25
    1548:	18 f4       	brcc	.+6      	; 0x1550 <vTaskRemoveFromUnorderedEventList+0x12e>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	80 93 d6 00 	sts	0x00D6, r24
    }
}
    1550:	df 91       	pop	r29
    1552:	cf 91       	pop	r28
    1554:	08 95       	ret

00001556 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    1556:	fc 01       	movw	r30, r24
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    1558:	0f b6       	in	r0, 0x3f	; 63
    155a:	f8 94       	cli
    155c:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    155e:	80 91 db 00 	lds	r24, 0x00DB
    1562:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    1564:	80 91 d7 00 	lds	r24, 0x00D7
    1568:	90 91 d8 00 	lds	r25, 0x00D8
    156c:	92 83       	std	Z+2, r25	; 0x02
    156e:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    1570:	0f 90       	pop	r0
    1572:	0f be       	out	0x3f, r0	; 63
}
    1574:	08 95       	ret

00001576 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    1576:	fc 01       	movw	r30, r24
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    1578:	80 91 db 00 	lds	r24, 0x00DB
    157c:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    157e:	80 91 d7 00 	lds	r24, 0x00D7
    1582:	90 91 d8 00 	lds	r25, 0x00D8
    1586:	92 83       	std	Z+2, r25	; 0x02
    1588:	81 83       	std	Z+1, r24	; 0x01
}
    158a:	08 95       	ret

0000158c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    158c:	dc 01       	movw	r26, r24
    158e:	fb 01       	movw	r30, r22
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    1590:	0f b6       	in	r0, 0x3f	; 63
    1592:	f8 94       	cli
    1594:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    1596:	60 91 d7 00 	lds	r22, 0x00D7
    159a:	70 91 d8 00 	lds	r23, 0x00D8
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    159e:	11 96       	adiw	r26, 0x01	; 1
    15a0:	4d 91       	ld	r20, X+
    15a2:	5c 91       	ld	r21, X
    15a4:	12 97       	sbiw	r26, 0x02	; 2
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
    15a6:	20 81       	ld	r18, Z
    15a8:	31 81       	ldd	r19, Z+1	; 0x01
    15aa:	8f ef       	ldi	r24, 0xFF	; 255
    15ac:	2f 3f       	cpi	r18, 0xFF	; 255
    15ae:	38 07       	cpc	r19, r24
    15b0:	e9 f0       	breq	.+58     	; 0x15ec <xTaskCheckForTimeOut+0x60>
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    15b2:	90 91 db 00 	lds	r25, 0x00DB
    15b6:	8c 91       	ld	r24, X
    15b8:	98 17       	cp	r25, r24
    15ba:	19 f0       	breq	.+6      	; 0x15c2 <xTaskCheckForTimeOut+0x36>
    15bc:	64 17       	cp	r22, r20
    15be:	75 07       	cpc	r23, r21
    15c0:	b8 f4       	brcc	.+46     	; 0x15f0 <xTaskCheckForTimeOut+0x64>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    15c2:	cb 01       	movw	r24, r22
    15c4:	84 1b       	sub	r24, r20
    15c6:	95 0b       	sbc	r25, r21
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    15c8:	82 17       	cp	r24, r18
    15ca:	93 07       	cpc	r25, r19
    15cc:	88 f4       	brcc	.+34     	; 0x15f0 <xTaskCheckForTimeOut+0x64>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    15ce:	28 1b       	sub	r18, r24
    15d0:	39 0b       	sbc	r19, r25
    15d2:	31 83       	std	Z+1, r19	; 0x01
    15d4:	20 83       	st	Z, r18
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    15d6:	80 91 db 00 	lds	r24, 0x00DB
    15da:	8c 93       	st	X, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    15dc:	80 91 d7 00 	lds	r24, 0x00D7
    15e0:	90 91 d8 00 	lds	r25, 0x00D8
    15e4:	12 96       	adiw	r26, 0x02	; 2
    15e6:	9c 93       	st	X, r25
    15e8:	8e 93       	st	-X, r24
    15ea:	11 97       	sbiw	r26, 0x01	; 1
    15ec:	80 e0       	ldi	r24, 0x00	; 0
    15ee:	03 c0       	rjmp	.+6      	; 0x15f6 <xTaskCheckForTimeOut+0x6a>
            vTaskInternalSetTimeOutState( pxTimeOut );
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    15f0:	11 82       	std	Z+1, r1	; 0x01
    15f2:	10 82       	st	Z, r1
    15f4:	81 e0       	ldi	r24, 0x01	; 1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    15f6:	0f 90       	pop	r0
    15f8:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    15fa:	08 95       	ret

000015fc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    15fc:	81 e0       	ldi	r24, 0x01	; 1
    15fe:	80 93 d6 00 	sts	0x00D6, r24
}
    1602:	08 95       	ret

00001604 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1604:	e0 91 d2 00 	lds	r30, 0x00D2
    1608:	f0 91 d3 00 	lds	r31, 0x00D3
    160c:	84 85       	ldd	r24, Z+12	; 0x0c
    160e:	95 85       	ldd	r25, Z+13	; 0x0d

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1610:	a0 91 d2 00 	lds	r26, 0x00D2
    1614:	b0 91 d3 00 	lds	r27, 0x00D3
    1618:	e0 91 d2 00 	lds	r30, 0x00D2
    161c:	f0 91 d3 00 	lds	r31, 0x00D3
    1620:	46 89       	ldd	r20, Z+22	; 0x16
    1622:	24 e0       	ldi	r18, 0x04	; 4
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	24 1b       	sub	r18, r20
    1628:	31 09       	sbc	r19, r1
    162a:	1d 96       	adiw	r26, 0x0d	; 13
    162c:	3c 93       	st	X, r19
    162e:	2e 93       	st	-X, r18
    1630:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
}
    1632:	08 95       	ret

00001634 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    1634:	cf 92       	push	r12
    1636:	df 92       	push	r13
    1638:	ef 92       	push	r14
    163a:	ff 92       	push	r15
    163c:	0f 93       	push	r16
    163e:	cf 93       	push	r28
    1640:	df 93       	push	r29
    1642:	ec 01       	movw	r28, r24

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
    1644:	e1 14       	cp	r14, r1
    1646:	f1 04       	cpc	r15, r1
    1648:	89 f0       	breq	.+34     	; 0x166c <xTaskGenericNotifyFromISR+0x38>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    164a:	e6 2f       	mov	r30, r22
    164c:	f0 e0       	ldi	r31, 0x00	; 0
    164e:	ee 0f       	add	r30, r30
    1650:	ff 1f       	adc	r31, r31
    1652:	ee 0f       	add	r30, r30
    1654:	ff 1f       	adc	r31, r31
    1656:	e8 0f       	add	r30, r24
    1658:	f9 1f       	adc	r31, r25
    165a:	81 a1       	ldd	r24, Z+33	; 0x21
    165c:	92 a1       	ldd	r25, Z+34	; 0x22
    165e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1660:	b4 a1       	ldd	r27, Z+36	; 0x24
    1662:	f7 01       	movw	r30, r14
    1664:	80 83       	st	Z, r24
    1666:	91 83       	std	Z+1, r25	; 0x01
    1668:	a2 83       	std	Z+2, r26	; 0x02
    166a:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    166c:	a6 2f       	mov	r26, r22
    166e:	b0 e0       	ldi	r27, 0x00	; 0
    1670:	fe 01       	movw	r30, r28
    1672:	ea 0f       	add	r30, r26
    1674:	fb 1f       	adc	r31, r27
    1676:	65 a1       	ldd	r22, Z+37	; 0x25
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1678:	82 e0       	ldi	r24, 0x02	; 2
    167a:	85 a3       	std	Z+37, r24	; 0x25

            switch( eAction )
    167c:	02 30       	cpi	r16, 0x02	; 2
    167e:	d1 f0       	breq	.+52     	; 0x16b4 <xTaskGenericNotifyFromISR+0x80>
    1680:	03 30       	cpi	r16, 0x03	; 3
    1682:	18 f4       	brcc	.+6      	; 0x168a <xTaskGenericNotifyFromISR+0x56>
    1684:	01 30       	cpi	r16, 0x01	; 1
    1686:	c9 f5       	brne	.+114    	; 0x16fa <xTaskGenericNotifyFromISR+0xc6>
    1688:	05 c0       	rjmp	.+10     	; 0x1694 <xTaskGenericNotifyFromISR+0x60>
    168a:	03 30       	cpi	r16, 0x03	; 3
    168c:	51 f1       	breq	.+84     	; 0x16e2 <xTaskGenericNotifyFromISR+0xae>
    168e:	04 30       	cpi	r16, 0x04	; 4
    1690:	a1 f5       	brne	.+104    	; 0x16fa <xTaskGenericNotifyFromISR+0xc6>
    1692:	23 c0       	rjmp	.+70     	; 0x16da <xTaskGenericNotifyFromISR+0xa6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1694:	fd 01       	movw	r30, r26
    1696:	ee 0f       	add	r30, r30
    1698:	ff 1f       	adc	r31, r31
    169a:	ee 0f       	add	r30, r30
    169c:	ff 1f       	adc	r31, r31
    169e:	ec 0f       	add	r30, r28
    16a0:	fd 1f       	adc	r31, r29
    16a2:	81 a1       	ldd	r24, Z+33	; 0x21
    16a4:	92 a1       	ldd	r25, Z+34	; 0x22
    16a6:	a3 a1       	ldd	r26, Z+35	; 0x23
    16a8:	b4 a1       	ldd	r27, Z+36	; 0x24
    16aa:	82 2b       	or	r24, r18
    16ac:	93 2b       	or	r25, r19
    16ae:	a4 2b       	or	r26, r20
    16b0:	b5 2b       	or	r27, r21
    16b2:	0e c0       	rjmp	.+28     	; 0x16d0 <xTaskGenericNotifyFromISR+0x9c>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    16b4:	fd 01       	movw	r30, r26
    16b6:	ee 0f       	add	r30, r30
    16b8:	ff 1f       	adc	r31, r31
    16ba:	ee 0f       	add	r30, r30
    16bc:	ff 1f       	adc	r31, r31
    16be:	ec 0f       	add	r30, r28
    16c0:	fd 1f       	adc	r31, r29
    16c2:	81 a1       	ldd	r24, Z+33	; 0x21
    16c4:	92 a1       	ldd	r25, Z+34	; 0x22
    16c6:	a3 a1       	ldd	r26, Z+35	; 0x23
    16c8:	b4 a1       	ldd	r27, Z+36	; 0x24
    16ca:	01 96       	adiw	r24, 0x01	; 1
    16cc:	a1 1d       	adc	r26, r1
    16ce:	b1 1d       	adc	r27, r1
    16d0:	81 a3       	std	Z+33, r24	; 0x21
    16d2:	92 a3       	std	Z+34, r25	; 0x22
    16d4:	a3 a3       	std	Z+35, r26	; 0x23
    16d6:	b4 a3       	std	Z+36, r27	; 0x24
    16d8:	10 c0       	rjmp	.+32     	; 0x16fa <xTaskGenericNotifyFromISR+0xc6>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    16da:	62 30       	cpi	r22, 0x02	; 2
    16dc:	11 f4       	brne	.+4      	; 0x16e2 <xTaskGenericNotifyFromISR+0xae>
    16de:	80 e0       	ldi	r24, 0x00	; 0
    16e0:	9d c0       	rjmp	.+314    	; 0x181c <xTaskGenericNotifyFromISR+0x1e8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    16e2:	aa 0f       	add	r26, r26
    16e4:	bb 1f       	adc	r27, r27
    16e6:	aa 0f       	add	r26, r26
    16e8:	bb 1f       	adc	r27, r27
    16ea:	ac 0f       	add	r26, r28
    16ec:	bd 1f       	adc	r27, r29
    16ee:	91 96       	adiw	r26, 0x21	; 33
    16f0:	2d 93       	st	X+, r18
    16f2:	3d 93       	st	X+, r19
    16f4:	4d 93       	st	X+, r20
    16f6:	5c 93       	st	X, r21
    16f8:	94 97       	sbiw	r26, 0x24	; 36

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    16fa:	61 30       	cpi	r22, 0x01	; 1
    16fc:	09 f0       	breq	.+2      	; 0x1700 <xTaskGenericNotifyFromISR+0xcc>
    16fe:	8d c0       	rjmp	.+282    	; 0x181a <xTaskGenericNotifyFromISR+0x1e6>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1700:	80 91 d4 00 	lds	r24, 0x00D4
    1704:	88 23       	and	r24, r24
    1706:	09 f0       	breq	.+2      	; 0x170a <xTaskGenericNotifyFromISR+0xd6>
    1708:	55 c0       	rjmp	.+170    	; 0x17b4 <xTaskGenericNotifyFromISR+0x180>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    170a:	aa 85       	ldd	r26, Y+10	; 0x0a
    170c:	bb 85       	ldd	r27, Y+11	; 0x0b
    170e:	4c 81       	ldd	r20, Y+4	; 0x04
    1710:	5d 81       	ldd	r21, Y+5	; 0x05
    1712:	8e 81       	ldd	r24, Y+6	; 0x06
    1714:	9f 81       	ldd	r25, Y+7	; 0x07
    1716:	fa 01       	movw	r30, r20
    1718:	95 83       	std	Z+5, r25	; 0x05
    171a:	84 83       	std	Z+4, r24	; 0x04
    171c:	2e 81       	ldd	r18, Y+6	; 0x06
    171e:	3f 81       	ldd	r19, Y+7	; 0x07
    1720:	f9 01       	movw	r30, r18
    1722:	53 83       	std	Z+3, r21	; 0x03
    1724:	42 83       	std	Z+2, r20	; 0x02
    1726:	ae 01       	movw	r20, r28
    1728:	4e 5f       	subi	r20, 0xFE	; 254
    172a:	5f 4f       	sbci	r21, 0xFF	; 255
    172c:	11 96       	adiw	r26, 0x01	; 1
    172e:	8d 91       	ld	r24, X+
    1730:	9c 91       	ld	r25, X
    1732:	12 97       	sbiw	r26, 0x02	; 2
    1734:	84 17       	cp	r24, r20
    1736:	95 07       	cpc	r25, r21
    1738:	21 f4       	brne	.+8      	; 0x1742 <xTaskGenericNotifyFromISR+0x10e>
    173a:	12 96       	adiw	r26, 0x02	; 2
    173c:	3c 93       	st	X, r19
    173e:	2e 93       	st	-X, r18
    1740:	11 97       	sbiw	r26, 0x01	; 1
    1742:	1b 86       	std	Y+11, r1	; 0x0b
    1744:	1a 86       	std	Y+10, r1	; 0x0a
    1746:	8c 91       	ld	r24, X
    1748:	81 50       	subi	r24, 0x01	; 1
    174a:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    174c:	9e 89       	ldd	r25, Y+22	; 0x16
    174e:	80 91 d5 00 	lds	r24, 0x00D5
    1752:	89 17       	cp	r24, r25
    1754:	10 f4       	brcc	.+4      	; 0x175a <xTaskGenericNotifyFromISR+0x126>
    1756:	90 93 d5 00 	sts	0x00D5, r25
    175a:	89 2f       	mov	r24, r25
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	fc 01       	movw	r30, r24
    1760:	a3 e0       	ldi	r26, 0x03	; 3
    1762:	ee 0f       	add	r30, r30
    1764:	ff 1f       	adc	r31, r31
    1766:	aa 95       	dec	r26
    1768:	e1 f7       	brne	.-8      	; 0x1762 <xTaskGenericNotifyFromISR+0x12e>
    176a:	e8 0f       	add	r30, r24
    176c:	f9 1f       	adc	r31, r25
    176e:	ec 51       	subi	r30, 0x1C	; 28
    1770:	ff 4f       	sbci	r31, 0xFF	; 255
    1772:	a1 81       	ldd	r26, Z+1	; 0x01
    1774:	b2 81       	ldd	r27, Z+2	; 0x02
    1776:	bd 83       	std	Y+5, r27	; 0x05
    1778:	ac 83       	std	Y+4, r26	; 0x04
    177a:	14 96       	adiw	r26, 0x04	; 4
    177c:	8d 91       	ld	r24, X+
    177e:	9c 91       	ld	r25, X
    1780:	15 97       	sbiw	r26, 0x05	; 5
    1782:	9f 83       	std	Y+7, r25	; 0x07
    1784:	8e 83       	std	Y+6, r24	; 0x06
    1786:	14 96       	adiw	r26, 0x04	; 4
    1788:	ed 91       	ld	r30, X+
    178a:	fc 91       	ld	r31, X
    178c:	15 97       	sbiw	r26, 0x05	; 5
    178e:	53 83       	std	Z+3, r21	; 0x03
    1790:	42 83       	std	Z+2, r20	; 0x02
    1792:	15 96       	adiw	r26, 0x05	; 5
    1794:	5c 93       	st	X, r21
    1796:	4e 93       	st	-X, r20
    1798:	14 97       	sbiw	r26, 0x04	; 4
    179a:	ee 89       	ldd	r30, Y+22	; 0x16
    179c:	89 e0       	ldi	r24, 0x09	; 9
    179e:	e8 9f       	mul	r30, r24
    17a0:	f0 01       	movw	r30, r0
    17a2:	11 24       	eor	r1, r1
    17a4:	ec 51       	subi	r30, 0x1C	; 28
    17a6:	ff 4f       	sbci	r31, 0xFF	; 255
    17a8:	fb 87       	std	Y+11, r31	; 0x0b
    17aa:	ea 87       	std	Y+10, r30	; 0x0a
    17ac:	80 81       	ld	r24, Z
    17ae:	8f 5f       	subi	r24, 0xFF	; 255
    17b0:	80 83       	st	Z, r24
    17b2:	21 c0       	rjmp	.+66     	; 0x17f6 <xTaskGenericNotifyFromISR+0x1c2>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    17b4:	a0 91 1f 01 	lds	r26, 0x011F
    17b8:	b0 91 20 01 	lds	r27, 0x0120
    17bc:	bf 87       	std	Y+15, r27	; 0x0f
    17be:	ae 87       	std	Y+14, r26	; 0x0e
    17c0:	14 96       	adiw	r26, 0x04	; 4
    17c2:	8d 91       	ld	r24, X+
    17c4:	9c 91       	ld	r25, X
    17c6:	15 97       	sbiw	r26, 0x05	; 5
    17c8:	99 8b       	std	Y+17, r25	; 0x11
    17ca:	88 8b       	std	Y+16, r24	; 0x10
    17cc:	ce 01       	movw	r24, r28
    17ce:	0c 96       	adiw	r24, 0x0c	; 12
    17d0:	14 96       	adiw	r26, 0x04	; 4
    17d2:	ed 91       	ld	r30, X+
    17d4:	fc 91       	ld	r31, X
    17d6:	15 97       	sbiw	r26, 0x05	; 5
    17d8:	93 83       	std	Z+3, r25	; 0x03
    17da:	82 83       	std	Z+2, r24	; 0x02
    17dc:	15 96       	adiw	r26, 0x05	; 5
    17de:	9c 93       	st	X, r25
    17e0:	8e 93       	st	-X, r24
    17e2:	14 97       	sbiw	r26, 0x04	; 4
    17e4:	8e e1       	ldi	r24, 0x1E	; 30
    17e6:	91 e0       	ldi	r25, 0x01	; 1
    17e8:	9d 8b       	std	Y+21, r25	; 0x15
    17ea:	8c 8b       	std	Y+20, r24	; 0x14
    17ec:	80 91 1e 01 	lds	r24, 0x011E
    17f0:	8f 5f       	subi	r24, 0xFF	; 255
    17f2:	80 93 1e 01 	sts	0x011E, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    17f6:	e0 91 d2 00 	lds	r30, 0x00D2
    17fa:	f0 91 d3 00 	lds	r31, 0x00D3
    17fe:	9e 89       	ldd	r25, Y+22	; 0x16
    1800:	86 89       	ldd	r24, Z+22	; 0x16
    1802:	89 17       	cp	r24, r25
    1804:	50 f4       	brcc	.+20     	; 0x181a <xTaskGenericNotifyFromISR+0x1e6>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    1806:	c1 14       	cp	r12, r1
    1808:	d1 04       	cpc	r13, r1
    180a:	19 f0       	breq	.+6      	; 0x1812 <xTaskGenericNotifyFromISR+0x1de>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    180c:	81 e0       	ldi	r24, 0x01	; 1
    180e:	f6 01       	movw	r30, r12
    1810:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    1812:	81 e0       	ldi	r24, 0x01	; 1
    1814:	80 93 d6 00 	sts	0x00D6, r24
    1818:	01 c0       	rjmp	.+2      	; 0x181c <xTaskGenericNotifyFromISR+0x1e8>
    181a:	81 e0       	ldi	r24, 0x01	; 1
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }
    181c:	df 91       	pop	r29
    181e:	cf 91       	pop	r28
    1820:	0f 91       	pop	r16
    1822:	ff 90       	pop	r15
    1824:	ef 90       	pop	r14
    1826:	df 90       	pop	r13
    1828:	cf 90       	pop	r12
    182a:	08 95       	ret

0000182c <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    182c:	cf 93       	push	r28
    182e:	df 93       	push	r29
    1830:	ec 01       	movw	r28, r24
    1832:	e6 2f       	mov	r30, r22
    1834:	ba 01       	movw	r22, r20

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1836:	f0 e0       	ldi	r31, 0x00	; 0
    1838:	dc 01       	movw	r26, r24
    183a:	ae 0f       	add	r26, r30
    183c:	bf 1f       	adc	r27, r31
    183e:	95 96       	adiw	r26, 0x25	; 37
    1840:	2c 91       	ld	r18, X
    1842:	95 97       	sbiw	r26, 0x25	; 37
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1844:	82 e0       	ldi	r24, 0x02	; 2
    1846:	95 96       	adiw	r26, 0x25	; 37
    1848:	8c 93       	st	X, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    184a:	ee 0f       	add	r30, r30
    184c:	ff 1f       	adc	r31, r31
    184e:	ee 0f       	add	r30, r30
    1850:	ff 1f       	adc	r31, r31
    1852:	ec 0f       	add	r30, r28
    1854:	fd 1f       	adc	r31, r29
    1856:	81 a1       	ldd	r24, Z+33	; 0x21
    1858:	92 a1       	ldd	r25, Z+34	; 0x22
    185a:	a3 a1       	ldd	r26, Z+35	; 0x23
    185c:	b4 a1       	ldd	r27, Z+36	; 0x24
    185e:	01 96       	adiw	r24, 0x01	; 1
    1860:	a1 1d       	adc	r26, r1
    1862:	b1 1d       	adc	r27, r1
    1864:	81 a3       	std	Z+33, r24	; 0x21
    1866:	92 a3       	std	Z+34, r25	; 0x22
    1868:	a3 a3       	std	Z+35, r26	; 0x23
    186a:	b4 a3       	std	Z+36, r27	; 0x24

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    186c:	21 30       	cpi	r18, 0x01	; 1
    186e:	09 f0       	breq	.+2      	; 0x1872 <vTaskGenericNotifyGiveFromISR+0x46>
    1870:	8c c0       	rjmp	.+280    	; 0x198a <vTaskGenericNotifyGiveFromISR+0x15e>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1872:	80 91 d4 00 	lds	r24, 0x00D4
    1876:	88 23       	and	r24, r24
    1878:	09 f0       	breq	.+2      	; 0x187c <vTaskGenericNotifyGiveFromISR+0x50>
    187a:	55 c0       	rjmp	.+170    	; 0x1926 <vTaskGenericNotifyGiveFromISR+0xfa>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    187c:	aa 85       	ldd	r26, Y+10	; 0x0a
    187e:	bb 85       	ldd	r27, Y+11	; 0x0b
    1880:	4c 81       	ldd	r20, Y+4	; 0x04
    1882:	5d 81       	ldd	r21, Y+5	; 0x05
    1884:	8e 81       	ldd	r24, Y+6	; 0x06
    1886:	9f 81       	ldd	r25, Y+7	; 0x07
    1888:	fa 01       	movw	r30, r20
    188a:	95 83       	std	Z+5, r25	; 0x05
    188c:	84 83       	std	Z+4, r24	; 0x04
    188e:	2e 81       	ldd	r18, Y+6	; 0x06
    1890:	3f 81       	ldd	r19, Y+7	; 0x07
    1892:	f9 01       	movw	r30, r18
    1894:	53 83       	std	Z+3, r21	; 0x03
    1896:	42 83       	std	Z+2, r20	; 0x02
    1898:	ae 01       	movw	r20, r28
    189a:	4e 5f       	subi	r20, 0xFE	; 254
    189c:	5f 4f       	sbci	r21, 0xFF	; 255
    189e:	11 96       	adiw	r26, 0x01	; 1
    18a0:	8d 91       	ld	r24, X+
    18a2:	9c 91       	ld	r25, X
    18a4:	12 97       	sbiw	r26, 0x02	; 2
    18a6:	84 17       	cp	r24, r20
    18a8:	95 07       	cpc	r25, r21
    18aa:	21 f4       	brne	.+8      	; 0x18b4 <vTaskGenericNotifyGiveFromISR+0x88>
    18ac:	12 96       	adiw	r26, 0x02	; 2
    18ae:	3c 93       	st	X, r19
    18b0:	2e 93       	st	-X, r18
    18b2:	11 97       	sbiw	r26, 0x01	; 1
    18b4:	1b 86       	std	Y+11, r1	; 0x0b
    18b6:	1a 86       	std	Y+10, r1	; 0x0a
    18b8:	8c 91       	ld	r24, X
    18ba:	81 50       	subi	r24, 0x01	; 1
    18bc:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    18be:	9e 89       	ldd	r25, Y+22	; 0x16
    18c0:	80 91 d5 00 	lds	r24, 0x00D5
    18c4:	89 17       	cp	r24, r25
    18c6:	10 f4       	brcc	.+4      	; 0x18cc <vTaskGenericNotifyGiveFromISR+0xa0>
    18c8:	90 93 d5 00 	sts	0x00D5, r25
    18cc:	89 2f       	mov	r24, r25
    18ce:	90 e0       	ldi	r25, 0x00	; 0
    18d0:	fc 01       	movw	r30, r24
    18d2:	a3 e0       	ldi	r26, 0x03	; 3
    18d4:	ee 0f       	add	r30, r30
    18d6:	ff 1f       	adc	r31, r31
    18d8:	aa 95       	dec	r26
    18da:	e1 f7       	brne	.-8      	; 0x18d4 <vTaskGenericNotifyGiveFromISR+0xa8>
    18dc:	e8 0f       	add	r30, r24
    18de:	f9 1f       	adc	r31, r25
    18e0:	ec 51       	subi	r30, 0x1C	; 28
    18e2:	ff 4f       	sbci	r31, 0xFF	; 255
    18e4:	a1 81       	ldd	r26, Z+1	; 0x01
    18e6:	b2 81       	ldd	r27, Z+2	; 0x02
    18e8:	bd 83       	std	Y+5, r27	; 0x05
    18ea:	ac 83       	std	Y+4, r26	; 0x04
    18ec:	14 96       	adiw	r26, 0x04	; 4
    18ee:	8d 91       	ld	r24, X+
    18f0:	9c 91       	ld	r25, X
    18f2:	15 97       	sbiw	r26, 0x05	; 5
    18f4:	9f 83       	std	Y+7, r25	; 0x07
    18f6:	8e 83       	std	Y+6, r24	; 0x06
    18f8:	14 96       	adiw	r26, 0x04	; 4
    18fa:	ed 91       	ld	r30, X+
    18fc:	fc 91       	ld	r31, X
    18fe:	15 97       	sbiw	r26, 0x05	; 5
    1900:	53 83       	std	Z+3, r21	; 0x03
    1902:	42 83       	std	Z+2, r20	; 0x02
    1904:	15 96       	adiw	r26, 0x05	; 5
    1906:	5c 93       	st	X, r21
    1908:	4e 93       	st	-X, r20
    190a:	14 97       	sbiw	r26, 0x04	; 4
    190c:	ee 89       	ldd	r30, Y+22	; 0x16
    190e:	89 e0       	ldi	r24, 0x09	; 9
    1910:	e8 9f       	mul	r30, r24
    1912:	f0 01       	movw	r30, r0
    1914:	11 24       	eor	r1, r1
    1916:	ec 51       	subi	r30, 0x1C	; 28
    1918:	ff 4f       	sbci	r31, 0xFF	; 255
    191a:	fb 87       	std	Y+11, r31	; 0x0b
    191c:	ea 87       	std	Y+10, r30	; 0x0a
    191e:	80 81       	ld	r24, Z
    1920:	8f 5f       	subi	r24, 0xFF	; 255
    1922:	80 83       	st	Z, r24
    1924:	21 c0       	rjmp	.+66     	; 0x1968 <vTaskGenericNotifyGiveFromISR+0x13c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1926:	a0 91 1f 01 	lds	r26, 0x011F
    192a:	b0 91 20 01 	lds	r27, 0x0120
    192e:	bf 87       	std	Y+15, r27	; 0x0f
    1930:	ae 87       	std	Y+14, r26	; 0x0e
    1932:	14 96       	adiw	r26, 0x04	; 4
    1934:	8d 91       	ld	r24, X+
    1936:	9c 91       	ld	r25, X
    1938:	15 97       	sbiw	r26, 0x05	; 5
    193a:	99 8b       	std	Y+17, r25	; 0x11
    193c:	88 8b       	std	Y+16, r24	; 0x10
    193e:	ce 01       	movw	r24, r28
    1940:	0c 96       	adiw	r24, 0x0c	; 12
    1942:	14 96       	adiw	r26, 0x04	; 4
    1944:	ed 91       	ld	r30, X+
    1946:	fc 91       	ld	r31, X
    1948:	15 97       	sbiw	r26, 0x05	; 5
    194a:	93 83       	std	Z+3, r25	; 0x03
    194c:	82 83       	std	Z+2, r24	; 0x02
    194e:	15 96       	adiw	r26, 0x05	; 5
    1950:	9c 93       	st	X, r25
    1952:	8e 93       	st	-X, r24
    1954:	14 97       	sbiw	r26, 0x04	; 4
    1956:	8e e1       	ldi	r24, 0x1E	; 30
    1958:	91 e0       	ldi	r25, 0x01	; 1
    195a:	9d 8b       	std	Y+21, r25	; 0x15
    195c:	8c 8b       	std	Y+20, r24	; 0x14
    195e:	80 91 1e 01 	lds	r24, 0x011E
    1962:	8f 5f       	subi	r24, 0xFF	; 255
    1964:	80 93 1e 01 	sts	0x011E, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1968:	e0 91 d2 00 	lds	r30, 0x00D2
    196c:	f0 91 d3 00 	lds	r31, 0x00D3
    1970:	9e 89       	ldd	r25, Y+22	; 0x16
    1972:	86 89       	ldd	r24, Z+22	; 0x16
    1974:	89 17       	cp	r24, r25
    1976:	48 f4       	brcc	.+18     	; 0x198a <vTaskGenericNotifyGiveFromISR+0x15e>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    1978:	61 15       	cp	r22, r1
    197a:	71 05       	cpc	r23, r1
    197c:	19 f0       	breq	.+6      	; 0x1984 <vTaskGenericNotifyGiveFromISR+0x158>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	fb 01       	movw	r30, r22
    1982:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    1984:	81 e0       	ldi	r24, 0x01	; 1
    1986:	80 93 d6 00 	sts	0x00D6, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    198a:	df 91       	pop	r29
    198c:	cf 91       	pop	r28
    198e:	08 95       	ret

00001990 <xTaskGenericNotifyStateClear>:

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    1990:	00 97       	sbiw	r24, 0x00	; 0
    1992:	21 f4       	brne	.+8      	; 0x199c <xTaskGenericNotifyStateClear+0xc>
    1994:	80 91 d2 00 	lds	r24, 0x00D2
    1998:	90 91 d3 00 	lds	r25, 0x00D3

        taskENTER_CRITICAL();
    199c:	0f b6       	in	r0, 0x3f	; 63
    199e:	f8 94       	cli
    19a0:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    19a2:	fc 01       	movw	r30, r24
    19a4:	e6 0f       	add	r30, r22
    19a6:	f1 1d       	adc	r31, r1
    19a8:	85 a1       	ldd	r24, Z+37	; 0x25
    19aa:	82 30       	cpi	r24, 0x02	; 2
    19ac:	11 f0       	breq	.+4      	; 0x19b2 <xTaskGenericNotifyStateClear+0x22>
    19ae:	80 e0       	ldi	r24, 0x00	; 0
    19b0:	02 c0       	rjmp	.+4      	; 0x19b6 <xTaskGenericNotifyStateClear+0x26>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    19b2:	15 a2       	std	Z+37, r1	; 0x25
    19b4:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();
    19b6:	0f 90       	pop	r0
    19b8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    19ba:	08 95       	ret

000019bc <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    19bc:	ef 92       	push	r14
    19be:	ff 92       	push	r15
    19c0:	0f 93       	push	r16
    19c2:	1f 93       	push	r17
    19c4:	79 01       	movw	r14, r18
    19c6:	8a 01       	movw	r16, r20
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    19c8:	00 97       	sbiw	r24, 0x00	; 0
    19ca:	21 f4       	brne	.+8      	; 0x19d4 <ulTaskGenericNotifyValueClear+0x18>
    19cc:	80 91 d2 00 	lds	r24, 0x00D2
    19d0:	90 91 d3 00 	lds	r25, 0x00D3

        taskENTER_CRITICAL();
    19d4:	0f b6       	in	r0, 0x3f	; 63
    19d6:	f8 94       	cli
    19d8:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    19da:	e6 2f       	mov	r30, r22
    19dc:	f0 e0       	ldi	r31, 0x00	; 0
    19de:	ee 0f       	add	r30, r30
    19e0:	ff 1f       	adc	r31, r31
    19e2:	ee 0f       	add	r30, r30
    19e4:	ff 1f       	adc	r31, r31
    19e6:	e8 0f       	add	r30, r24
    19e8:	f9 1f       	adc	r31, r25
    19ea:	21 a1       	ldd	r18, Z+33	; 0x21
    19ec:	32 a1       	ldd	r19, Z+34	; 0x22
    19ee:	43 a1       	ldd	r20, Z+35	; 0x23
    19f0:	54 a1       	ldd	r21, Z+36	; 0x24
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    19f2:	81 a1       	ldd	r24, Z+33	; 0x21
    19f4:	92 a1       	ldd	r25, Z+34	; 0x22
    19f6:	a3 a1       	ldd	r26, Z+35	; 0x23
    19f8:	b4 a1       	ldd	r27, Z+36	; 0x24
    19fa:	e0 94       	com	r14
    19fc:	f0 94       	com	r15
    19fe:	00 95       	com	r16
    1a00:	10 95       	com	r17
    1a02:	8e 21       	and	r24, r14
    1a04:	9f 21       	and	r25, r15
    1a06:	a0 23       	and	r26, r16
    1a08:	b1 23       	and	r27, r17
    1a0a:	81 a3       	std	Z+33, r24	; 0x21
    1a0c:	92 a3       	std	Z+34, r25	; 0x22
    1a0e:	a3 a3       	std	Z+35, r26	; 0x23
    1a10:	b4 a3       	std	Z+36, r27	; 0x24
        }
        taskEXIT_CRITICAL();
    1a12:	0f 90       	pop	r0
    1a14:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    1a16:	b9 01       	movw	r22, r18
    1a18:	ca 01       	movw	r24, r20
    1a1a:	1f 91       	pop	r17
    1a1c:	0f 91       	pop	r16
    1a1e:	ff 90       	pop	r15
    1a20:	ef 90       	pop	r14
    1a22:	08 95       	ret

00001a24 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    1a24:	ef 92       	push	r14
    1a26:	ff 92       	push	r15
    1a28:	0f 93       	push	r16
    1a2a:	cf 93       	push	r28
    1a2c:	df 93       	push	r29
    1a2e:	ec 01       	movw	r28, r24

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
    1a30:	0f b6       	in	r0, 0x3f	; 63
    1a32:	f8 94       	cli
    1a34:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    1a36:	e1 14       	cp	r14, r1
    1a38:	f1 04       	cpc	r15, r1
    1a3a:	89 f0       	breq	.+34     	; 0x1a5e <xTaskGenericNotify+0x3a>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    1a3c:	e6 2f       	mov	r30, r22
    1a3e:	f0 e0       	ldi	r31, 0x00	; 0
    1a40:	ee 0f       	add	r30, r30
    1a42:	ff 1f       	adc	r31, r31
    1a44:	ee 0f       	add	r30, r30
    1a46:	ff 1f       	adc	r31, r31
    1a48:	ec 0f       	add	r30, r28
    1a4a:	fd 1f       	adc	r31, r29
    1a4c:	81 a1       	ldd	r24, Z+33	; 0x21
    1a4e:	92 a1       	ldd	r25, Z+34	; 0x22
    1a50:	a3 a1       	ldd	r26, Z+35	; 0x23
    1a52:	b4 a1       	ldd	r27, Z+36	; 0x24
    1a54:	f7 01       	movw	r30, r14
    1a56:	80 83       	st	Z, r24
    1a58:	91 83       	std	Z+1, r25	; 0x01
    1a5a:	a2 83       	std	Z+2, r26	; 0x02
    1a5c:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1a5e:	a6 2f       	mov	r26, r22
    1a60:	b0 e0       	ldi	r27, 0x00	; 0
    1a62:	fe 01       	movw	r30, r28
    1a64:	ea 0f       	add	r30, r26
    1a66:	fb 1f       	adc	r31, r27
    1a68:	65 a1       	ldd	r22, Z+37	; 0x25

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1a6a:	82 e0       	ldi	r24, 0x02	; 2
    1a6c:	85 a3       	std	Z+37, r24	; 0x25

            switch( eAction )
    1a6e:	02 30       	cpi	r16, 0x02	; 2
    1a70:	d1 f0       	breq	.+52     	; 0x1aa6 <xTaskGenericNotify+0x82>
    1a72:	03 30       	cpi	r16, 0x03	; 3
    1a74:	18 f4       	brcc	.+6      	; 0x1a7c <xTaskGenericNotify+0x58>
    1a76:	01 30       	cpi	r16, 0x01	; 1
    1a78:	c9 f5       	brne	.+114    	; 0x1aec <xTaskGenericNotify+0xc8>
    1a7a:	05 c0       	rjmp	.+10     	; 0x1a86 <xTaskGenericNotify+0x62>
    1a7c:	03 30       	cpi	r16, 0x03	; 3
    1a7e:	51 f1       	breq	.+84     	; 0x1ad4 <xTaskGenericNotify+0xb0>
    1a80:	04 30       	cpi	r16, 0x04	; 4
    1a82:	a1 f5       	brne	.+104    	; 0x1aec <xTaskGenericNotify+0xc8>
    1a84:	23 c0       	rjmp	.+70     	; 0x1acc <xTaskGenericNotify+0xa8>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1a86:	fd 01       	movw	r30, r26
    1a88:	ee 0f       	add	r30, r30
    1a8a:	ff 1f       	adc	r31, r31
    1a8c:	ee 0f       	add	r30, r30
    1a8e:	ff 1f       	adc	r31, r31
    1a90:	ec 0f       	add	r30, r28
    1a92:	fd 1f       	adc	r31, r29
    1a94:	81 a1       	ldd	r24, Z+33	; 0x21
    1a96:	92 a1       	ldd	r25, Z+34	; 0x22
    1a98:	a3 a1       	ldd	r26, Z+35	; 0x23
    1a9a:	b4 a1       	ldd	r27, Z+36	; 0x24
    1a9c:	82 2b       	or	r24, r18
    1a9e:	93 2b       	or	r25, r19
    1aa0:	a4 2b       	or	r26, r20
    1aa2:	b5 2b       	or	r27, r21
    1aa4:	0e c0       	rjmp	.+28     	; 0x1ac2 <xTaskGenericNotify+0x9e>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1aa6:	fd 01       	movw	r30, r26
    1aa8:	ee 0f       	add	r30, r30
    1aaa:	ff 1f       	adc	r31, r31
    1aac:	ee 0f       	add	r30, r30
    1aae:	ff 1f       	adc	r31, r31
    1ab0:	ec 0f       	add	r30, r28
    1ab2:	fd 1f       	adc	r31, r29
    1ab4:	81 a1       	ldd	r24, Z+33	; 0x21
    1ab6:	92 a1       	ldd	r25, Z+34	; 0x22
    1ab8:	a3 a1       	ldd	r26, Z+35	; 0x23
    1aba:	b4 a1       	ldd	r27, Z+36	; 0x24
    1abc:	01 96       	adiw	r24, 0x01	; 1
    1abe:	a1 1d       	adc	r26, r1
    1ac0:	b1 1d       	adc	r27, r1
    1ac2:	81 a3       	std	Z+33, r24	; 0x21
    1ac4:	92 a3       	std	Z+34, r25	; 0x22
    1ac6:	a3 a3       	std	Z+35, r26	; 0x23
    1ac8:	b4 a3       	std	Z+36, r27	; 0x24
    1aca:	10 c0       	rjmp	.+32     	; 0x1aec <xTaskGenericNotify+0xc8>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1acc:	62 30       	cpi	r22, 0x02	; 2
    1ace:	11 f4       	brne	.+4      	; 0x1ad4 <xTaskGenericNotify+0xb0>
    1ad0:	80 e0       	ldi	r24, 0x00	; 0
    1ad2:	6e c0       	rjmp	.+220    	; 0x1bb0 <xTaskGenericNotify+0x18c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    1ad4:	aa 0f       	add	r26, r26
    1ad6:	bb 1f       	adc	r27, r27
    1ad8:	aa 0f       	add	r26, r26
    1ada:	bb 1f       	adc	r27, r27
    1adc:	ac 0f       	add	r26, r28
    1ade:	bd 1f       	adc	r27, r29
    1ae0:	91 96       	adiw	r26, 0x21	; 33
    1ae2:	2d 93       	st	X+, r18
    1ae4:	3d 93       	st	X+, r19
    1ae6:	4d 93       	st	X+, r20
    1ae8:	5c 93       	st	X, r21
    1aea:	94 97       	sbiw	r26, 0x24	; 36

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1aec:	61 30       	cpi	r22, 0x01	; 1
    1aee:	09 f0       	breq	.+2      	; 0x1af2 <xTaskGenericNotify+0xce>
    1af0:	5e c0       	rjmp	.+188    	; 0x1bae <xTaskGenericNotify+0x18a>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1af2:	aa 85       	ldd	r26, Y+10	; 0x0a
    1af4:	bb 85       	ldd	r27, Y+11	; 0x0b
    1af6:	4c 81       	ldd	r20, Y+4	; 0x04
    1af8:	5d 81       	ldd	r21, Y+5	; 0x05
    1afa:	8e 81       	ldd	r24, Y+6	; 0x06
    1afc:	9f 81       	ldd	r25, Y+7	; 0x07
    1afe:	fa 01       	movw	r30, r20
    1b00:	95 83       	std	Z+5, r25	; 0x05
    1b02:	84 83       	std	Z+4, r24	; 0x04
    1b04:	2e 81       	ldd	r18, Y+6	; 0x06
    1b06:	3f 81       	ldd	r19, Y+7	; 0x07
    1b08:	f9 01       	movw	r30, r18
    1b0a:	53 83       	std	Z+3, r21	; 0x03
    1b0c:	42 83       	std	Z+2, r20	; 0x02
    1b0e:	ae 01       	movw	r20, r28
    1b10:	4e 5f       	subi	r20, 0xFE	; 254
    1b12:	5f 4f       	sbci	r21, 0xFF	; 255
    1b14:	11 96       	adiw	r26, 0x01	; 1
    1b16:	8d 91       	ld	r24, X+
    1b18:	9c 91       	ld	r25, X
    1b1a:	12 97       	sbiw	r26, 0x02	; 2
    1b1c:	84 17       	cp	r24, r20
    1b1e:	95 07       	cpc	r25, r21
    1b20:	21 f4       	brne	.+8      	; 0x1b2a <xTaskGenericNotify+0x106>
    1b22:	12 96       	adiw	r26, 0x02	; 2
    1b24:	3c 93       	st	X, r19
    1b26:	2e 93       	st	-X, r18
    1b28:	11 97       	sbiw	r26, 0x01	; 1
    1b2a:	1b 86       	std	Y+11, r1	; 0x0b
    1b2c:	1a 86       	std	Y+10, r1	; 0x0a
    1b2e:	8c 91       	ld	r24, X
    1b30:	81 50       	subi	r24, 0x01	; 1
    1b32:	8c 93       	st	X, r24
                prvAddTaskToReadyList( pxTCB );
    1b34:	9e 89       	ldd	r25, Y+22	; 0x16
    1b36:	80 91 d5 00 	lds	r24, 0x00D5
    1b3a:	89 17       	cp	r24, r25
    1b3c:	10 f4       	brcc	.+4      	; 0x1b42 <xTaskGenericNotify+0x11e>
    1b3e:	90 93 d5 00 	sts	0x00D5, r25
    1b42:	89 2f       	mov	r24, r25
    1b44:	90 e0       	ldi	r25, 0x00	; 0
    1b46:	fc 01       	movw	r30, r24
    1b48:	33 e0       	ldi	r19, 0x03	; 3
    1b4a:	ee 0f       	add	r30, r30
    1b4c:	ff 1f       	adc	r31, r31
    1b4e:	3a 95       	dec	r19
    1b50:	e1 f7       	brne	.-8      	; 0x1b4a <xTaskGenericNotify+0x126>
    1b52:	e8 0f       	add	r30, r24
    1b54:	f9 1f       	adc	r31, r25
    1b56:	ec 51       	subi	r30, 0x1C	; 28
    1b58:	ff 4f       	sbci	r31, 0xFF	; 255
    1b5a:	a1 81       	ldd	r26, Z+1	; 0x01
    1b5c:	b2 81       	ldd	r27, Z+2	; 0x02
    1b5e:	bd 83       	std	Y+5, r27	; 0x05
    1b60:	ac 83       	std	Y+4, r26	; 0x04
    1b62:	14 96       	adiw	r26, 0x04	; 4
    1b64:	8d 91       	ld	r24, X+
    1b66:	9c 91       	ld	r25, X
    1b68:	15 97       	sbiw	r26, 0x05	; 5
    1b6a:	9f 83       	std	Y+7, r25	; 0x07
    1b6c:	8e 83       	std	Y+6, r24	; 0x06
    1b6e:	14 96       	adiw	r26, 0x04	; 4
    1b70:	ed 91       	ld	r30, X+
    1b72:	fc 91       	ld	r31, X
    1b74:	15 97       	sbiw	r26, 0x05	; 5
    1b76:	53 83       	std	Z+3, r21	; 0x03
    1b78:	42 83       	std	Z+2, r20	; 0x02
    1b7a:	15 96       	adiw	r26, 0x05	; 5
    1b7c:	5c 93       	st	X, r21
    1b7e:	4e 93       	st	-X, r20
    1b80:	14 97       	sbiw	r26, 0x04	; 4
    1b82:	ee 89       	ldd	r30, Y+22	; 0x16
    1b84:	89 e0       	ldi	r24, 0x09	; 9
    1b86:	e8 9f       	mul	r30, r24
    1b88:	f0 01       	movw	r30, r0
    1b8a:	11 24       	eor	r1, r1
    1b8c:	ec 51       	subi	r30, 0x1C	; 28
    1b8e:	ff 4f       	sbci	r31, 0xFF	; 255
    1b90:	fb 87       	std	Y+11, r31	; 0x0b
    1b92:	ea 87       	std	Y+10, r30	; 0x0a
    1b94:	80 81       	ld	r24, Z
    1b96:	8f 5f       	subi	r24, 0xFF	; 255
    1b98:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1b9a:	e0 91 d2 00 	lds	r30, 0x00D2
    1b9e:	f0 91 d3 00 	lds	r31, 0x00D3
    1ba2:	9e 89       	ldd	r25, Y+22	; 0x16
    1ba4:	86 89       	ldd	r24, Z+22	; 0x16
    1ba6:	89 17       	cp	r24, r25
    1ba8:	10 f4       	brcc	.+4      	; 0x1bae <xTaskGenericNotify+0x18a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    1baa:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    1bae:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    1bb0:	0f 90       	pop	r0
    1bb2:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    1bb4:	df 91       	pop	r29
    1bb6:	cf 91       	pop	r28
    1bb8:	0f 91       	pop	r16
    1bba:	ff 90       	pop	r15
    1bbc:	ef 90       	pop	r14
    1bbe:	08 95       	ret

00001bc0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1bc0:	1f 93       	push	r17
    1bc2:	cf 93       	push	r28
    1bc4:	df 93       	push	r29
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    1bc6:	0f b6       	in	r0, 0x3f	; 63
    1bc8:	f8 94       	cli
    1bca:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    1bcc:	80 91 d4 00 	lds	r24, 0x00D4
    1bd0:	81 50       	subi	r24, 0x01	; 1
    1bd2:	80 93 d4 00 	sts	0x00D4, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1bd6:	80 91 d4 00 	lds	r24, 0x00D4
    1bda:	88 23       	and	r24, r24
    1bdc:	09 f0       	breq	.+2      	; 0x1be0 <xTaskResumeAll+0x20>
    1bde:	c7 c0       	rjmp	.+398    	; 0x1d6e <xTaskResumeAll+0x1ae>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1be0:	80 91 de 00 	lds	r24, 0x00DE
    1be4:	88 23       	and	r24, r24
    1be6:	09 f4       	brne	.+2      	; 0x1bea <xTaskResumeAll+0x2a>
    1be8:	c2 c0       	rjmp	.+388    	; 0x1d6e <xTaskResumeAll+0x1ae>
    1bea:	c0 e0       	ldi	r28, 0x00	; 0
    1bec:	d0 e0       	ldi	r29, 0x00	; 0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    1bee:	79 e0       	ldi	r23, 0x09	; 9

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    1bf0:	61 e0       	ldi	r22, 0x01	; 1
    1bf2:	84 c0       	rjmp	.+264    	; 0x1cfc <xTaskResumeAll+0x13c>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1bf4:	e0 91 23 01 	lds	r30, 0x0123
    1bf8:	f0 91 24 01 	lds	r31, 0x0124
    1bfc:	c6 81       	ldd	r28, Z+6	; 0x06
    1bfe:	d7 81       	ldd	r29, Z+7	; 0x07
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    1c00:	ac 89       	ldd	r26, Y+20	; 0x14
    1c02:	bd 89       	ldd	r27, Y+21	; 0x15
    1c04:	2e 85       	ldd	r18, Y+14	; 0x0e
    1c06:	3f 85       	ldd	r19, Y+15	; 0x0f
    1c08:	88 89       	ldd	r24, Y+16	; 0x10
    1c0a:	99 89       	ldd	r25, Y+17	; 0x11
    1c0c:	f9 01       	movw	r30, r18
    1c0e:	95 83       	std	Z+5, r25	; 0x05
    1c10:	84 83       	std	Z+4, r24	; 0x04
    1c12:	48 89       	ldd	r20, Y+16	; 0x10
    1c14:	59 89       	ldd	r21, Y+17	; 0x11
    1c16:	fa 01       	movw	r30, r20
    1c18:	33 83       	std	Z+3, r19	; 0x03
    1c1a:	22 83       	std	Z+2, r18	; 0x02
    1c1c:	9e 01       	movw	r18, r28
    1c1e:	24 5f       	subi	r18, 0xF4	; 244
    1c20:	3f 4f       	sbci	r19, 0xFF	; 255
    1c22:	11 96       	adiw	r26, 0x01	; 1
    1c24:	8d 91       	ld	r24, X+
    1c26:	9c 91       	ld	r25, X
    1c28:	12 97       	sbiw	r26, 0x02	; 2
    1c2a:	82 17       	cp	r24, r18
    1c2c:	93 07       	cpc	r25, r19
    1c2e:	21 f4       	brne	.+8      	; 0x1c38 <xTaskResumeAll+0x78>
    1c30:	12 96       	adiw	r26, 0x02	; 2
    1c32:	5c 93       	st	X, r21
    1c34:	4e 93       	st	-X, r20
    1c36:	11 97       	sbiw	r26, 0x01	; 1
    1c38:	1d 8a       	std	Y+21, r1	; 0x15
    1c3a:	1c 8a       	std	Y+20, r1	; 0x14
    1c3c:	8c 91       	ld	r24, X
    1c3e:	81 50       	subi	r24, 0x01	; 1
    1c40:	8c 93       	st	X, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1c42:	aa 85       	ldd	r26, Y+10	; 0x0a
    1c44:	bb 85       	ldd	r27, Y+11	; 0x0b
    1c46:	4c 81       	ldd	r20, Y+4	; 0x04
    1c48:	5d 81       	ldd	r21, Y+5	; 0x05
    1c4a:	8e 81       	ldd	r24, Y+6	; 0x06
    1c4c:	9f 81       	ldd	r25, Y+7	; 0x07
    1c4e:	fa 01       	movw	r30, r20
    1c50:	95 83       	std	Z+5, r25	; 0x05
    1c52:	84 83       	std	Z+4, r24	; 0x04
    1c54:	2e 81       	ldd	r18, Y+6	; 0x06
    1c56:	3f 81       	ldd	r19, Y+7	; 0x07
    1c58:	f9 01       	movw	r30, r18
    1c5a:	53 83       	std	Z+3, r21	; 0x03
    1c5c:	42 83       	std	Z+2, r20	; 0x02
    1c5e:	ae 01       	movw	r20, r28
    1c60:	4e 5f       	subi	r20, 0xFE	; 254
    1c62:	5f 4f       	sbci	r21, 0xFF	; 255
    1c64:	11 96       	adiw	r26, 0x01	; 1
    1c66:	8d 91       	ld	r24, X+
    1c68:	9c 91       	ld	r25, X
    1c6a:	12 97       	sbiw	r26, 0x02	; 2
    1c6c:	84 17       	cp	r24, r20
    1c6e:	95 07       	cpc	r25, r21
    1c70:	21 f4       	brne	.+8      	; 0x1c7a <xTaskResumeAll+0xba>
    1c72:	12 96       	adiw	r26, 0x02	; 2
    1c74:	3c 93       	st	X, r19
    1c76:	2e 93       	st	-X, r18
    1c78:	11 97       	sbiw	r26, 0x01	; 1
    1c7a:	1b 86       	std	Y+11, r1	; 0x0b
    1c7c:	1a 86       	std	Y+10, r1	; 0x0a
    1c7e:	8c 91       	ld	r24, X
    1c80:	81 50       	subi	r24, 0x01	; 1
    1c82:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    1c84:	9e 89       	ldd	r25, Y+22	; 0x16
    1c86:	80 91 d5 00 	lds	r24, 0x00D5
    1c8a:	89 17       	cp	r24, r25
    1c8c:	10 f4       	brcc	.+4      	; 0x1c92 <xTaskResumeAll+0xd2>
    1c8e:	90 93 d5 00 	sts	0x00D5, r25
    1c92:	89 2f       	mov	r24, r25
    1c94:	90 e0       	ldi	r25, 0x00	; 0
    1c96:	fc 01       	movw	r30, r24
    1c98:	23 e0       	ldi	r18, 0x03	; 3
    1c9a:	ee 0f       	add	r30, r30
    1c9c:	ff 1f       	adc	r31, r31
    1c9e:	2a 95       	dec	r18
    1ca0:	e1 f7       	brne	.-8      	; 0x1c9a <xTaskResumeAll+0xda>
    1ca2:	e8 0f       	add	r30, r24
    1ca4:	f9 1f       	adc	r31, r25
    1ca6:	ec 51       	subi	r30, 0x1C	; 28
    1ca8:	ff 4f       	sbci	r31, 0xFF	; 255
    1caa:	a1 81       	ldd	r26, Z+1	; 0x01
    1cac:	b2 81       	ldd	r27, Z+2	; 0x02
    1cae:	bd 83       	std	Y+5, r27	; 0x05
    1cb0:	ac 83       	std	Y+4, r26	; 0x04
    1cb2:	14 96       	adiw	r26, 0x04	; 4
    1cb4:	8d 91       	ld	r24, X+
    1cb6:	9c 91       	ld	r25, X
    1cb8:	15 97       	sbiw	r26, 0x05	; 5
    1cba:	9f 83       	std	Y+7, r25	; 0x07
    1cbc:	8e 83       	std	Y+6, r24	; 0x06
    1cbe:	14 96       	adiw	r26, 0x04	; 4
    1cc0:	ed 91       	ld	r30, X+
    1cc2:	fc 91       	ld	r31, X
    1cc4:	15 97       	sbiw	r26, 0x05	; 5
    1cc6:	53 83       	std	Z+3, r21	; 0x03
    1cc8:	42 83       	std	Z+2, r20	; 0x02
    1cca:	15 96       	adiw	r26, 0x05	; 5
    1ccc:	5c 93       	st	X, r21
    1cce:	4e 93       	st	-X, r20
    1cd0:	14 97       	sbiw	r26, 0x04	; 4
    1cd2:	ee 89       	ldd	r30, Y+22	; 0x16
    1cd4:	e7 9f       	mul	r30, r23
    1cd6:	f0 01       	movw	r30, r0
    1cd8:	11 24       	eor	r1, r1
    1cda:	ec 51       	subi	r30, 0x1C	; 28
    1cdc:	ff 4f       	sbci	r31, 0xFF	; 255
    1cde:	fb 87       	std	Y+11, r31	; 0x0b
    1ce0:	ea 87       	std	Y+10, r30	; 0x0a
    1ce2:	80 81       	ld	r24, Z
    1ce4:	8f 5f       	subi	r24, 0xFF	; 255
    1ce6:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1ce8:	e0 91 d2 00 	lds	r30, 0x00D2
    1cec:	f0 91 d3 00 	lds	r31, 0x00D3
    1cf0:	9e 89       	ldd	r25, Y+22	; 0x16
    1cf2:	86 89       	ldd	r24, Z+22	; 0x16
    1cf4:	98 17       	cp	r25, r24
    1cf6:	10 f0       	brcs	.+4      	; 0x1cfc <xTaskResumeAll+0x13c>
                    {
                        xYieldPending = pdTRUE;
    1cf8:	60 93 d6 00 	sts	0x00D6, r22
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1cfc:	80 91 1e 01 	lds	r24, 0x011E
    1d00:	88 23       	and	r24, r24
    1d02:	09 f0       	breq	.+2      	; 0x1d06 <xTaskResumeAll+0x146>
    1d04:	77 cf       	rjmp	.-274    	; 0x1bf4 <xTaskResumeAll+0x34>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    1d06:	cd 2b       	or	r28, r29
    1d08:	b9 f0       	breq	.+46     	; 0x1d38 <xTaskResumeAll+0x178>
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1d0a:	e0 91 1a 01 	lds	r30, 0x011A
    1d0e:	f0 91 1b 01 	lds	r31, 0x011B
    1d12:	80 81       	ld	r24, Z
    1d14:	88 23       	and	r24, r24
    1d16:	19 f4       	brne	.+6      	; 0x1d1e <xTaskResumeAll+0x15e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    1d18:	8f ef       	ldi	r24, 0xFF	; 255
    1d1a:	9f ef       	ldi	r25, 0xFF	; 255
    1d1c:	09 c0       	rjmp	.+18     	; 0x1d30 <xTaskResumeAll+0x170>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1d1e:	e0 91 1a 01 	lds	r30, 0x011A
    1d22:	f0 91 1b 01 	lds	r31, 0x011B
    1d26:	05 80       	ldd	r0, Z+5	; 0x05
    1d28:	f6 81       	ldd	r31, Z+6	; 0x06
    1d2a:	e0 2d       	mov	r30, r0
    1d2c:	80 81       	ld	r24, Z
    1d2e:	91 81       	ldd	r25, Z+1	; 0x01
    1d30:	90 93 da 00 	sts	0x00DA, r25
    1d34:	80 93 d9 00 	sts	0x00D9, r24
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    1d38:	c0 91 dc 00 	lds	r28, 0x00DC
    1d3c:	d0 91 dd 00 	lds	r29, 0x00DD

                    if( xPendedCounts > ( TickType_t ) 0U )
    1d40:	20 97       	sbiw	r28, 0x00	; 0
    1d42:	69 f0       	breq	.+26     	; 0x1d5e <xTaskResumeAll+0x19e>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    1d44:	11 e0       	ldi	r17, 0x01	; 1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    1d46:	0e 94 46 08 	call	0x108c	; 0x108c <xTaskIncrementTick>
    1d4a:	88 23       	and	r24, r24
    1d4c:	11 f0       	breq	.+4      	; 0x1d52 <xTaskResumeAll+0x192>
                            {
                                xYieldPending = pdTRUE;
    1d4e:	10 93 d6 00 	sts	0x00D6, r17
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    1d52:	21 97       	sbiw	r28, 0x01	; 1
                        } while( xPendedCounts > ( TickType_t ) 0U );
    1d54:	c1 f7       	brne	.-16     	; 0x1d46 <xTaskResumeAll+0x186>

                        xPendedTicks = 0;
    1d56:	10 92 dd 00 	sts	0x00DD, r1
    1d5a:	10 92 dc 00 	sts	0x00DC, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    1d5e:	80 91 d6 00 	lds	r24, 0x00D6
    1d62:	88 23       	and	r24, r24
    1d64:	21 f0       	breq	.+8      	; 0x1d6e <xTaskResumeAll+0x1ae>
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    1d66:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    1d6a:	81 e0       	ldi	r24, 0x01	; 1
    1d6c:	01 c0       	rjmp	.+2      	; 0x1d70 <xTaskResumeAll+0x1b0>
    1d6e:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    1d70:	0f 90       	pop	r0
    1d72:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
}
    1d74:	df 91       	pop	r29
    1d76:	cf 91       	pop	r28
    1d78:	1f 91       	pop	r17
    1d7a:	08 95       	ret

00001d7c <xTaskCatchUpTicks>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    1d7c:	20 91 d4 00 	lds	r18, 0x00D4
    1d80:	2f 5f       	subi	r18, 0xFF	; 255
    1d82:	20 93 d4 00 	sts	0x00D4, r18
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    xPendedTicks += xTicksToCatchUp;
    1d86:	20 91 dc 00 	lds	r18, 0x00DC
    1d8a:	30 91 dd 00 	lds	r19, 0x00DD
    1d8e:	28 0f       	add	r18, r24
    1d90:	39 1f       	adc	r19, r25
    1d92:	30 93 dd 00 	sts	0x00DD, r19
    1d96:	20 93 dc 00 	sts	0x00DC, r18
    xYieldOccurred = xTaskResumeAll();
    1d9a:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>

    return xYieldOccurred;
}
    1d9e:	08 95       	ret

00001da0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
    1da0:	0f 93       	push	r16
    1da2:	1f 93       	push	r17
    1da4:	cf 93       	push	r28
    1da6:	df 93       	push	r29
    1da8:	ec 01       	movw	r28, r24
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    1daa:	80 91 d2 00 	lds	r24, 0x00D2
    1dae:	90 91 d3 00 	lds	r25, 0x00D3
    1db2:	c8 17       	cp	r28, r24
    1db4:	d9 07       	cpc	r29, r25
    1db6:	09 f4       	brne	.+2      	; 0x1dba <vTaskResume+0x1a>
    1db8:	5d c0       	rjmp	.+186    	; 0x1e74 <vTaskResume+0xd4>
    1dba:	20 97       	sbiw	r28, 0x00	; 0
    1dbc:	09 f4       	brne	.+2      	; 0x1dc0 <vTaskResume+0x20>
    1dbe:	5a c0       	rjmp	.+180    	; 0x1e74 <vTaskResume+0xd4>
        {
            taskENTER_CRITICAL();
    1dc0:	0f b6       	in	r0, 0x3f	; 63
    1dc2:	f8 94       	cli
    1dc4:	0f 92       	push	r0

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    1dc6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1dc8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1dca:	80 53       	subi	r24, 0x30	; 48
    1dcc:	91 40       	sbci	r25, 0x01	; 1
    1dce:	09 f0       	breq	.+2      	; 0x1dd2 <vTaskResume+0x32>
    1dd0:	41 c0       	rjmp	.+130    	; 0x1e54 <vTaskResume+0xb4>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    1dd2:	8c 89       	ldd	r24, Y+20	; 0x14
    1dd4:	9d 89       	ldd	r25, Y+21	; 0x15
    1dd6:	21 e0       	ldi	r18, 0x01	; 1
    1dd8:	8e 31       	cpi	r24, 0x1E	; 30
    1dda:	92 07       	cpc	r25, r18
    1ddc:	d9 f1       	breq	.+118    	; 0x1e54 <vTaskResume+0xb4>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    1dde:	89 2b       	or	r24, r25
    1de0:	c9 f5       	brne	.+114    	; 0x1e54 <vTaskResume+0xb4>
    1de2:	3b c0       	rjmp	.+118    	; 0x1e5a <vTaskResume+0xba>
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    1de4:	90 93 d5 00 	sts	0x00D5, r25
    1de8:	89 2f       	mov	r24, r25
    1dea:	90 e0       	ldi	r25, 0x00	; 0
    1dec:	fc 01       	movw	r30, r24
    1dee:	33 e0       	ldi	r19, 0x03	; 3
    1df0:	ee 0f       	add	r30, r30
    1df2:	ff 1f       	adc	r31, r31
    1df4:	3a 95       	dec	r19
    1df6:	e1 f7       	brne	.-8      	; 0x1df0 <vTaskResume+0x50>
    1df8:	e8 0f       	add	r30, r24
    1dfa:	f9 1f       	adc	r31, r25
    1dfc:	ec 51       	subi	r30, 0x1C	; 28
    1dfe:	ff 4f       	sbci	r31, 0xFF	; 255
    1e00:	a1 81       	ldd	r26, Z+1	; 0x01
    1e02:	b2 81       	ldd	r27, Z+2	; 0x02
    1e04:	bd 83       	std	Y+5, r27	; 0x05
    1e06:	ac 83       	std	Y+4, r26	; 0x04
    1e08:	14 96       	adiw	r26, 0x04	; 4
    1e0a:	8d 91       	ld	r24, X+
    1e0c:	9c 91       	ld	r25, X
    1e0e:	15 97       	sbiw	r26, 0x05	; 5
    1e10:	9f 83       	std	Y+7, r25	; 0x07
    1e12:	8e 83       	std	Y+6, r24	; 0x06
    1e14:	14 96       	adiw	r26, 0x04	; 4
    1e16:	ed 91       	ld	r30, X+
    1e18:	fc 91       	ld	r31, X
    1e1a:	15 97       	sbiw	r26, 0x05	; 5
    1e1c:	13 83       	std	Z+3, r17	; 0x03
    1e1e:	02 83       	std	Z+2, r16	; 0x02
    1e20:	15 96       	adiw	r26, 0x05	; 5
    1e22:	1c 93       	st	X, r17
    1e24:	0e 93       	st	-X, r16
    1e26:	14 97       	sbiw	r26, 0x04	; 4
    1e28:	ee 89       	ldd	r30, Y+22	; 0x16
    1e2a:	89 e0       	ldi	r24, 0x09	; 9
    1e2c:	e8 9f       	mul	r30, r24
    1e2e:	f0 01       	movw	r30, r0
    1e30:	11 24       	eor	r1, r1
    1e32:	ec 51       	subi	r30, 0x1C	; 28
    1e34:	ff 4f       	sbci	r31, 0xFF	; 255
    1e36:	fb 87       	std	Y+11, r31	; 0x0b
    1e38:	ea 87       	std	Y+10, r30	; 0x0a
    1e3a:	80 81       	ld	r24, Z
    1e3c:	8f 5f       	subi	r24, 0xFF	; 255
    1e3e:	80 83       	st	Z, r24

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e40:	e0 91 d2 00 	lds	r30, 0x00D2
    1e44:	f0 91 d3 00 	lds	r31, 0x00D3
    1e48:	9e 89       	ldd	r25, Y+22	; 0x16
    1e4a:	86 89       	ldd	r24, Z+22	; 0x16
    1e4c:	98 17       	cp	r25, r24
    1e4e:	10 f0       	brcs	.+4      	; 0x1e54 <vTaskResume+0xb4>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
    1e50:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    1e54:	0f 90       	pop	r0
    1e56:	0f be       	out	0x3f, r0	; 63
    1e58:	0d c0       	rjmp	.+26     	; 0x1e74 <vTaskResume+0xd4>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1e5a:	8e 01       	movw	r16, r28
    1e5c:	0e 5f       	subi	r16, 0xFE	; 254
    1e5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e60:	c8 01       	movw	r24, r16
    1e62:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    1e66:	9e 89       	ldd	r25, Y+22	; 0x16
    1e68:	80 91 d5 00 	lds	r24, 0x00D5
    1e6c:	89 17       	cp	r24, r25
    1e6e:	08 f4       	brcc	.+2      	; 0x1e72 <vTaskResume+0xd2>
    1e70:	b9 cf       	rjmp	.-142    	; 0x1de4 <vTaskResume+0x44>
    1e72:	ba cf       	rjmp	.-140    	; 0x1de8 <vTaskResume+0x48>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    1e74:	df 91       	pop	r29
    1e76:	cf 91       	pop	r28
    1e78:	1f 91       	pop	r17
    1e7a:	0f 91       	pop	r16
    1e7c:	08 95       	ret

00001e7e <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    1e7e:	ff 92       	push	r15
    1e80:	0f 93       	push	r16
    1e82:	1f 93       	push	r17
    1e84:	cf 93       	push	r28
    1e86:	df 93       	push	r29
    1e88:	ec 01       	movw	r28, r24
    1e8a:	f6 2e       	mov	r15, r22
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    1e8c:	00 91 d7 00 	lds	r16, 0x00D7
    1e90:	10 91 d8 00 	lds	r17, 0x00D8
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1e94:	80 91 d2 00 	lds	r24, 0x00D2
    1e98:	90 91 d3 00 	lds	r25, 0x00D3
    1e9c:	02 96       	adiw	r24, 0x02	; 2
    1e9e:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    1ea2:	8f ef       	ldi	r24, 0xFF	; 255
    1ea4:	cf 3f       	cpi	r28, 0xFF	; 255
    1ea6:	d8 07       	cpc	r29, r24
    1ea8:	c1 f5       	brne	.+112    	; 0x1f1a <prvAddCurrentTaskToDelayedList+0x9c>
    1eaa:	ff 20       	and	r15, r15
    1eac:	b1 f1       	breq	.+108    	; 0x1f1a <prvAddCurrentTaskToDelayedList+0x9c>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1eae:	a0 91 31 01 	lds	r26, 0x0131
    1eb2:	b0 91 32 01 	lds	r27, 0x0132
    1eb6:	e0 91 d2 00 	lds	r30, 0x00D2
    1eba:	f0 91 d3 00 	lds	r31, 0x00D3
    1ebe:	b5 83       	std	Z+5, r27	; 0x05
    1ec0:	a4 83       	std	Z+4, r26	; 0x04
    1ec2:	e0 91 d2 00 	lds	r30, 0x00D2
    1ec6:	f0 91 d3 00 	lds	r31, 0x00D3
    1eca:	14 96       	adiw	r26, 0x04	; 4
    1ecc:	8d 91       	ld	r24, X+
    1ece:	9c 91       	ld	r25, X
    1ed0:	15 97       	sbiw	r26, 0x05	; 5
    1ed2:	97 83       	std	Z+7, r25	; 0x07
    1ed4:	86 83       	std	Z+6, r24	; 0x06
    1ed6:	80 91 d2 00 	lds	r24, 0x00D2
    1eda:	90 91 d3 00 	lds	r25, 0x00D3
    1ede:	14 96       	adiw	r26, 0x04	; 4
    1ee0:	ed 91       	ld	r30, X+
    1ee2:	fc 91       	ld	r31, X
    1ee4:	15 97       	sbiw	r26, 0x05	; 5
    1ee6:	02 96       	adiw	r24, 0x02	; 2
    1ee8:	93 83       	std	Z+3, r25	; 0x03
    1eea:	82 83       	std	Z+2, r24	; 0x02
    1eec:	80 91 d2 00 	lds	r24, 0x00D2
    1ef0:	90 91 d3 00 	lds	r25, 0x00D3
    1ef4:	02 96       	adiw	r24, 0x02	; 2
    1ef6:	15 96       	adiw	r26, 0x05	; 5
    1ef8:	9c 93       	st	X, r25
    1efa:	8e 93       	st	-X, r24
    1efc:	14 97       	sbiw	r26, 0x04	; 4
    1efe:	e0 91 d2 00 	lds	r30, 0x00D2
    1f02:	f0 91 d3 00 	lds	r31, 0x00D3
    1f06:	80 e3       	ldi	r24, 0x30	; 48
    1f08:	91 e0       	ldi	r25, 0x01	; 1
    1f0a:	93 87       	std	Z+11, r25	; 0x0b
    1f0c:	82 87       	std	Z+10, r24	; 0x0a
    1f0e:	80 91 30 01 	lds	r24, 0x0130
    1f12:	8f 5f       	subi	r24, 0xFF	; 255
    1f14:	80 93 30 01 	sts	0x0130, r24
    1f18:	2f c0       	rjmp	.+94     	; 0x1f78 <prvAddCurrentTaskToDelayedList+0xfa>
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
    1f1a:	c0 0f       	add	r28, r16
    1f1c:	d1 1f       	adc	r29, r17

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1f1e:	e0 91 d2 00 	lds	r30, 0x00D2
    1f22:	f0 91 d3 00 	lds	r31, 0x00D3
    1f26:	d3 83       	std	Z+3, r29	; 0x03
    1f28:	c2 83       	std	Z+2, r28	; 0x02

                if( xTimeToWake < xConstTickCount )
    1f2a:	c0 17       	cp	r28, r16
    1f2c:	d1 07       	cpc	r29, r17
    1f2e:	68 f4       	brcc	.+26     	; 0x1f4a <prvAddCurrentTaskToDelayedList+0xcc>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1f30:	80 91 1c 01 	lds	r24, 0x011C
    1f34:	90 91 1d 01 	lds	r25, 0x011D
    1f38:	60 91 d2 00 	lds	r22, 0x00D2
    1f3c:	70 91 d3 00 	lds	r23, 0x00D3
    1f40:	6e 5f       	subi	r22, 0xFE	; 254
    1f42:	7f 4f       	sbci	r23, 0xFF	; 255
    1f44:	0e 94 42 02 	call	0x484	; 0x484 <vListInsert>
    1f48:	17 c0       	rjmp	.+46     	; 0x1f78 <prvAddCurrentTaskToDelayedList+0xfa>
                }
                else
                {
                    /* The wake time has not overflowed, so the current block list
                     * is used. */
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1f4a:	80 91 1a 01 	lds	r24, 0x011A
    1f4e:	90 91 1b 01 	lds	r25, 0x011B
    1f52:	60 91 d2 00 	lds	r22, 0x00D2
    1f56:	70 91 d3 00 	lds	r23, 0x00D3
    1f5a:	6e 5f       	subi	r22, 0xFE	; 254
    1f5c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f5e:	0e 94 42 02 	call	0x484	; 0x484 <vListInsert>

                    /* If the task entering the blocked state was placed at the
                     * head of the list of blocked tasks then xNextTaskUnblockTime
                     * needs to be updated too. */
                    if( xTimeToWake < xNextTaskUnblockTime )
    1f62:	80 91 d9 00 	lds	r24, 0x00D9
    1f66:	90 91 da 00 	lds	r25, 0x00DA
    1f6a:	c8 17       	cp	r28, r24
    1f6c:	d9 07       	cpc	r29, r25
    1f6e:	20 f4       	brcc	.+8      	; 0x1f78 <prvAddCurrentTaskToDelayedList+0xfa>
                    {
                        xNextTaskUnblockTime = xTimeToWake;
    1f70:	d0 93 da 00 	sts	0x00DA, r29
    1f74:	c0 93 d9 00 	sts	0x00D9, r28

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    1f78:	df 91       	pop	r29
    1f7a:	cf 91       	pop	r28
    1f7c:	1f 91       	pop	r17
    1f7e:	0f 91       	pop	r16
    1f80:	ff 90       	pop	r15
    1f82:	08 95       	ret

00001f84 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    1f84:	8f 92       	push	r8
    1f86:	9f 92       	push	r9
    1f88:	af 92       	push	r10
    1f8a:	bf 92       	push	r11
    1f8c:	cf 92       	push	r12
    1f8e:	df 92       	push	r13
    1f90:	ef 92       	push	r14
    1f92:	ff 92       	push	r15
    1f94:	0f 93       	push	r16
    1f96:	1f 93       	push	r17
    1f98:	cf 93       	push	r28
    1f9a:	df 93       	push	r29
    1f9c:	48 01       	movw	r8, r16
    1f9e:	59 01       	movw	r10, r18
    1fa0:	e7 01       	movw	r28, r14
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    1fa2:	0f b6       	in	r0, 0x3f	; 63
    1fa4:	f8 94       	cli
    1fa6:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    1fa8:	e0 91 d2 00 	lds	r30, 0x00D2
    1fac:	f0 91 d3 00 	lds	r31, 0x00D3
    1fb0:	e8 2e       	mov	r14, r24
    1fb2:	ff 24       	eor	r15, r15
    1fb4:	ee 0d       	add	r30, r14
    1fb6:	ff 1d       	adc	r31, r15
    1fb8:	85 a1       	ldd	r24, Z+37	; 0x25
    1fba:	82 30       	cpi	r24, 0x02	; 2
    1fbc:	61 f1       	breq	.+88     	; 0x2016 <xTaskGenericNotifyWait+0x92>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    1fbe:	e0 91 d2 00 	lds	r30, 0x00D2
    1fc2:	f0 91 d3 00 	lds	r31, 0x00D3
    1fc6:	c7 01       	movw	r24, r14
    1fc8:	88 0f       	add	r24, r24
    1fca:	99 1f       	adc	r25, r25
    1fcc:	88 0f       	add	r24, r24
    1fce:	99 1f       	adc	r25, r25
    1fd0:	e8 0f       	add	r30, r24
    1fd2:	f9 1f       	adc	r31, r25
    1fd4:	81 a1       	ldd	r24, Z+33	; 0x21
    1fd6:	92 a1       	ldd	r25, Z+34	; 0x22
    1fd8:	a3 a1       	ldd	r26, Z+35	; 0x23
    1fda:	b4 a1       	ldd	r27, Z+36	; 0x24
    1fdc:	40 95       	com	r20
    1fde:	50 95       	com	r21
    1fe0:	60 95       	com	r22
    1fe2:	70 95       	com	r23
    1fe4:	84 23       	and	r24, r20
    1fe6:	95 23       	and	r25, r21
    1fe8:	a6 23       	and	r26, r22
    1fea:	b7 23       	and	r27, r23
    1fec:	81 a3       	std	Z+33, r24	; 0x21
    1fee:	92 a3       	std	Z+34, r25	; 0x22
    1ff0:	a3 a3       	std	Z+35, r26	; 0x23
    1ff2:	b4 a3       	std	Z+36, r27	; 0x24

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    1ff4:	e0 91 d2 00 	lds	r30, 0x00D2
    1ff8:	f0 91 d3 00 	lds	r31, 0x00D3
    1ffc:	ee 0d       	add	r30, r14
    1ffe:	ff 1d       	adc	r31, r15
    2000:	81 e0       	ldi	r24, 0x01	; 1
    2002:	85 a3       	std	Z+37, r24	; 0x25

                if( xTicksToWait > ( TickType_t ) 0 )
    2004:	c1 14       	cp	r12, r1
    2006:	d1 04       	cpc	r13, r1
    2008:	31 f0       	breq	.+12     	; 0x2016 <xTaskGenericNotifyWait+0x92>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    200a:	c6 01       	movw	r24, r12
    200c:	61 e0       	ldi	r22, 0x01	; 1
    200e:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    2012:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2016:	0f 90       	pop	r0
    2018:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    201a:	0f b6       	in	r0, 0x3f	; 63
    201c:	f8 94       	cli
    201e:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    2020:	20 97       	sbiw	r28, 0x00	; 0
    2022:	99 f0       	breq	.+38     	; 0x204a <xTaskGenericNotifyWait+0xc6>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    2024:	e0 91 d2 00 	lds	r30, 0x00D2
    2028:	f0 91 d3 00 	lds	r31, 0x00D3
    202c:	c7 01       	movw	r24, r14
    202e:	88 0f       	add	r24, r24
    2030:	99 1f       	adc	r25, r25
    2032:	88 0f       	add	r24, r24
    2034:	99 1f       	adc	r25, r25
    2036:	e8 0f       	add	r30, r24
    2038:	f9 1f       	adc	r31, r25
    203a:	81 a1       	ldd	r24, Z+33	; 0x21
    203c:	92 a1       	ldd	r25, Z+34	; 0x22
    203e:	a3 a1       	ldd	r26, Z+35	; 0x23
    2040:	b4 a1       	ldd	r27, Z+36	; 0x24
    2042:	88 83       	st	Y, r24
    2044:	99 83       	std	Y+1, r25	; 0x01
    2046:	aa 83       	std	Y+2, r26	; 0x02
    2048:	bb 83       	std	Y+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    204a:	e0 91 d2 00 	lds	r30, 0x00D2
    204e:	f0 91 d3 00 	lds	r31, 0x00D3
    2052:	ee 0d       	add	r30, r14
    2054:	ff 1d       	adc	r31, r15
    2056:	85 a1       	ldd	r24, Z+37	; 0x25
    2058:	82 30       	cpi	r24, 0x02	; 2
    205a:	11 f0       	breq	.+4      	; 0x2060 <xTaskGenericNotifyWait+0xdc>
    205c:	80 e0       	ldi	r24, 0x00	; 0
    205e:	1c c0       	rjmp	.+56     	; 0x2098 <xTaskGenericNotifyWait+0x114>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    2060:	e0 91 d2 00 	lds	r30, 0x00D2
    2064:	f0 91 d3 00 	lds	r31, 0x00D3
    2068:	c7 01       	movw	r24, r14
    206a:	88 0f       	add	r24, r24
    206c:	99 1f       	adc	r25, r25
    206e:	88 0f       	add	r24, r24
    2070:	99 1f       	adc	r25, r25
    2072:	e8 0f       	add	r30, r24
    2074:	f9 1f       	adc	r31, r25
    2076:	81 a1       	ldd	r24, Z+33	; 0x21
    2078:	92 a1       	ldd	r25, Z+34	; 0x22
    207a:	a3 a1       	ldd	r26, Z+35	; 0x23
    207c:	b4 a1       	ldd	r27, Z+36	; 0x24
    207e:	80 94       	com	r8
    2080:	90 94       	com	r9
    2082:	a0 94       	com	r10
    2084:	b0 94       	com	r11
    2086:	88 21       	and	r24, r8
    2088:	99 21       	and	r25, r9
    208a:	aa 21       	and	r26, r10
    208c:	bb 21       	and	r27, r11
    208e:	81 a3       	std	Z+33, r24	; 0x21
    2090:	92 a3       	std	Z+34, r25	; 0x22
    2092:	a3 a3       	std	Z+35, r26	; 0x23
    2094:	b4 a3       	std	Z+36, r27	; 0x24
    2096:	81 e0       	ldi	r24, 0x01	; 1
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    2098:	e0 91 d2 00 	lds	r30, 0x00D2
    209c:	f0 91 d3 00 	lds	r31, 0x00D3
    20a0:	ee 0d       	add	r30, r14
    20a2:	ff 1d       	adc	r31, r15
    20a4:	15 a2       	std	Z+37, r1	; 0x25
        }
        taskEXIT_CRITICAL();
    20a6:	0f 90       	pop	r0
    20a8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    20aa:	df 91       	pop	r29
    20ac:	cf 91       	pop	r28
    20ae:	1f 91       	pop	r17
    20b0:	0f 91       	pop	r16
    20b2:	ff 90       	pop	r15
    20b4:	ef 90       	pop	r14
    20b6:	df 90       	pop	r13
    20b8:	cf 90       	pop	r12
    20ba:	bf 90       	pop	r11
    20bc:	af 90       	pop	r10
    20be:	9f 90       	pop	r9
    20c0:	8f 90       	pop	r8
    20c2:	08 95       	ret

000020c4 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    20c4:	1f 93       	push	r17
    20c6:	cf 93       	push	r28
    20c8:	df 93       	push	r29
    20ca:	16 2f       	mov	r17, r22
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    20cc:	0f b6       	in	r0, 0x3f	; 63
    20ce:	f8 94       	cli
    20d0:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    20d2:	e0 91 d2 00 	lds	r30, 0x00D2
    20d6:	f0 91 d3 00 	lds	r31, 0x00D3
    20da:	c8 2f       	mov	r28, r24
    20dc:	d0 e0       	ldi	r29, 0x00	; 0
    20de:	ce 01       	movw	r24, r28
    20e0:	88 0f       	add	r24, r24
    20e2:	99 1f       	adc	r25, r25
    20e4:	88 0f       	add	r24, r24
    20e6:	99 1f       	adc	r25, r25
    20e8:	e8 0f       	add	r30, r24
    20ea:	f9 1f       	adc	r31, r25
    20ec:	81 a1       	ldd	r24, Z+33	; 0x21
    20ee:	92 a1       	ldd	r25, Z+34	; 0x22
    20f0:	a3 a1       	ldd	r26, Z+35	; 0x23
    20f2:	b4 a1       	ldd	r27, Z+36	; 0x24
    20f4:	00 97       	sbiw	r24, 0x00	; 0
    20f6:	a1 05       	cpc	r26, r1
    20f8:	b1 05       	cpc	r27, r1
    20fa:	89 f4       	brne	.+34     	; 0x211e <ulTaskGenericNotifyTake+0x5a>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    20fc:	e0 91 d2 00 	lds	r30, 0x00D2
    2100:	f0 91 d3 00 	lds	r31, 0x00D3
    2104:	ec 0f       	add	r30, r28
    2106:	fd 1f       	adc	r31, r29
    2108:	81 e0       	ldi	r24, 0x01	; 1
    210a:	85 a3       	std	Z+37, r24	; 0x25

                if( xTicksToWait > ( TickType_t ) 0 )
    210c:	41 15       	cp	r20, r1
    210e:	51 05       	cpc	r21, r1
    2110:	31 f0       	breq	.+12     	; 0x211e <ulTaskGenericNotifyTake+0x5a>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2112:	ca 01       	movw	r24, r20
    2114:	61 e0       	ldi	r22, 0x01	; 1
    2116:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    211a:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    211e:	0f 90       	pop	r0
    2120:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	f8 94       	cli
    2126:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    2128:	e0 91 d2 00 	lds	r30, 0x00D2
    212c:	f0 91 d3 00 	lds	r31, 0x00D3
    2130:	ce 01       	movw	r24, r28
    2132:	88 0f       	add	r24, r24
    2134:	99 1f       	adc	r25, r25
    2136:	88 0f       	add	r24, r24
    2138:	99 1f       	adc	r25, r25
    213a:	e8 0f       	add	r30, r24
    213c:	f9 1f       	adc	r31, r25
    213e:	21 a1       	ldd	r18, Z+33	; 0x21
    2140:	32 a1       	ldd	r19, Z+34	; 0x22
    2142:	43 a1       	ldd	r20, Z+35	; 0x23
    2144:	54 a1       	ldd	r21, Z+36	; 0x24

            if( ulReturn != 0UL )
    2146:	21 15       	cp	r18, r1
    2148:	31 05       	cpc	r19, r1
    214a:	41 05       	cpc	r20, r1
    214c:	51 05       	cpc	r21, r1
    214e:	f9 f0       	breq	.+62     	; 0x218e <ulTaskGenericNotifyTake+0xca>
            {
                if( xClearCountOnExit != pdFALSE )
    2150:	11 23       	and	r17, r17
    2152:	59 f0       	breq	.+22     	; 0x216a <ulTaskGenericNotifyTake+0xa6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    2154:	e0 91 d2 00 	lds	r30, 0x00D2
    2158:	f0 91 d3 00 	lds	r31, 0x00D3
    215c:	e8 0f       	add	r30, r24
    215e:	f9 1f       	adc	r31, r25
    2160:	11 a2       	std	Z+33, r1	; 0x21
    2162:	12 a2       	std	Z+34, r1	; 0x22
    2164:	13 a2       	std	Z+35, r1	; 0x23
    2166:	14 a2       	std	Z+36, r1	; 0x24
    2168:	12 c0       	rjmp	.+36     	; 0x218e <ulTaskGenericNotifyTake+0xca>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    216a:	e0 91 d2 00 	lds	r30, 0x00D2
    216e:	f0 91 d3 00 	lds	r31, 0x00D3
    2172:	21 50       	subi	r18, 0x01	; 1
    2174:	30 40       	sbci	r19, 0x00	; 0
    2176:	40 40       	sbci	r20, 0x00	; 0
    2178:	50 40       	sbci	r21, 0x00	; 0
    217a:	e8 0f       	add	r30, r24
    217c:	f9 1f       	adc	r31, r25
    217e:	21 a3       	std	Z+33, r18	; 0x21
    2180:	32 a3       	std	Z+34, r19	; 0x22
    2182:	43 a3       	std	Z+35, r20	; 0x23
    2184:	54 a3       	std	Z+36, r21	; 0x24
    2186:	2f 5f       	subi	r18, 0xFF	; 255
    2188:	3f 4f       	sbci	r19, 0xFF	; 255
    218a:	4f 4f       	sbci	r20, 0xFF	; 255
    218c:	5f 4f       	sbci	r21, 0xFF	; 255
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    218e:	e0 91 d2 00 	lds	r30, 0x00D2
    2192:	f0 91 d3 00 	lds	r31, 0x00D3
    2196:	ec 0f       	add	r30, r28
    2198:	fd 1f       	adc	r31, r29
    219a:	15 a2       	std	Z+37, r1	; 0x25
        }
        taskEXIT_CRITICAL();
    219c:	0f 90       	pop	r0
    219e:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    21a0:	b9 01       	movw	r22, r18
    21a2:	ca 01       	movw	r24, r20
    21a4:	df 91       	pop	r29
    21a6:	cf 91       	pop	r28
    21a8:	1f 91       	pop	r17
    21aa:	08 95       	ret

000021ac <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    21ac:	0f 93       	push	r16
    21ae:	1f 93       	push	r17
    21b0:	8c 01       	movw	r16, r24
    21b2:	ca 01       	movw	r24, r20
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    21b4:	e0 91 d2 00 	lds	r30, 0x00D2
    21b8:	f0 91 d3 00 	lds	r31, 0x00D3
    21bc:	70 68       	ori	r23, 0x80	; 128
    21be:	75 87       	std	Z+13, r23	; 0x0d
    21c0:	64 87       	std	Z+12, r22	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    21c2:	f8 01       	movw	r30, r16
    21c4:	a1 81       	ldd	r26, Z+1	; 0x01
    21c6:	b2 81       	ldd	r27, Z+2	; 0x02
    21c8:	e0 91 d2 00 	lds	r30, 0x00D2
    21cc:	f0 91 d3 00 	lds	r31, 0x00D3
    21d0:	b7 87       	std	Z+15, r27	; 0x0f
    21d2:	a6 87       	std	Z+14, r26	; 0x0e
    21d4:	e0 91 d2 00 	lds	r30, 0x00D2
    21d8:	f0 91 d3 00 	lds	r31, 0x00D3
    21dc:	14 96       	adiw	r26, 0x04	; 4
    21de:	2d 91       	ld	r18, X+
    21e0:	3c 91       	ld	r19, X
    21e2:	15 97       	sbiw	r26, 0x05	; 5
    21e4:	31 8b       	std	Z+17, r19	; 0x11
    21e6:	20 8b       	std	Z+16, r18	; 0x10
    21e8:	20 91 d2 00 	lds	r18, 0x00D2
    21ec:	30 91 d3 00 	lds	r19, 0x00D3
    21f0:	14 96       	adiw	r26, 0x04	; 4
    21f2:	ed 91       	ld	r30, X+
    21f4:	fc 91       	ld	r31, X
    21f6:	15 97       	sbiw	r26, 0x05	; 5
    21f8:	24 5f       	subi	r18, 0xF4	; 244
    21fa:	3f 4f       	sbci	r19, 0xFF	; 255
    21fc:	33 83       	std	Z+3, r19	; 0x03
    21fe:	22 83       	std	Z+2, r18	; 0x02
    2200:	20 91 d2 00 	lds	r18, 0x00D2
    2204:	30 91 d3 00 	lds	r19, 0x00D3
    2208:	24 5f       	subi	r18, 0xF4	; 244
    220a:	3f 4f       	sbci	r19, 0xFF	; 255
    220c:	15 96       	adiw	r26, 0x05	; 5
    220e:	3c 93       	st	X, r19
    2210:	2e 93       	st	-X, r18
    2212:	14 97       	sbiw	r26, 0x04	; 4
    2214:	e0 91 d2 00 	lds	r30, 0x00D2
    2218:	f0 91 d3 00 	lds	r31, 0x00D3
    221c:	15 8b       	std	Z+21, r17	; 0x15
    221e:	04 8b       	std	Z+20, r16	; 0x14
    2220:	f8 01       	movw	r30, r16
    2222:	20 81       	ld	r18, Z
    2224:	2f 5f       	subi	r18, 0xFF	; 255
    2226:	20 83       	st	Z, r18

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2228:	61 e0       	ldi	r22, 0x01	; 1
    222a:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <prvAddCurrentTaskToDelayedList>
}
    222e:	1f 91       	pop	r17
    2230:	0f 91       	pop	r16
    2232:	08 95       	ret

00002234 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    2234:	9c 01       	movw	r18, r24
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    2236:	00 97       	sbiw	r24, 0x00	; 0
    2238:	69 f0       	breq	.+26     	; 0x2254 <vTaskDelay+0x20>
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    223a:	80 91 d4 00 	lds	r24, 0x00D4
    223e:	8f 5f       	subi	r24, 0xFF	; 255
    2240:	80 93 d4 00 	sts	0x00D4, r24
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2244:	c9 01       	movw	r24, r18
    2246:	60 e0       	ldi	r22, 0x00	; 0
    2248:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    224c:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    2250:	88 23       	and	r24, r24
    2252:	11 f4       	brne	.+4      	; 0x2258 <vTaskDelay+0x24>
        {
            portYIELD_WITHIN_API();
    2254:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    2258:	08 95       	ret

0000225a <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    225a:	1f 93       	push	r17
    225c:	fc 01       	movw	r30, r24
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    225e:	80 91 d4 00 	lds	r24, 0x00D4
    2262:	8f 5f       	subi	r24, 0xFF	; 255
    2264:	80 93 d4 00 	sts	0x00D4, r24

        vTaskSuspendAll();
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    2268:	80 91 d7 00 	lds	r24, 0x00D7
    226c:	90 91 d8 00 	lds	r25, 0x00D8

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2270:	20 81       	ld	r18, Z
    2272:	31 81       	ldd	r19, Z+1	; 0x01
    2274:	62 0f       	add	r22, r18
    2276:	73 1f       	adc	r23, r19

            if( xConstTickCount < *pxPreviousWakeTime )
    2278:	82 17       	cp	r24, r18
    227a:	93 07       	cpc	r25, r19
    227c:	28 f4       	brcc	.+10     	; 0x2288 <xTaskDelayUntil+0x2e>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    227e:	62 17       	cp	r22, r18
    2280:	73 07       	cpc	r23, r19
    2282:	28 f0       	brcs	.+10     	; 0x228e <xTaskDelayUntil+0x34>
    2284:	10 e0       	ldi	r17, 0x00	; 0
    2286:	08 c0       	rjmp	.+16     	; 0x2298 <xTaskDelayUntil+0x3e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2288:	62 17       	cp	r22, r18
    228a:	73 07       	cpc	r23, r19
    228c:	20 f0       	brcs	.+8      	; 0x2296 <xTaskDelayUntil+0x3c>
    228e:	10 e0       	ldi	r17, 0x00	; 0
    2290:	86 17       	cp	r24, r22
    2292:	97 07       	cpc	r25, r23
    2294:	08 f4       	brcc	.+2      	; 0x2298 <xTaskDelayUntil+0x3e>
    2296:	11 e0       	ldi	r17, 0x01	; 1
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    2298:	71 83       	std	Z+1, r23	; 0x01
    229a:	60 83       	st	Z, r22

            if( xShouldDelay != pdFALSE )
    229c:	11 23       	and	r17, r17
    229e:	39 f0       	breq	.+14     	; 0x22ae <xTaskDelayUntil+0x54>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    22a0:	9b 01       	movw	r18, r22
    22a2:	28 1b       	sub	r18, r24
    22a4:	39 0b       	sbc	r19, r25
    22a6:	c9 01       	movw	r24, r18
    22a8:	60 e0       	ldi	r22, 0x00	; 0
    22aa:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    22ae:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    22b2:	88 23       	and	r24, r24
    22b4:	11 f4       	brne	.+4      	; 0x22ba <xTaskDelayUntil+0x60>
        {
            portYIELD_WITHIN_API();
    22b6:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    }
    22ba:	81 2f       	mov	r24, r17
    22bc:	1f 91       	pop	r17
    22be:	08 95       	ret

000022c0 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    22c0:	0f 93       	push	r16
    22c2:	1f 93       	push	r17
    22c4:	8b 01       	movw	r16, r22
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    22c6:	60 91 d2 00 	lds	r22, 0x00D2
    22ca:	70 91 d3 00 	lds	r23, 0x00D3
    22ce:	64 5f       	subi	r22, 0xF4	; 244
    22d0:	7f 4f       	sbci	r23, 0xFF	; 255
    22d2:	0e 94 42 02 	call	0x484	; 0x484 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    22d6:	c8 01       	movw	r24, r16
    22d8:	61 e0       	ldi	r22, 0x01	; 1
    22da:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <prvAddCurrentTaskToDelayedList>
}
    22de:	1f 91       	pop	r17
    22e0:	0f 91       	pop	r16
    22e2:	08 95       	ret

000022e4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    22e4:	80 91 d4 00 	lds	r24, 0x00D4
    22e8:	88 23       	and	r24, r24
    22ea:	21 f0       	breq	.+8      	; 0x22f4 <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    22ec:	81 e0       	ldi	r24, 0x01	; 1
    22ee:	80 93 d6 00 	sts	0x00D6, r24
    22f2:	08 95       	ret
    }
    else
    {
        xYieldPending = pdFALSE;
    22f4:	10 92 d6 00 	sts	0x00D6, r1
                ulTaskSwitchedInTime = ulTotalRunTime;
            }
        #endif /* configGENERATE_RUN_TIME_STATS */

        /* Check for stack overflow, if configured. */
        taskCHECK_FOR_STACK_OVERFLOW();
    22f8:	e0 91 d2 00 	lds	r30, 0x00D2
    22fc:	f0 91 d3 00 	lds	r31, 0x00D3
    2300:	a0 91 d2 00 	lds	r26, 0x00D2
    2304:	b0 91 d3 00 	lds	r27, 0x00D3
    2308:	20 81       	ld	r18, Z
    230a:	31 81       	ldd	r19, Z+1	; 0x01
    230c:	57 96       	adiw	r26, 0x17	; 23
    230e:	8d 91       	ld	r24, X+
    2310:	9c 91       	ld	r25, X
    2312:	58 97       	sbiw	r26, 0x18	; 24
    2314:	82 17       	cp	r24, r18
    2316:	93 07       	cpc	r25, r19
    2318:	60 f0       	brcs	.+24     	; 0x2332 <vTaskSwitchContext+0x4e>
    231a:	80 91 d2 00 	lds	r24, 0x00D2
    231e:	90 91 d3 00 	lds	r25, 0x00D3
    2322:	60 91 d2 00 	lds	r22, 0x00D2
    2326:	70 91 d3 00 	lds	r23, 0x00D3
    232a:	67 5e       	subi	r22, 0xE7	; 231
    232c:	7f 4f       	sbci	r23, 0xFF	; 255
    232e:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <vApplicationStackOverflowHook>
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2332:	20 91 d5 00 	lds	r18, 0x00D5
    2336:	99 e0       	ldi	r25, 0x09	; 9
    2338:	01 c0       	rjmp	.+2      	; 0x233c <vTaskSwitchContext+0x58>
    233a:	21 50       	subi	r18, 0x01	; 1
    233c:	29 9f       	mul	r18, r25
    233e:	d0 01       	movw	r26, r0
    2340:	11 24       	eor	r1, r1
    2342:	ac 51       	subi	r26, 0x1C	; 28
    2344:	bf 4f       	sbci	r27, 0xFF	; 255
    2346:	8c 91       	ld	r24, X
    2348:	88 23       	and	r24, r24
    234a:	b9 f3       	breq	.-18     	; 0x233a <vTaskSwitchContext+0x56>
    234c:	11 96       	adiw	r26, 0x01	; 1
    234e:	ed 91       	ld	r30, X+
    2350:	fc 91       	ld	r31, X
    2352:	12 97       	sbiw	r26, 0x02	; 2
    2354:	02 80       	ldd	r0, Z+2	; 0x02
    2356:	f3 81       	ldd	r31, Z+3	; 0x03
    2358:	e0 2d       	mov	r30, r0
    235a:	12 96       	adiw	r26, 0x02	; 2
    235c:	fc 93       	st	X, r31
    235e:	ee 93       	st	-X, r30
    2360:	11 97       	sbiw	r26, 0x01	; 1
    2362:	cd 01       	movw	r24, r26
    2364:	03 96       	adiw	r24, 0x03	; 3
    2366:	e8 17       	cp	r30, r24
    2368:	f9 07       	cpc	r31, r25
    236a:	31 f4       	brne	.+12     	; 0x2378 <vTaskSwitchContext+0x94>
    236c:	82 81       	ldd	r24, Z+2	; 0x02
    236e:	93 81       	ldd	r25, Z+3	; 0x03
    2370:	12 96       	adiw	r26, 0x02	; 2
    2372:	9c 93       	st	X, r25
    2374:	8e 93       	st	-X, r24
    2376:	11 97       	sbiw	r26, 0x01	; 1
    2378:	11 96       	adiw	r26, 0x01	; 1
    237a:	ed 91       	ld	r30, X+
    237c:	fc 91       	ld	r31, X
    237e:	12 97       	sbiw	r26, 0x02	; 2
    2380:	86 81       	ldd	r24, Z+6	; 0x06
    2382:	97 81       	ldd	r25, Z+7	; 0x07
    2384:	90 93 d3 00 	sts	0x00D3, r25
    2388:	80 93 d2 00 	sts	0x00D2, r24
    238c:	20 93 d5 00 	sts	0x00D5, r18
    2390:	08 95       	ret

00002392 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    2392:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    2394:	10 92 df 00 	sts	0x00DF, r1
    vPortEndScheduler();
    2398:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <vPortEndScheduler>
}
    239c:	08 95       	ret

0000239e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    239e:	0f 93       	push	r16
    23a0:	1f 93       	push	r17
    23a2:	21 c0       	rjmp	.+66     	; 0x23e6 <prvIdleTask+0x48>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    23a4:	0f b6       	in	r0, 0x3f	; 63
    23a6:	f8 94       	cli
    23a8:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    23aa:	e0 91 2c 01 	lds	r30, 0x012C
    23ae:	f0 91 2d 01 	lds	r31, 0x012D
    23b2:	06 81       	ldd	r16, Z+6	; 0x06
    23b4:	17 81       	ldd	r17, Z+7	; 0x07
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    23b6:	c8 01       	movw	r24, r16
    23b8:	02 96       	adiw	r24, 0x02	; 2
    23ba:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    23be:	80 91 de 00 	lds	r24, 0x00DE
    23c2:	81 50       	subi	r24, 0x01	; 1
    23c4:	80 93 de 00 	sts	0x00DE, r24
                    --uxDeletedTasksWaitingCleanUp;
    23c8:	80 91 e2 00 	lds	r24, 0x00E2
    23cc:	81 50       	subi	r24, 0x01	; 1
    23ce:	80 93 e2 00 	sts	0x00E2, r24
                }
                taskEXIT_CRITICAL();
    23d2:	0f 90       	pop	r0
    23d4:	0f be       	out	0x3f, r0	; 63

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    23d6:	f8 01       	movw	r30, r16
    23d8:	87 89       	ldd	r24, Z+23	; 0x17
    23da:	90 8d       	ldd	r25, Z+24	; 0x18
    23dc:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vPortFree>
                vPortFree( pxTCB );
    23e0:	c8 01       	movw	r24, r16
    23e2:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vPortFree>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    23e6:	80 91 e2 00 	lds	r24, 0x00E2
    23ea:	88 23       	and	r24, r24
    23ec:	d9 f6       	brne	.-74     	; 0x23a4 <prvIdleTask+0x6>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    23ee:	80 91 e4 00 	lds	r24, 0x00E4
    23f2:	82 30       	cpi	r24, 0x02	; 2
    23f4:	c0 f3       	brcs	.-16     	; 0x23e6 <prvIdleTask+0x48>
                {
                    taskYIELD();
    23f6:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    23fa:	f5 cf       	rjmp	.-22     	; 0x23e6 <prvIdleTask+0x48>

000023fc <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
    23fc:	ff 92       	push	r15
    23fe:	0f 93       	push	r16
    2400:	1f 93       	push	r17
    2402:	cf 93       	push	r28
    2404:	df 93       	push	r29
    2406:	ec 01       	movw	r28, r24

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    2408:	8a 85       	ldd	r24, Y+10	; 0x0a
    240a:	9b 85       	ldd	r25, Y+11	; 0x0b
    240c:	80 53       	subi	r24, 0x30	; 48
    240e:	91 40       	sbci	r25, 0x01	; 1
    2410:	09 f0       	breq	.+2      	; 0x2414 <xTaskResumeFromISR+0x18>
    2412:	5a c0       	rjmp	.+180    	; 0x24c8 <xTaskResumeFromISR+0xcc>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    2414:	8c 89       	ldd	r24, Y+20	; 0x14
    2416:	9d 89       	ldd	r25, Y+21	; 0x15
    2418:	21 e0       	ldi	r18, 0x01	; 1
    241a:	8e 31       	cpi	r24, 0x1E	; 30
    241c:	92 07       	cpc	r25, r18
    241e:	09 f4       	brne	.+2      	; 0x2422 <xTaskResumeFromISR+0x26>
    2420:	53 c0       	rjmp	.+166    	; 0x24c8 <xTaskResumeFromISR+0xcc>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    2422:	89 2b       	or	r24, r25
    2424:	09 f0       	breq	.+2      	; 0x2428 <xTaskResumeFromISR+0x2c>
    2426:	50 c0       	rjmp	.+160    	; 0x24c8 <xTaskResumeFromISR+0xcc>
    2428:	57 c0       	rjmp	.+174    	; 0x24d8 <xTaskResumeFromISR+0xdc>
                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    242a:	e0 91 d2 00 	lds	r30, 0x00D2
    242e:	f0 91 d3 00 	lds	r31, 0x00D3
    2432:	9e 89       	ldd	r25, Y+22	; 0x16
    2434:	86 89       	ldd	r24, Z+22	; 0x16
    2436:	98 17       	cp	r25, r24
    2438:	10 f4       	brcc	.+4      	; 0x243e <xTaskResumeFromISR+0x42>
    243a:	ff 24       	eor	r15, r15
    243c:	05 c0       	rjmp	.+10     	; 0x2448 <xTaskResumeFromISR+0x4c>
                        xYieldRequired = pdTRUE;

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
    243e:	81 e0       	ldi	r24, 0x01	; 1
    2440:	80 93 d6 00 	sts	0x00D6, r24
    2444:	ff 24       	eor	r15, r15
    2446:	f3 94       	inc	r15
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2448:	8e 01       	movw	r16, r28
    244a:	0e 5f       	subi	r16, 0xFE	; 254
    244c:	1f 4f       	sbci	r17, 0xFF	; 255
    244e:	c8 01       	movw	r24, r16
    2450:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    2454:	9e 89       	ldd	r25, Y+22	; 0x16
    2456:	80 91 d5 00 	lds	r24, 0x00D5
    245a:	89 17       	cp	r24, r25
    245c:	10 f4       	brcc	.+4      	; 0x2462 <xTaskResumeFromISR+0x66>
    245e:	90 93 d5 00 	sts	0x00D5, r25
    2462:	89 2f       	mov	r24, r25
    2464:	90 e0       	ldi	r25, 0x00	; 0
    2466:	fc 01       	movw	r30, r24
    2468:	33 e0       	ldi	r19, 0x03	; 3
    246a:	ee 0f       	add	r30, r30
    246c:	ff 1f       	adc	r31, r31
    246e:	3a 95       	dec	r19
    2470:	e1 f7       	brne	.-8      	; 0x246a <xTaskResumeFromISR+0x6e>
    2472:	e8 0f       	add	r30, r24
    2474:	f9 1f       	adc	r31, r25
    2476:	ec 51       	subi	r30, 0x1C	; 28
    2478:	ff 4f       	sbci	r31, 0xFF	; 255
    247a:	a1 81       	ldd	r26, Z+1	; 0x01
    247c:	b2 81       	ldd	r27, Z+2	; 0x02
    247e:	bd 83       	std	Y+5, r27	; 0x05
    2480:	ac 83       	std	Y+4, r26	; 0x04
    2482:	14 96       	adiw	r26, 0x04	; 4
    2484:	8d 91       	ld	r24, X+
    2486:	9c 91       	ld	r25, X
    2488:	15 97       	sbiw	r26, 0x05	; 5
    248a:	9f 83       	std	Y+7, r25	; 0x07
    248c:	8e 83       	std	Y+6, r24	; 0x06
    248e:	14 96       	adiw	r26, 0x04	; 4
    2490:	ed 91       	ld	r30, X+
    2492:	fc 91       	ld	r31, X
    2494:	15 97       	sbiw	r26, 0x05	; 5
    2496:	13 83       	std	Z+3, r17	; 0x03
    2498:	02 83       	std	Z+2, r16	; 0x02
    249a:	15 96       	adiw	r26, 0x05	; 5
    249c:	1c 93       	st	X, r17
    249e:	0e 93       	st	-X, r16
    24a0:	14 97       	sbiw	r26, 0x04	; 4
    24a2:	ee 89       	ldd	r30, Y+22	; 0x16
    24a4:	89 e0       	ldi	r24, 0x09	; 9
    24a6:	e8 9f       	mul	r30, r24
    24a8:	f0 01       	movw	r30, r0
    24aa:	11 24       	eor	r1, r1
    24ac:	ec 51       	subi	r30, 0x1C	; 28
    24ae:	ff 4f       	sbci	r31, 0xFF	; 255
    24b0:	fb 87       	std	Y+11, r31	; 0x0b
    24b2:	ea 87       	std	Y+10, r30	; 0x0a
    24b4:	80 81       	ld	r24, Z
    24b6:	8f 5f       	subi	r24, 0xFF	; 255
    24b8:	80 83       	st	Z, r24
    24ba:	07 c0       	rjmp	.+14     	; 0x24ca <xTaskResumeFromISR+0xce>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    24bc:	2c 96       	adiw	r28, 0x0c	; 12
    24be:	8e e1       	ldi	r24, 0x1E	; 30
    24c0:	91 e0       	ldi	r25, 0x01	; 1
    24c2:	be 01       	movw	r22, r28
    24c4:	0e 94 23 02 	call	0x446	; 0x446 <vListInsertEnd>
    24c8:	ff 24       	eor	r15, r15
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    }
    24ca:	8f 2d       	mov	r24, r15
    24cc:	df 91       	pop	r29
    24ce:	cf 91       	pop	r28
    24d0:	1f 91       	pop	r17
    24d2:	0f 91       	pop	r16
    24d4:	ff 90       	pop	r15
    24d6:	08 95       	ret
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    24d8:	80 91 d4 00 	lds	r24, 0x00D4
    24dc:	88 23       	and	r24, r24
    24de:	09 f4       	brne	.+2      	; 0x24e2 <xTaskResumeFromISR+0xe6>
    24e0:	a4 cf       	rjmp	.-184    	; 0x242a <xTaskResumeFromISR+0x2e>
    24e2:	ec cf       	rjmp	.-40     	; 0x24bc <xTaskResumeFromISR+0xc0>

000024e4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
    24e4:	0f 93       	push	r16
    24e6:	1f 93       	push	r17
    24e8:	cf 93       	push	r28
    24ea:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    24ec:	0f b6       	in	r0, 0x3f	; 63
    24ee:	f8 94       	cli
    24f0:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    24f2:	00 97       	sbiw	r24, 0x00	; 0
    24f4:	11 f0       	breq	.+4      	; 0x24fa <vTaskSuspend+0x16>
    24f6:	ec 01       	movw	r28, r24
    24f8:	04 c0       	rjmp	.+8      	; 0x2502 <vTaskSuspend+0x1e>
    24fa:	c0 91 d2 00 	lds	r28, 0x00D2
    24fe:	d0 91 d3 00 	lds	r29, 0x00D3

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2502:	8e 01       	movw	r16, r28
    2504:	0e 5f       	subi	r16, 0xFE	; 254
    2506:	1f 4f       	sbci	r17, 0xFF	; 255
    2508:	c8 01       	movw	r24, r16
    250a:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    250e:	8c 89       	ldd	r24, Y+20	; 0x14
    2510:	9d 89       	ldd	r25, Y+21	; 0x15
    2512:	89 2b       	or	r24, r25
    2514:	21 f0       	breq	.+8      	; 0x251e <vTaskSuspend+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2516:	ce 01       	movw	r24, r28
    2518:	0c 96       	adiw	r24, 0x0c	; 12
    251a:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    251e:	80 e3       	ldi	r24, 0x30	; 48
    2520:	91 e0       	ldi	r25, 0x01	; 1
    2522:	b8 01       	movw	r22, r16
    2524:	0e 94 23 02 	call	0x446	; 0x446 <vListInsertEnd>
                {
                    BaseType_t x;

                    for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
                    {
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
    2528:	8d a1       	ldd	r24, Y+37	; 0x25
    252a:	81 30       	cpi	r24, 0x01	; 1
    252c:	09 f4       	brne	.+2      	; 0x2530 <vTaskSuspend+0x4c>
                        {
                            /* The task was blocked to wait for a notification, but is
                             * now suspended, so no notification was received. */
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
    252e:	1d a2       	std	Y+37, r1	; 0x25
                        }
                    }
                }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
    2530:	0f 90       	pop	r0
    2532:	0f be       	out	0x3f, r0	; 63

        if( xSchedulerRunning != pdFALSE )
    2534:	80 91 df 00 	lds	r24, 0x00DF
    2538:	88 23       	and	r24, r24
    253a:	e1 f0       	breq	.+56     	; 0x2574 <vTaskSuspend+0x90>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
    253c:	0f b6       	in	r0, 0x3f	; 63
    253e:	f8 94       	cli
    2540:	0f 92       	push	r0
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2542:	e0 91 1a 01 	lds	r30, 0x011A
    2546:	f0 91 1b 01 	lds	r31, 0x011B
    254a:	80 81       	ld	r24, Z
    254c:	88 23       	and	r24, r24
    254e:	19 f4       	brne	.+6      	; 0x2556 <vTaskSuspend+0x72>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    2550:	8f ef       	ldi	r24, 0xFF	; 255
    2552:	9f ef       	ldi	r25, 0xFF	; 255
    2554:	09 c0       	rjmp	.+18     	; 0x2568 <vTaskSuspend+0x84>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    2556:	e0 91 1a 01 	lds	r30, 0x011A
    255a:	f0 91 1b 01 	lds	r31, 0x011B
    255e:	05 80       	ldd	r0, Z+5	; 0x05
    2560:	f6 81       	ldd	r31, Z+6	; 0x06
    2562:	e0 2d       	mov	r30, r0
    2564:	80 81       	ld	r24, Z
    2566:	91 81       	ldd	r25, Z+1	; 0x01
    2568:	90 93 da 00 	sts	0x00DA, r25
    256c:	80 93 d9 00 	sts	0x00D9, r24
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
            {
                prvResetNextTaskUnblockTime();
            }
            taskEXIT_CRITICAL();
    2570:	0f 90       	pop	r0
    2572:	0f be       	out	0x3f, r0	; 63
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
    2574:	80 91 d2 00 	lds	r24, 0x00D2
    2578:	90 91 d3 00 	lds	r25, 0x00D3
    257c:	c8 17       	cp	r28, r24
    257e:	d9 07       	cpc	r29, r25
    2580:	a1 f4       	brne	.+40     	; 0x25aa <vTaskSuspend+0xc6>
        {
            if( xSchedulerRunning != pdFALSE )
    2582:	80 91 df 00 	lds	r24, 0x00DF
    2586:	88 23       	and	r24, r24
    2588:	19 f0       	breq	.+6      	; 0x2590 <vTaskSuspend+0xac>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    258a:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    258e:	0d c0       	rjmp	.+26     	; 0x25aa <vTaskSuspend+0xc6>
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    2590:	90 91 30 01 	lds	r25, 0x0130
    2594:	80 91 de 00 	lds	r24, 0x00DE
    2598:	98 17       	cp	r25, r24
    259a:	29 f4       	brne	.+10     	; 0x25a6 <vTaskSuspend+0xc2>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
    259c:	10 92 d3 00 	sts	0x00D3, r1
    25a0:	10 92 d2 00 	sts	0x00D2, r1
    25a4:	02 c0       	rjmp	.+4      	; 0x25aa <vTaskSuspend+0xc6>
                }
                else
                {
                    vTaskSwitchContext();
    25a6:	0e 94 72 11 	call	0x22e4	; 0x22e4 <vTaskSwitchContext>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    25aa:	df 91       	pop	r29
    25ac:	cf 91       	pop	r28
    25ae:	1f 91       	pop	r17
    25b0:	0f 91       	pop	r16
    25b2:	08 95       	ret

000025b4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    25b4:	0f 93       	push	r16
    25b6:	1f 93       	push	r17
    25b8:	cf 93       	push	r28
    25ba:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    25bc:	0f b6       	in	r0, 0x3f	; 63
    25be:	f8 94       	cli
    25c0:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    25c2:	00 97       	sbiw	r24, 0x00	; 0
    25c4:	11 f0       	breq	.+4      	; 0x25ca <vTaskDelete+0x16>
    25c6:	ec 01       	movw	r28, r24
    25c8:	04 c0       	rjmp	.+8      	; 0x25d2 <vTaskDelete+0x1e>
    25ca:	c0 91 d2 00 	lds	r28, 0x00D2
    25ce:	d0 91 d3 00 	lds	r29, 0x00D3

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    25d2:	8e 01       	movw	r16, r28
    25d4:	0e 5f       	subi	r16, 0xFE	; 254
    25d6:	1f 4f       	sbci	r17, 0xFF	; 255
    25d8:	c8 01       	movw	r24, r16
    25da:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    25de:	8c 89       	ldd	r24, Y+20	; 0x14
    25e0:	9d 89       	ldd	r25, Y+21	; 0x15
    25e2:	89 2b       	or	r24, r25
    25e4:	21 f0       	breq	.+8      	; 0x25ee <vTaskDelete+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    25e6:	ce 01       	movw	r24, r28
    25e8:	0c 96       	adiw	r24, 0x0c	; 12
    25ea:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    25ee:	80 91 e3 00 	lds	r24, 0x00E3
    25f2:	8f 5f       	subi	r24, 0xFF	; 255
    25f4:	80 93 e3 00 	sts	0x00E3, r24

            if( pxTCB == pxCurrentTCB )
    25f8:	80 91 d2 00 	lds	r24, 0x00D2
    25fc:	90 91 d3 00 	lds	r25, 0x00D3
    2600:	c8 17       	cp	r28, r24
    2602:	d9 07       	cpc	r29, r25
    2604:	59 f4       	brne	.+22     	; 0x261c <vTaskDelete+0x68>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2606:	87 e2       	ldi	r24, 0x27	; 39
    2608:	91 e0       	ldi	r25, 0x01	; 1
    260a:	b8 01       	movw	r22, r16
    260c:	0e 94 23 02 	call	0x446	; 0x446 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    2610:	80 91 e2 00 	lds	r24, 0x00E2
    2614:	8f 5f       	subi	r24, 0xFF	; 255
    2616:	80 93 e2 00 	sts	0x00E2, r24
    261a:	1c c0       	rjmp	.+56     	; 0x2654 <vTaskDelete+0xa0>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    261c:	80 91 de 00 	lds	r24, 0x00DE
    2620:	81 50       	subi	r24, 0x01	; 1
    2622:	80 93 de 00 	sts	0x00DE, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2626:	e0 91 1a 01 	lds	r30, 0x011A
    262a:	f0 91 1b 01 	lds	r31, 0x011B
    262e:	80 81       	ld	r24, Z
    2630:	88 23       	and	r24, r24
    2632:	19 f4       	brne	.+6      	; 0x263a <vTaskDelete+0x86>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    2634:	8f ef       	ldi	r24, 0xFF	; 255
    2636:	9f ef       	ldi	r25, 0xFF	; 255
    2638:	09 c0       	rjmp	.+18     	; 0x264c <vTaskDelete+0x98>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    263a:	e0 91 1a 01 	lds	r30, 0x011A
    263e:	f0 91 1b 01 	lds	r31, 0x011B
    2642:	05 80       	ldd	r0, Z+5	; 0x05
    2644:	f6 81       	ldd	r31, Z+6	; 0x06
    2646:	e0 2d       	mov	r30, r0
    2648:	80 81       	ld	r24, Z
    264a:	91 81       	ldd	r25, Z+1	; 0x01
    264c:	90 93 da 00 	sts	0x00DA, r25
    2650:	80 93 d9 00 	sts	0x00D9, r24
                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
            }
        }
        taskEXIT_CRITICAL();
    2654:	0f 90       	pop	r0
    2656:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    2658:	80 91 d2 00 	lds	r24, 0x00D2
    265c:	90 91 d3 00 	lds	r25, 0x00D3
    2660:	c8 17       	cp	r28, r24
    2662:	d9 07       	cpc	r29, r25
    2664:	39 f0       	breq	.+14     	; 0x2674 <vTaskDelete+0xc0>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    2666:	8f 89       	ldd	r24, Y+23	; 0x17
    2668:	98 8d       	ldd	r25, Y+24	; 0x18
    266a:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vPortFree>
                vPortFree( pxTCB );
    266e:	ce 01       	movw	r24, r28
    2670:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vPortFree>
            prvDeleteTCB( pxTCB );
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    2674:	80 91 df 00 	lds	r24, 0x00DF
    2678:	88 23       	and	r24, r24
    267a:	49 f0       	breq	.+18     	; 0x268e <vTaskDelete+0xda>
        {
            if( pxTCB == pxCurrentTCB )
    267c:	80 91 d2 00 	lds	r24, 0x00D2
    2680:	90 91 d3 00 	lds	r25, 0x00D3
    2684:	c8 17       	cp	r28, r24
    2686:	d9 07       	cpc	r29, r25
    2688:	11 f4       	brne	.+4      	; 0x268e <vTaskDelete+0xda>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    268a:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    268e:	df 91       	pop	r29
    2690:	cf 91       	pop	r28
    2692:	1f 91       	pop	r17
    2694:	0f 91       	pop	r16
    2696:	08 95       	ret

00002698 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    2698:	4f 92       	push	r4
    269a:	5f 92       	push	r5
    269c:	6f 92       	push	r6
    269e:	7f 92       	push	r7
    26a0:	8f 92       	push	r8
    26a2:	9f 92       	push	r9
    26a4:	af 92       	push	r10
    26a6:	bf 92       	push	r11
    26a8:	cf 92       	push	r12
    26aa:	df 92       	push	r13
    26ac:	ef 92       	push	r14
    26ae:	ff 92       	push	r15
    26b0:	0f 93       	push	r16
    26b2:	1f 93       	push	r17
    26b4:	cf 93       	push	r28
    26b6:	df 93       	push	r29
    26b8:	2c 01       	movw	r4, r24
    26ba:	5b 01       	movw	r10, r22
    26bc:	6a 01       	movw	r12, r20
    26be:	39 01       	movw	r6, r18
    26c0:	47 01       	movw	r8, r14
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    26c2:	ca 01       	movw	r24, r20
    26c4:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <pvPortMalloc>
    26c8:	7c 01       	movw	r14, r24

                if( pxStack != NULL )
    26ca:	00 97       	sbiw	r24, 0x00	; 0
    26cc:	81 f0       	breq	.+32     	; 0x26ee <xTaskCreate+0x56>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    26ce:	86 e2       	ldi	r24, 0x26	; 38
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <pvPortMalloc>
    26d6:	ec 01       	movw	r28, r24

                    if( pxNewTCB != NULL )
    26d8:	00 97       	sbiw	r24, 0x00	; 0
    26da:	31 f0       	breq	.+12     	; 0x26e8 <xTaskCreate+0x50>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    26dc:	f8 8e       	std	Y+24, r15	; 0x18
    26de:	ef 8a       	std	Y+23, r14	; 0x17
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    26e0:	a1 14       	cp	r10, r1
    26e2:	b1 04       	cpc	r11, r1
    26e4:	31 f4       	brne	.+12     	; 0x26f2 <xTaskCreate+0x5a>
    26e6:	16 c0       	rjmp	.+44     	; 0x2714 <xTaskCreate+0x7c>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    26e8:	c7 01       	movw	r24, r14
    26ea:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vPortFree>
    26ee:	8f ef       	ldi	r24, 0xFF	; 255
    26f0:	e4 c0       	rjmp	.+456    	; 0x28ba <xTaskCreate+0x222>
    26f2:	f5 01       	movw	r30, r10
    26f4:	dc 01       	movw	r26, r24
    26f6:	90 e0       	ldi	r25, 0x00	; 0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    26f8:	80 81       	ld	r24, Z
    26fa:	59 96       	adiw	r26, 0x19	; 25
    26fc:	8c 93       	st	X, r24
    26fe:	59 97       	sbiw	r26, 0x19	; 25

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    2700:	80 81       	ld	r24, Z
    2702:	88 23       	and	r24, r24
    2704:	29 f0       	breq	.+10     	; 0x2710 <xTaskCreate+0x78>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2706:	9f 5f       	subi	r25, 0xFF	; 255
    2708:	31 96       	adiw	r30, 0x01	; 1
    270a:	11 96       	adiw	r26, 0x01	; 1
    270c:	98 30       	cpi	r25, 0x08	; 8
    270e:	a1 f7       	brne	.-24     	; 0x26f8 <xTaskCreate+0x60>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2710:	18 a2       	std	Y+32, r1	; 0x20
    2712:	01 c0       	rjmp	.+2      	; 0x2716 <xTaskCreate+0x7e>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2714:	19 8e       	std	Y+25, r1	; 0x19
    2716:	04 30       	cpi	r16, 0x04	; 4
    2718:	08 f0       	brcs	.+2      	; 0x271c <xTaskCreate+0x84>
    271a:	03 e0       	ldi	r16, 0x03	; 3
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    271c:	0e 8b       	std	Y+22, r16	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    271e:	62 e0       	ldi	r22, 0x02	; 2
    2720:	a6 2e       	mov	r10, r22
    2722:	b1 2c       	mov	r11, r1
    2724:	ac 0e       	add	r10, r28
    2726:	bd 1e       	adc	r11, r29
    2728:	c5 01       	movw	r24, r10
    272a:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    272e:	ce 01       	movw	r24, r28
    2730:	0c 96       	adiw	r24, 0x0c	; 12
    2732:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2736:	d9 87       	std	Y+9, r29	; 0x09
    2738:	c8 87       	std	Y+8, r28	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    273a:	84 e0       	ldi	r24, 0x04	; 4
    273c:	90 e0       	ldi	r25, 0x00	; 0
    273e:	80 1b       	sub	r24, r16
    2740:	91 09       	sbc	r25, r1
    2742:	9d 87       	std	Y+13, r25	; 0x0d
    2744:	8c 87       	std	Y+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2746:	db 8b       	std	Y+19, r29	; 0x13
    2748:	ca 8b       	std	Y+18, r28	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    274a:	19 a2       	std	Y+33, r1	; 0x21
    274c:	1a a2       	std	Y+34, r1	; 0x22
    274e:	1b a2       	std	Y+35, r1	; 0x23
    2750:	1c a2       	std	Y+36, r1	; 0x24
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    2752:	1d a2       	std	Y+37, r1	; 0x25
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2754:	08 94       	sec
    2756:	c1 08       	sbc	r12, r1
    2758:	d1 08       	sbc	r13, r1
    275a:	c7 01       	movw	r24, r14
    275c:	8c 0d       	add	r24, r12
    275e:	9d 1d       	adc	r25, r13
    2760:	b2 01       	movw	r22, r4
    2762:	a3 01       	movw	r20, r6
    2764:	0e 94 98 14 	call	0x2930	; 0x2930 <pxPortInitialiseStack>
    2768:	99 83       	std	Y+1, r25	; 0x01
    276a:	88 83       	st	Y, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    276c:	81 14       	cp	r8, r1
    276e:	91 04       	cpc	r9, r1
    2770:	19 f0       	breq	.+6      	; 0x2778 <xTaskCreate+0xe0>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2772:	f4 01       	movw	r30, r8
    2774:	d1 83       	std	Z+1, r29	; 0x01
    2776:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    2778:	0f b6       	in	r0, 0x3f	; 63
    277a:	f8 94       	cli
    277c:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    277e:	80 91 de 00 	lds	r24, 0x00DE
    2782:	8f 5f       	subi	r24, 0xFF	; 255
    2784:	80 93 de 00 	sts	0x00DE, r24

        if( pxCurrentTCB == NULL )
    2788:	80 91 d2 00 	lds	r24, 0x00D2
    278c:	90 91 d3 00 	lds	r25, 0x00D3
    2790:	89 2b       	or	r24, r25
    2792:	d1 f5       	brne	.+116    	; 0x2808 <xTaskCreate+0x170>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    2794:	d0 93 d3 00 	sts	0x00D3, r29
    2798:	c0 93 d2 00 	sts	0x00D2, r28

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    279c:	80 91 de 00 	lds	r24, 0x00DE
    27a0:	81 30       	cpi	r24, 0x01	; 1
    27a2:	09 f0       	breq	.+2      	; 0x27a6 <xTaskCreate+0x10e>
    27a4:	41 c0       	rjmp	.+130    	; 0x2828 <xTaskCreate+0x190>
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    27a6:	84 ee       	ldi	r24, 0xE4	; 228
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
    27ae:	8d ee       	ldi	r24, 0xED	; 237
    27b0:	90 e0       	ldi	r25, 0x00	; 0
    27b2:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
    27b6:	86 ef       	ldi	r24, 0xF6	; 246
    27b8:	90 e0       	ldi	r25, 0x00	; 0
    27ba:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
    27be:	8f ef       	ldi	r24, 0xFF	; 255
    27c0:	90 e0       	ldi	r25, 0x00	; 0
    27c2:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
    }

    vListInitialise( &xDelayedTaskList1 );
    27c6:	58 e0       	ldi	r21, 0x08	; 8
    27c8:	e5 2e       	mov	r14, r21
    27ca:	51 e0       	ldi	r21, 0x01	; 1
    27cc:	f5 2e       	mov	r15, r21
    27ce:	c7 01       	movw	r24, r14
    27d0:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    27d4:	01 e1       	ldi	r16, 0x11	; 17
    27d6:	11 e0       	ldi	r17, 0x01	; 1
    27d8:	c8 01       	movw	r24, r16
    27da:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
    vListInitialise( &xPendingReadyList );
    27de:	8e e1       	ldi	r24, 0x1E	; 30
    27e0:	91 e0       	ldi	r25, 0x01	; 1
    27e2:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    27e6:	87 e2       	ldi	r24, 0x27	; 39
    27e8:	91 e0       	ldi	r25, 0x01	; 1
    27ea:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
        }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            vListInitialise( &xSuspendedTaskList );
    27ee:	80 e3       	ldi	r24, 0x30	; 48
    27f0:	91 e0       	ldi	r25, 0x01	; 1
    27f2:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    27f6:	f0 92 1b 01 	sts	0x011B, r15
    27fa:	e0 92 1a 01 	sts	0x011A, r14
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    27fe:	10 93 1d 01 	sts	0x011D, r17
    2802:	00 93 1c 01 	sts	0x011C, r16
    2806:	10 c0       	rjmp	.+32     	; 0x2828 <xTaskCreate+0x190>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    2808:	80 91 df 00 	lds	r24, 0x00DF
    280c:	88 23       	and	r24, r24
    280e:	61 f4       	brne	.+24     	; 0x2828 <xTaskCreate+0x190>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2810:	e0 91 d2 00 	lds	r30, 0x00D2
    2814:	f0 91 d3 00 	lds	r31, 0x00D3
    2818:	96 89       	ldd	r25, Z+22	; 0x16
    281a:	8e 89       	ldd	r24, Y+22	; 0x16
    281c:	89 17       	cp	r24, r25
    281e:	20 f0       	brcs	.+8      	; 0x2828 <xTaskCreate+0x190>
                {
                    pxCurrentTCB = pxNewTCB;
    2820:	d0 93 d3 00 	sts	0x00D3, r29
    2824:	c0 93 d2 00 	sts	0x00D2, r28
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    2828:	80 91 e3 00 	lds	r24, 0x00E3
    282c:	8f 5f       	subi	r24, 0xFF	; 255
    282e:	80 93 e3 00 	sts	0x00E3, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    2832:	9e 89       	ldd	r25, Y+22	; 0x16
    2834:	80 91 d5 00 	lds	r24, 0x00D5
    2838:	89 17       	cp	r24, r25
    283a:	10 f4       	brcc	.+4      	; 0x2840 <xTaskCreate+0x1a8>
    283c:	90 93 d5 00 	sts	0x00D5, r25
    2840:	8e 89       	ldd	r24, Y+22	; 0x16
    2842:	90 e0       	ldi	r25, 0x00	; 0
    2844:	fc 01       	movw	r30, r24
    2846:	43 e0       	ldi	r20, 0x03	; 3
    2848:	ee 0f       	add	r30, r30
    284a:	ff 1f       	adc	r31, r31
    284c:	4a 95       	dec	r20
    284e:	e1 f7       	brne	.-8      	; 0x2848 <xTaskCreate+0x1b0>
    2850:	e8 0f       	add	r30, r24
    2852:	f9 1f       	adc	r31, r25
    2854:	ec 51       	subi	r30, 0x1C	; 28
    2856:	ff 4f       	sbci	r31, 0xFF	; 255
    2858:	a1 81       	ldd	r26, Z+1	; 0x01
    285a:	b2 81       	ldd	r27, Z+2	; 0x02
    285c:	bd 83       	std	Y+5, r27	; 0x05
    285e:	ac 83       	std	Y+4, r26	; 0x04
    2860:	14 96       	adiw	r26, 0x04	; 4
    2862:	8d 91       	ld	r24, X+
    2864:	9c 91       	ld	r25, X
    2866:	15 97       	sbiw	r26, 0x05	; 5
    2868:	9f 83       	std	Y+7, r25	; 0x07
    286a:	8e 83       	std	Y+6, r24	; 0x06
    286c:	14 96       	adiw	r26, 0x04	; 4
    286e:	ed 91       	ld	r30, X+
    2870:	fc 91       	ld	r31, X
    2872:	15 97       	sbiw	r26, 0x05	; 5
    2874:	b3 82       	std	Z+3, r11	; 0x03
    2876:	a2 82       	std	Z+2, r10	; 0x02
    2878:	15 96       	adiw	r26, 0x05	; 5
    287a:	bc 92       	st	X, r11
    287c:	ae 92       	st	-X, r10
    287e:	14 97       	sbiw	r26, 0x04	; 4
    2880:	ee 89       	ldd	r30, Y+22	; 0x16
    2882:	89 e0       	ldi	r24, 0x09	; 9
    2884:	e8 9f       	mul	r30, r24
    2886:	f0 01       	movw	r30, r0
    2888:	11 24       	eor	r1, r1
    288a:	ec 51       	subi	r30, 0x1C	; 28
    288c:	ff 4f       	sbci	r31, 0xFF	; 255
    288e:	fb 87       	std	Y+11, r31	; 0x0b
    2890:	ea 87       	std	Y+10, r30	; 0x0a
    2892:	80 81       	ld	r24, Z
    2894:	8f 5f       	subi	r24, 0xFF	; 255
    2896:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    2898:	0f 90       	pop	r0
    289a:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    289c:	80 91 df 00 	lds	r24, 0x00DF
    28a0:	88 23       	and	r24, r24
    28a2:	51 f0       	breq	.+20     	; 0x28b8 <xTaskCreate+0x220>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    28a4:	e0 91 d2 00 	lds	r30, 0x00D2
    28a8:	f0 91 d3 00 	lds	r31, 0x00D3
    28ac:	96 89       	ldd	r25, Z+22	; 0x16
    28ae:	8e 89       	ldd	r24, Y+22	; 0x16
    28b0:	98 17       	cp	r25, r24
    28b2:	10 f4       	brcc	.+4      	; 0x28b8 <xTaskCreate+0x220>
        {
            taskYIELD_IF_USING_PREEMPTION();
    28b4:	0e 94 76 15 	call	0x2aec	; 0x2aec <vPortYield>
    28b8:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    28ba:	df 91       	pop	r29
    28bc:	cf 91       	pop	r28
    28be:	1f 91       	pop	r17
    28c0:	0f 91       	pop	r16
    28c2:	ff 90       	pop	r15
    28c4:	ef 90       	pop	r14
    28c6:	df 90       	pop	r13
    28c8:	cf 90       	pop	r12
    28ca:	bf 90       	pop	r11
    28cc:	af 90       	pop	r10
    28ce:	9f 90       	pop	r9
    28d0:	8f 90       	pop	r8
    28d2:	7f 90       	pop	r7
    28d4:	6f 90       	pop	r6
    28d6:	5f 90       	pop	r5
    28d8:	4f 90       	pop	r4
    28da:	08 95       	ret

000028dc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    28dc:	ef 92       	push	r14
    28de:	ff 92       	push	r15
    28e0:	0f 93       	push	r16
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    28e2:	8f ec       	ldi	r24, 0xCF	; 207
    28e4:	91 e1       	ldi	r25, 0x11	; 17
    28e6:	60 e6       	ldi	r22, 0x60	; 96
    28e8:	70 e0       	ldi	r23, 0x00	; 0
    28ea:	45 e5       	ldi	r20, 0x55	; 85
    28ec:	50 e0       	ldi	r21, 0x00	; 0
    28ee:	20 e0       	ldi	r18, 0x00	; 0
    28f0:	30 e0       	ldi	r19, 0x00	; 0
    28f2:	00 e0       	ldi	r16, 0x00	; 0
    28f4:	e0 ee       	ldi	r30, 0xE0	; 224
    28f6:	ee 2e       	mov	r14, r30
    28f8:	e0 e0       	ldi	r30, 0x00	; 0
    28fa:	fe 2e       	mov	r15, r30
    28fc:	0e 94 4c 13 	call	0x2698	; 0x2698 <xTaskCreate>
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    2900:	81 30       	cpi	r24, 0x01	; 1
    2902:	81 f4       	brne	.+32     	; 0x2924 <vTaskStartScheduler+0x48>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    2904:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    2906:	8f ef       	ldi	r24, 0xFF	; 255
    2908:	9f ef       	ldi	r25, 0xFF	; 255
    290a:	90 93 da 00 	sts	0x00DA, r25
    290e:	80 93 d9 00 	sts	0x00D9, r24
        xSchedulerRunning = pdTRUE;
    2912:	81 e0       	ldi	r24, 0x01	; 1
    2914:	80 93 df 00 	sts	0x00DF, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2918:	10 92 d8 00 	sts	0x00D8, r1
    291c:	10 92 d7 00 	sts	0x00D7, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    2920:	0e 94 e0 14 	call	0x29c0	; 0x29c0 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    2924:	80 91 72 00 	lds	r24, 0x0072
}
    2928:	0f 91       	pop	r16
    292a:	ff 90       	pop	r15
    292c:	ef 90       	pop	r14
    292e:	08 95       	ret

00002930 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2930:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2932:	91 e1       	ldi	r25, 0x11	; 17
    2934:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2936:	22 e2       	ldi	r18, 0x22	; 34
    2938:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    293a:	83 e3       	ldi	r24, 0x33	; 51
    293c:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    293e:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2940:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2942:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2944:	80 e8       	ldi	r24, 0x80	; 128
    2946:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    2948:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    294a:	82 e0       	ldi	r24, 0x02	; 2
    294c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    294e:	83 e0       	ldi	r24, 0x03	; 3
    2950:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2952:	84 e0       	ldi	r24, 0x04	; 4
    2954:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2956:	85 e0       	ldi	r24, 0x05	; 5
    2958:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    295a:	86 e0       	ldi	r24, 0x06	; 6
    295c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    295e:	87 e0       	ldi	r24, 0x07	; 7
    2960:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2962:	88 e0       	ldi	r24, 0x08	; 8
    2964:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2966:	89 e0       	ldi	r24, 0x09	; 9
    2968:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    296a:	80 e1       	ldi	r24, 0x10	; 16
    296c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    296e:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2970:	82 e1       	ldi	r24, 0x12	; 18
    2972:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    2974:	83 e1       	ldi	r24, 0x13	; 19
    2976:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2978:	84 e1       	ldi	r24, 0x14	; 20
    297a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    297c:	85 e1       	ldi	r24, 0x15	; 21
    297e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2980:	86 e1       	ldi	r24, 0x16	; 22
    2982:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2984:	87 e1       	ldi	r24, 0x17	; 23
    2986:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2988:	88 e1       	ldi	r24, 0x18	; 24
    298a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    298c:	89 e1       	ldi	r24, 0x19	; 25
    298e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2990:	80 e2       	ldi	r24, 0x20	; 32
    2992:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2994:	81 e2       	ldi	r24, 0x21	; 33
    2996:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2998:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    299a:	83 e2       	ldi	r24, 0x23	; 35
    299c:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    299e:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    29a0:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    29a2:	86 e2       	ldi	r24, 0x26	; 38
    29a4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    29a6:	87 e2       	ldi	r24, 0x27	; 39
    29a8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    29aa:	88 e2       	ldi	r24, 0x28	; 40
    29ac:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    29ae:	89 e2       	ldi	r24, 0x29	; 41
    29b0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    29b2:	80 e3       	ldi	r24, 0x30	; 48
    29b4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    29b6:	81 e3       	ldi	r24, 0x31	; 49
    29b8:	82 93       	st	-Z, r24
    29ba:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    29bc:	cf 01       	movw	r24, r30
    29be:	08 95       	ret

000029c0 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    29c0:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    29c2:	8c e7       	ldi	r24, 0x7C	; 124
    29c4:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    29c6:	8b e0       	ldi	r24, 0x0B	; 11
    29c8:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    29ca:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    29cc:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    29ce:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    29d0:	a0 91 d2 00 	lds	r26, 0x00D2
    29d4:	b0 91 d3 00 	lds	r27, 0x00D3
    29d8:	cd 91       	ld	r28, X+
    29da:	cd bf       	out	0x3d, r28	; 61
    29dc:	dd 91       	ld	r29, X+
    29de:	de bf       	out	0x3e, r29	; 62
    29e0:	ff 91       	pop	r31
    29e2:	ef 91       	pop	r30
    29e4:	df 91       	pop	r29
    29e6:	cf 91       	pop	r28
    29e8:	bf 91       	pop	r27
    29ea:	af 91       	pop	r26
    29ec:	9f 91       	pop	r25
    29ee:	8f 91       	pop	r24
    29f0:	7f 91       	pop	r23
    29f2:	6f 91       	pop	r22
    29f4:	5f 91       	pop	r21
    29f6:	4f 91       	pop	r20
    29f8:	3f 91       	pop	r19
    29fa:	2f 91       	pop	r18
    29fc:	1f 91       	pop	r17
    29fe:	0f 91       	pop	r16
    2a00:	ff 90       	pop	r15
    2a02:	ef 90       	pop	r14
    2a04:	df 90       	pop	r13
    2a06:	cf 90       	pop	r12
    2a08:	bf 90       	pop	r11
    2a0a:	af 90       	pop	r10
    2a0c:	9f 90       	pop	r9
    2a0e:	8f 90       	pop	r8
    2a10:	7f 90       	pop	r7
    2a12:	6f 90       	pop	r6
    2a14:	5f 90       	pop	r5
    2a16:	4f 90       	pop	r4
    2a18:	3f 90       	pop	r3
    2a1a:	2f 90       	pop	r2
    2a1c:	1f 90       	pop	r1
    2a1e:	0f 90       	pop	r0
    2a20:	0f be       	out	0x3f, r0	; 63
    2a22:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2a24:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2a26:	81 e0       	ldi	r24, 0x01	; 1
    2a28:	08 95       	ret

00002a2a <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2a2a:	08 95       	ret

00002a2c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2a2c:	0f 92       	push	r0
    2a2e:	0f b6       	in	r0, 0x3f	; 63
    2a30:	f8 94       	cli
    2a32:	0f 92       	push	r0
    2a34:	1f 92       	push	r1
    2a36:	11 24       	eor	r1, r1
    2a38:	2f 92       	push	r2
    2a3a:	3f 92       	push	r3
    2a3c:	4f 92       	push	r4
    2a3e:	5f 92       	push	r5
    2a40:	6f 92       	push	r6
    2a42:	7f 92       	push	r7
    2a44:	8f 92       	push	r8
    2a46:	9f 92       	push	r9
    2a48:	af 92       	push	r10
    2a4a:	bf 92       	push	r11
    2a4c:	cf 92       	push	r12
    2a4e:	df 92       	push	r13
    2a50:	ef 92       	push	r14
    2a52:	ff 92       	push	r15
    2a54:	0f 93       	push	r16
    2a56:	1f 93       	push	r17
    2a58:	2f 93       	push	r18
    2a5a:	3f 93       	push	r19
    2a5c:	4f 93       	push	r20
    2a5e:	5f 93       	push	r21
    2a60:	6f 93       	push	r22
    2a62:	7f 93       	push	r23
    2a64:	8f 93       	push	r24
    2a66:	9f 93       	push	r25
    2a68:	af 93       	push	r26
    2a6a:	bf 93       	push	r27
    2a6c:	cf 93       	push	r28
    2a6e:	df 93       	push	r29
    2a70:	ef 93       	push	r30
    2a72:	ff 93       	push	r31
    2a74:	a0 91 d2 00 	lds	r26, 0x00D2
    2a78:	b0 91 d3 00 	lds	r27, 0x00D3
    2a7c:	0d b6       	in	r0, 0x3d	; 61
    2a7e:	0d 92       	st	X+, r0
    2a80:	0e b6       	in	r0, 0x3e	; 62
    2a82:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2a84:	0e 94 46 08 	call	0x108c	; 0x108c <xTaskIncrementTick>
    2a88:	88 23       	and	r24, r24
    2a8a:	11 f0       	breq	.+4      	; 0x2a90 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2a8c:	0e 94 72 11 	call	0x22e4	; 0x22e4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2a90:	a0 91 d2 00 	lds	r26, 0x00D2
    2a94:	b0 91 d3 00 	lds	r27, 0x00D3
    2a98:	cd 91       	ld	r28, X+
    2a9a:	cd bf       	out	0x3d, r28	; 61
    2a9c:	dd 91       	ld	r29, X+
    2a9e:	de bf       	out	0x3e, r29	; 62
    2aa0:	ff 91       	pop	r31
    2aa2:	ef 91       	pop	r30
    2aa4:	df 91       	pop	r29
    2aa6:	cf 91       	pop	r28
    2aa8:	bf 91       	pop	r27
    2aaa:	af 91       	pop	r26
    2aac:	9f 91       	pop	r25
    2aae:	8f 91       	pop	r24
    2ab0:	7f 91       	pop	r23
    2ab2:	6f 91       	pop	r22
    2ab4:	5f 91       	pop	r21
    2ab6:	4f 91       	pop	r20
    2ab8:	3f 91       	pop	r19
    2aba:	2f 91       	pop	r18
    2abc:	1f 91       	pop	r17
    2abe:	0f 91       	pop	r16
    2ac0:	ff 90       	pop	r15
    2ac2:	ef 90       	pop	r14
    2ac4:	df 90       	pop	r13
    2ac6:	cf 90       	pop	r12
    2ac8:	bf 90       	pop	r11
    2aca:	af 90       	pop	r10
    2acc:	9f 90       	pop	r9
    2ace:	8f 90       	pop	r8
    2ad0:	7f 90       	pop	r7
    2ad2:	6f 90       	pop	r6
    2ad4:	5f 90       	pop	r5
    2ad6:	4f 90       	pop	r4
    2ad8:	3f 90       	pop	r3
    2ada:	2f 90       	pop	r2
    2adc:	1f 90       	pop	r1
    2ade:	0f 90       	pop	r0
    2ae0:	0f be       	out	0x3f, r0	; 63
    2ae2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2ae4:	08 95       	ret

00002ae6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2ae6:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <vPortYieldFromTick>
		asm volatile ( "reti" );
    2aea:	18 95       	reti

00002aec <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2aec:	0f 92       	push	r0
    2aee:	0f b6       	in	r0, 0x3f	; 63
    2af0:	f8 94       	cli
    2af2:	0f 92       	push	r0
    2af4:	1f 92       	push	r1
    2af6:	11 24       	eor	r1, r1
    2af8:	2f 92       	push	r2
    2afa:	3f 92       	push	r3
    2afc:	4f 92       	push	r4
    2afe:	5f 92       	push	r5
    2b00:	6f 92       	push	r6
    2b02:	7f 92       	push	r7
    2b04:	8f 92       	push	r8
    2b06:	9f 92       	push	r9
    2b08:	af 92       	push	r10
    2b0a:	bf 92       	push	r11
    2b0c:	cf 92       	push	r12
    2b0e:	df 92       	push	r13
    2b10:	ef 92       	push	r14
    2b12:	ff 92       	push	r15
    2b14:	0f 93       	push	r16
    2b16:	1f 93       	push	r17
    2b18:	2f 93       	push	r18
    2b1a:	3f 93       	push	r19
    2b1c:	4f 93       	push	r20
    2b1e:	5f 93       	push	r21
    2b20:	6f 93       	push	r22
    2b22:	7f 93       	push	r23
    2b24:	8f 93       	push	r24
    2b26:	9f 93       	push	r25
    2b28:	af 93       	push	r26
    2b2a:	bf 93       	push	r27
    2b2c:	cf 93       	push	r28
    2b2e:	df 93       	push	r29
    2b30:	ef 93       	push	r30
    2b32:	ff 93       	push	r31
    2b34:	a0 91 d2 00 	lds	r26, 0x00D2
    2b38:	b0 91 d3 00 	lds	r27, 0x00D3
    2b3c:	0d b6       	in	r0, 0x3d	; 61
    2b3e:	0d 92       	st	X+, r0
    2b40:	0e b6       	in	r0, 0x3e	; 62
    2b42:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2b44:	0e 94 72 11 	call	0x22e4	; 0x22e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2b48:	a0 91 d2 00 	lds	r26, 0x00D2
    2b4c:	b0 91 d3 00 	lds	r27, 0x00D3
    2b50:	cd 91       	ld	r28, X+
    2b52:	cd bf       	out	0x3d, r28	; 61
    2b54:	dd 91       	ld	r29, X+
    2b56:	de bf       	out	0x3e, r29	; 62
    2b58:	ff 91       	pop	r31
    2b5a:	ef 91       	pop	r30
    2b5c:	df 91       	pop	r29
    2b5e:	cf 91       	pop	r28
    2b60:	bf 91       	pop	r27
    2b62:	af 91       	pop	r26
    2b64:	9f 91       	pop	r25
    2b66:	8f 91       	pop	r24
    2b68:	7f 91       	pop	r23
    2b6a:	6f 91       	pop	r22
    2b6c:	5f 91       	pop	r21
    2b6e:	4f 91       	pop	r20
    2b70:	3f 91       	pop	r19
    2b72:	2f 91       	pop	r18
    2b74:	1f 91       	pop	r17
    2b76:	0f 91       	pop	r16
    2b78:	ff 90       	pop	r15
    2b7a:	ef 90       	pop	r14
    2b7c:	df 90       	pop	r13
    2b7e:	cf 90       	pop	r12
    2b80:	bf 90       	pop	r11
    2b82:	af 90       	pop	r10
    2b84:	9f 90       	pop	r9
    2b86:	8f 90       	pop	r8
    2b88:	7f 90       	pop	r7
    2b8a:	6f 90       	pop	r6
    2b8c:	5f 90       	pop	r5
    2b8e:	4f 90       	pop	r4
    2b90:	3f 90       	pop	r3
    2b92:	2f 90       	pop	r2
    2b94:	1f 90       	pop	r1
    2b96:	0f 90       	pop	r0
    2b98:	0f be       	out	0x3f, r0	; 63
    2b9a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2b9c:	08 95       	ret

00002b9e <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    2b9e:	cf 93       	push	r28
    2ba0:	df 93       	push	r29
    2ba2:	ec 01       	movw	r28, r24
    if( pv )
    2ba4:	00 97       	sbiw	r24, 0x00	; 0
    2ba6:	39 f0       	breq	.+14     	; 0x2bb6 <vPortFree+0x18>
    {
        vTaskSuspendAll();
    2ba8:	0e 94 21 08 	call	0x1042	; 0x1042 <vTaskSuspendAll>
        {
            free( pv );
    2bac:	ce 01       	movw	r24, r28
    2bae:	0e 94 41 1c 	call	0x3882	; 0x3882 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    2bb2:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
    }
}
    2bb6:	df 91       	pop	r29
    2bb8:	cf 91       	pop	r28
    2bba:	08 95       	ret

00002bbc <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    2bbc:	0f 93       	push	r16
    2bbe:	1f 93       	push	r17
    2bc0:	8c 01       	movw	r16, r24
    void * pvReturn;

    vTaskSuspendAll();
    2bc2:	0e 94 21 08 	call	0x1042	; 0x1042 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    2bc6:	c8 01       	movw	r24, r16
    2bc8:	0e 94 94 1b 	call	0x3728	; 0x3728 <malloc>
    2bcc:	18 2f       	mov	r17, r24
    2bce:	09 2f       	mov	r16, r25
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    2bd0:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskResumeAll>
            }
        }
    #endif

    return pvReturn;
}
    2bd4:	81 2f       	mov	r24, r17
    2bd6:	90 2f       	mov	r25, r16
    2bd8:	1f 91       	pop	r17
    2bda:	0f 91       	pop	r16
    2bdc:	08 95       	ret

00002bde <Private_u8AccessPinDirection>:
#define PRIVATE_CONC(B7, B6, B5, B4, B3, B2, B1, B0)  PRIVATE_CONC_HELP(B7, B6, B5, B4, B3, B2, B1, B0)
#define PRIVATE_CONC_HELP(B7, B6, B5, B4, B3, B2, B1, B0) 0b##B7##B6##B5##B4##B3##B2##B1##B0
/**/


u8 Private_u8AccessPinDirection(  volatile u8* Copy_P_u8PORTX_REG, u8 Copy_u8PinId, u8 Copy_u8PinDirection ) {
    2bde:	dc 01       	movw	r26, r24
 	u8 Local_u8ErrorState = STD_TYPES_OK;

	switch (Copy_u8PinDirection) {
    2be0:	41 30       	cpi	r20, 0x01	; 1
    2be2:	31 f0       	breq	.+12     	; 0x2bf0 <Private_u8AccessPinDirection+0x12>
    2be4:	41 30       	cpi	r20, 0x01	; 1
    2be6:	80 f0       	brcs	.+32     	; 0x2c08 <Private_u8AccessPinDirection+0x2a>
    2be8:	42 30       	cpi	r20, 0x02	; 2
    2bea:	e1 f0       	breq	.+56     	; 0x2c24 <Private_u8AccessPinDirection+0x46>
    2bec:	80 e0       	ldi	r24, 0x00	; 0
    2bee:	08 95       	ret
	case DIO_u8_OUTPUT:
		SET_BIT(*(Copy_P_u8PORTX_REG-1), Copy_u8PinId);//DDRX
    2bf0:	fc 01       	movw	r30, r24
    2bf2:	22 91       	ld	r18, -Z
    2bf4:	81 e0       	ldi	r24, 0x01	; 1
    2bf6:	90 e0       	ldi	r25, 0x00	; 0
    2bf8:	02 c0       	rjmp	.+4      	; 0x2bfe <Private_u8AccessPinDirection+0x20>
    2bfa:	88 0f       	add	r24, r24
    2bfc:	99 1f       	adc	r25, r25
    2bfe:	6a 95       	dec	r22
    2c00:	e2 f7       	brpl	.-8      	; 0x2bfa <Private_u8AccessPinDirection+0x1c>
    2c02:	28 2b       	or	r18, r24
    2c04:	20 83       	st	Z, r18
    2c06:	0c c0       	rjmp	.+24     	; 0x2c20 <Private_u8AccessPinDirection+0x42>
		break;

	case DIO_u8_INPUT_FLOATING:
		CLR_BIT(*(Copy_P_u8PORTX_REG-1), Copy_u8PinId);//DDRX
    2c08:	fc 01       	movw	r30, r24
    2c0a:	22 91       	ld	r18, -Z
    2c0c:	81 e0       	ldi	r24, 0x01	; 1
    2c0e:	90 e0       	ldi	r25, 0x00	; 0
    2c10:	02 c0       	rjmp	.+4      	; 0x2c16 <Private_u8AccessPinDirection+0x38>
    2c12:	88 0f       	add	r24, r24
    2c14:	99 1f       	adc	r25, r25
    2c16:	6a 95       	dec	r22
    2c18:	e2 f7       	brpl	.-8      	; 0x2c12 <Private_u8AccessPinDirection+0x34>
    2c1a:	80 95       	com	r24
    2c1c:	82 23       	and	r24, r18
    2c1e:	80 83       	st	Z, r24
    2c20:	81 e0       	ldi	r24, 0x01	; 1
    2c22:	08 95       	ret
		break;

	case DIO_u8_INPUT_PULLUP:
		CLR_BIT(*(Copy_P_u8PORTX_REG-1), Copy_u8PinId);//DDRX
    2c24:	fc 01       	movw	r30, r24
    2c26:	32 91       	ld	r19, -Z
    2c28:	81 e0       	ldi	r24, 0x01	; 1
    2c2a:	90 e0       	ldi	r25, 0x00	; 0
    2c2c:	02 c0       	rjmp	.+4      	; 0x2c32 <Private_u8AccessPinDirection+0x54>
    2c2e:	88 0f       	add	r24, r24
    2c30:	99 1f       	adc	r25, r25
    2c32:	6a 95       	dec	r22
    2c34:	e2 f7       	brpl	.-8      	; 0x2c2e <Private_u8AccessPinDirection+0x50>
    2c36:	28 2f       	mov	r18, r24
    2c38:	20 95       	com	r18
    2c3a:	23 23       	and	r18, r19
    2c3c:	20 83       	st	Z, r18
		SET_BIT(*(Copy_P_u8PORTX_REG  ), Copy_u8PinId);//PORTX
    2c3e:	2c 91       	ld	r18, X
    2c40:	82 2b       	or	r24, r18
    2c42:	8c 93       	st	X, r24
    2c44:	81 e0       	ldi	r24, 0x01	; 1
		Local_u8ErrorState = STD_TYPES_NOK;

	}

	return Local_u8ErrorState;
}
    2c46:	08 95       	ret

00002c48 <Private_u8AccessPortDirection>:

u8 Private_u8AccessPortDirection( volatile u8* Copy_P_u8PORTX_REG, u8 Copy_u8PortDirection ) {
    2c48:	fc 01       	movw	r30, r24
 	u8 Local_u8ErrorState = STD_TYPES_OK;

	switch (Copy_u8PortDirection) {
    2c4a:	61 30       	cpi	r22, 0x01	; 1
    2c4c:	31 f0       	breq	.+12     	; 0x2c5a <Private_u8AccessPortDirection+0x12>
    2c4e:	61 30       	cpi	r22, 0x01	; 1
    2c50:	40 f0       	brcs	.+16     	; 0x2c62 <Private_u8AccessPortDirection+0x1a>
    2c52:	62 30       	cpi	r22, 0x02	; 2
    2c54:	51 f0       	breq	.+20     	; 0x2c6a <Private_u8AccessPortDirection+0x22>
    2c56:	80 e0       	ldi	r24, 0x00	; 0
    2c58:	08 95       	ret
	case DIO_u8_OUTPUT:
		*(Copy_P_u8PORTX_REG-1) = 0xff;//DDRX
    2c5a:	31 97       	sbiw	r30, 0x01	; 1
    2c5c:	8f ef       	ldi	r24, 0xFF	; 255
    2c5e:	80 83       	st	Z, r24
    2c60:	02 c0       	rjmp	.+4      	; 0x2c66 <Private_u8AccessPortDirection+0x1e>
		break;

	case DIO_u8_INPUT_FLOATING:
		*(Copy_P_u8PORTX_REG-1) = 0x00;//DDRX
    2c62:	31 97       	sbiw	r30, 0x01	; 1
    2c64:	10 82       	st	Z, r1
    2c66:	81 e0       	ldi	r24, 0x01	; 1
    2c68:	08 95       	ret
		break;

	case DIO_u8_INPUT_PULLUP:
		*(Copy_P_u8PORTX_REG-1) = 0x00;//DDRX
    2c6a:	12 92       	st	-Z, r1
    2c6c:	31 96       	adiw	r30, 0x01	; 1
		*(Copy_P_u8PORTX_REG  ) = 0xff;//PORTX
    2c6e:	8f ef       	ldi	r24, 0xFF	; 255
    2c70:	80 83       	st	Z, r24
    2c72:	81 e0       	ldi	r24, 0x01	; 1
		Local_u8ErrorState = STD_TYPES_NOK;

	}

	return Local_u8ErrorState;
}
    2c74:	08 95       	ret

00002c76 <DIO_Init>:
#include "DIO_config.h"

void DIO_Init(void) {

	//directions
	DIO_U8_DDRA_REG = PRIVATE_CONC(DIO_DDRA_7, DIO_DDRA_6, DIO_DDRA_5,
    2c76:	9f ef       	ldi	r25, 0xFF	; 255
    2c78:	9a bb       	out	0x1a, r25	; 26
			DIO_DDRA_4, DIO_DDRA_3, DIO_DDRA_2, DIO_DDRA_1, DIO_DDRA_0);

	DIO_U8_DDRB_REG = PRIVATE_CONC(DIO_DDRB_7, DIO_DDRB_6, DIO_DDRB_5,
    2c7a:	17 ba       	out	0x17, r1	; 23
			DIO_DDRB_4, DIO_DDRB_3, DIO_DDRB_2, DIO_DDRB_1, DIO_DDRB_0);

	DIO_U8_DDRC_REG = PRIVATE_CONC(DIO_DDRC_7, DIO_DDRC_6, DIO_DDRC_5,
    2c7c:	8f e0       	ldi	r24, 0x0F	; 15
    2c7e:	84 bb       	out	0x14, r24	; 20
			DIO_DDRC_4, DIO_DDRC_3, DIO_DDRC_2, DIO_DDRC_1, DIO_DDRC_0);

	DIO_U8_DDRD_REG = PRIVATE_CONC(DIO_DDRD_7, DIO_DDRD_6, DIO_DDRD_5,
    2c80:	8b ef       	ldi	r24, 0xFB	; 251
    2c82:	81 bb       	out	0x11, r24	; 17
			DIO_DDRD_4, DIO_DDRD_3, DIO_DDRD_2, DIO_DDRD_1, DIO_DDRD_0);

	//values
	DIO_U8_PORTA_REG = PRIVATE_CONC(DIO_PORTA_7, DIO_PORTA_6, DIO_PORTA_5,
    2c84:	1b ba       	out	0x1b, r1	; 27
			DIO_PORTA_4, DIO_PORTA_3, DIO_PORTA_2, DIO_PORTA_1, DIO_PORTA_0);

	DIO_U8_PORTB_REG = PRIVATE_CONC(DIO_PORTB_7, DIO_PORTB_6, DIO_PORTB_5,
    2c86:	87 ef       	ldi	r24, 0xF7	; 247
    2c88:	88 bb       	out	0x18, r24	; 24
			DIO_PORTB_4, DIO_PORTB_3, DIO_PORTB_2, DIO_PORTB_1, DIO_PORTB_0);

	DIO_U8_PORTC_REG = PRIVATE_CONC(DIO_PORTC_7, DIO_PORTC_6, DIO_PORTC_5,
    2c8a:	95 bb       	out	0x15, r25	; 21
			DIO_PORTC_4, DIO_PORTC_3, DIO_PORTC_2, DIO_PORTC_1, DIO_PORTC_0);

	DIO_U8_PORTD_REG = PRIVATE_CONC(DIO_PORTD_7, DIO_PORTD_6, DIO_PORTD_5,
    2c8c:	84 e0       	ldi	r24, 0x04	; 4
    2c8e:	82 bb       	out	0x12, r24	; 18
			DIO_PORTD_4, DIO_PORTD_3, DIO_PORTD_2, DIO_PORTD_1, DIO_PORTD_0);

}
    2c90:	08 95       	ret

00002c92 <DIO_u8SetPinValue>:
u8 DIO_u8SetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8PinValue) {
	u8 Local_u8ErrorState = STD_TYPES_OK;

	if (Copy_u8PortId <= DIO_u8_PORTD && Copy_u8PinId <= DIO_u8_PIN7
    2c92:	84 30       	cpi	r24, 0x04	; 4
    2c94:	08 f0       	brcs	.+2      	; 0x2c98 <DIO_u8SetPinValue+0x6>
    2c96:	75 c0       	rjmp	.+234    	; 0x2d82 <DIO_u8SetPinValue+0xf0>
    2c98:	68 30       	cpi	r22, 0x08	; 8
    2c9a:	08 f0       	brcs	.+2      	; 0x2c9e <DIO_u8SetPinValue+0xc>
    2c9c:	72 c0       	rjmp	.+228    	; 0x2d82 <DIO_u8SetPinValue+0xf0>
    2c9e:	42 30       	cpi	r20, 0x02	; 2
    2ca0:	08 f0       	brcs	.+2      	; 0x2ca4 <DIO_u8SetPinValue+0x12>
    2ca2:	6f c0       	rjmp	.+222    	; 0x2d82 <DIO_u8SetPinValue+0xf0>
			&& (Copy_u8PinValue == DIO_u8_LOW || Copy_u8PinValue == DIO_u8_HIGH)) {

		switch (Copy_u8PortId) {
    2ca4:	81 30       	cpi	r24, 0x01	; 1
    2ca6:	09 f1       	breq	.+66     	; 0x2cea <DIO_u8SetPinValue+0x58>
    2ca8:	81 30       	cpi	r24, 0x01	; 1
    2caa:	30 f0       	brcs	.+12     	; 0x2cb8 <DIO_u8SetPinValue+0x26>
    2cac:	82 30       	cpi	r24, 0x02	; 2
    2cae:	b1 f1       	breq	.+108    	; 0x2d1c <DIO_u8SetPinValue+0x8a>
    2cb0:	83 30       	cpi	r24, 0x03	; 3
    2cb2:	09 f0       	breq	.+2      	; 0x2cb6 <DIO_u8SetPinValue+0x24>
    2cb4:	64 c0       	rjmp	.+200    	; 0x2d7e <DIO_u8SetPinValue+0xec>
    2cb6:	4b c0       	rjmp	.+150    	; 0x2d4e <DIO_u8SetPinValue+0xbc>

		case DIO_u8_PORTA:

			if (Copy_u8PinValue) {
    2cb8:	44 23       	and	r20, r20
    2cba:	59 f0       	breq	.+22     	; 0x2cd2 <DIO_u8SetPinValue+0x40>
				SET_BIT(DIO_U8_PORTA_REG, Copy_u8PinId);
    2cbc:	2b b3       	in	r18, 0x1b	; 27
    2cbe:	81 e0       	ldi	r24, 0x01	; 1
    2cc0:	90 e0       	ldi	r25, 0x00	; 0
    2cc2:	02 c0       	rjmp	.+4      	; 0x2cc8 <DIO_u8SetPinValue+0x36>
    2cc4:	88 0f       	add	r24, r24
    2cc6:	99 1f       	adc	r25, r25
    2cc8:	6a 95       	dec	r22
    2cca:	e2 f7       	brpl	.-8      	; 0x2cc4 <DIO_u8SetPinValue+0x32>
    2ccc:	28 2b       	or	r18, r24
    2cce:	2b bb       	out	0x1b, r18	; 27
    2cd0:	56 c0       	rjmp	.+172    	; 0x2d7e <DIO_u8SetPinValue+0xec>
			} else {
				CLR_BIT(DIO_U8_PORTA_REG, Copy_u8PinId);
    2cd2:	2b b3       	in	r18, 0x1b	; 27
    2cd4:	81 e0       	ldi	r24, 0x01	; 1
    2cd6:	90 e0       	ldi	r25, 0x00	; 0
    2cd8:	02 c0       	rjmp	.+4      	; 0x2cde <DIO_u8SetPinValue+0x4c>
    2cda:	88 0f       	add	r24, r24
    2cdc:	99 1f       	adc	r25, r25
    2cde:	6a 95       	dec	r22
    2ce0:	e2 f7       	brpl	.-8      	; 0x2cda <DIO_u8SetPinValue+0x48>
    2ce2:	80 95       	com	r24
    2ce4:	82 23       	and	r24, r18
    2ce6:	8b bb       	out	0x1b, r24	; 27
    2ce8:	4a c0       	rjmp	.+148    	; 0x2d7e <DIO_u8SetPinValue+0xec>

			break;

		case DIO_u8_PORTB:

			if (Copy_u8PinValue) {
    2cea:	44 23       	and	r20, r20
    2cec:	59 f0       	breq	.+22     	; 0x2d04 <DIO_u8SetPinValue+0x72>
				SET_BIT(DIO_U8_PORTB_REG, Copy_u8PinId);
    2cee:	28 b3       	in	r18, 0x18	; 24
    2cf0:	81 e0       	ldi	r24, 0x01	; 1
    2cf2:	90 e0       	ldi	r25, 0x00	; 0
    2cf4:	02 c0       	rjmp	.+4      	; 0x2cfa <DIO_u8SetPinValue+0x68>
    2cf6:	88 0f       	add	r24, r24
    2cf8:	99 1f       	adc	r25, r25
    2cfa:	6a 95       	dec	r22
    2cfc:	e2 f7       	brpl	.-8      	; 0x2cf6 <DIO_u8SetPinValue+0x64>
    2cfe:	28 2b       	or	r18, r24
    2d00:	28 bb       	out	0x18, r18	; 24
    2d02:	3d c0       	rjmp	.+122    	; 0x2d7e <DIO_u8SetPinValue+0xec>
			} else {
				CLR_BIT(DIO_U8_PORTB_REG, Copy_u8PinId);
    2d04:	28 b3       	in	r18, 0x18	; 24
    2d06:	81 e0       	ldi	r24, 0x01	; 1
    2d08:	90 e0       	ldi	r25, 0x00	; 0
    2d0a:	02 c0       	rjmp	.+4      	; 0x2d10 <DIO_u8SetPinValue+0x7e>
    2d0c:	88 0f       	add	r24, r24
    2d0e:	99 1f       	adc	r25, r25
    2d10:	6a 95       	dec	r22
    2d12:	e2 f7       	brpl	.-8      	; 0x2d0c <DIO_u8SetPinValue+0x7a>
    2d14:	80 95       	com	r24
    2d16:	82 23       	and	r24, r18
    2d18:	88 bb       	out	0x18, r24	; 24
    2d1a:	31 c0       	rjmp	.+98     	; 0x2d7e <DIO_u8SetPinValue+0xec>

			break;

		case DIO_u8_PORTC:

			if (Copy_u8PinValue) {
    2d1c:	44 23       	and	r20, r20
    2d1e:	59 f0       	breq	.+22     	; 0x2d36 <DIO_u8SetPinValue+0xa4>
				SET_BIT(DIO_U8_PORTC_REG, Copy_u8PinId);
    2d20:	25 b3       	in	r18, 0x15	; 21
    2d22:	81 e0       	ldi	r24, 0x01	; 1
    2d24:	90 e0       	ldi	r25, 0x00	; 0
    2d26:	02 c0       	rjmp	.+4      	; 0x2d2c <DIO_u8SetPinValue+0x9a>
    2d28:	88 0f       	add	r24, r24
    2d2a:	99 1f       	adc	r25, r25
    2d2c:	6a 95       	dec	r22
    2d2e:	e2 f7       	brpl	.-8      	; 0x2d28 <DIO_u8SetPinValue+0x96>
    2d30:	28 2b       	or	r18, r24
    2d32:	25 bb       	out	0x15, r18	; 21
    2d34:	24 c0       	rjmp	.+72     	; 0x2d7e <DIO_u8SetPinValue+0xec>
			} else {
				CLR_BIT(DIO_U8_PORTC_REG, Copy_u8PinId);
    2d36:	25 b3       	in	r18, 0x15	; 21
    2d38:	81 e0       	ldi	r24, 0x01	; 1
    2d3a:	90 e0       	ldi	r25, 0x00	; 0
    2d3c:	02 c0       	rjmp	.+4      	; 0x2d42 <DIO_u8SetPinValue+0xb0>
    2d3e:	88 0f       	add	r24, r24
    2d40:	99 1f       	adc	r25, r25
    2d42:	6a 95       	dec	r22
    2d44:	e2 f7       	brpl	.-8      	; 0x2d3e <DIO_u8SetPinValue+0xac>
    2d46:	80 95       	com	r24
    2d48:	82 23       	and	r24, r18
    2d4a:	85 bb       	out	0x15, r24	; 21
    2d4c:	18 c0       	rjmp	.+48     	; 0x2d7e <DIO_u8SetPinValue+0xec>

			break;

		case DIO_u8_PORTD:

			if (Copy_u8PinValue) {
    2d4e:	44 23       	and	r20, r20
    2d50:	59 f0       	breq	.+22     	; 0x2d68 <DIO_u8SetPinValue+0xd6>
				SET_BIT(DIO_U8_PORTD_REG, Copy_u8PinId);
    2d52:	22 b3       	in	r18, 0x12	; 18
    2d54:	81 e0       	ldi	r24, 0x01	; 1
    2d56:	90 e0       	ldi	r25, 0x00	; 0
    2d58:	02 c0       	rjmp	.+4      	; 0x2d5e <DIO_u8SetPinValue+0xcc>
    2d5a:	88 0f       	add	r24, r24
    2d5c:	99 1f       	adc	r25, r25
    2d5e:	6a 95       	dec	r22
    2d60:	e2 f7       	brpl	.-8      	; 0x2d5a <DIO_u8SetPinValue+0xc8>
    2d62:	28 2b       	or	r18, r24
    2d64:	22 bb       	out	0x12, r18	; 18
    2d66:	0b c0       	rjmp	.+22     	; 0x2d7e <DIO_u8SetPinValue+0xec>
			} else {
				CLR_BIT(DIO_U8_PORTD_REG, Copy_u8PinId);
    2d68:	22 b3       	in	r18, 0x12	; 18
    2d6a:	81 e0       	ldi	r24, 0x01	; 1
    2d6c:	90 e0       	ldi	r25, 0x00	; 0
    2d6e:	02 c0       	rjmp	.+4      	; 0x2d74 <DIO_u8SetPinValue+0xe2>
    2d70:	88 0f       	add	r24, r24
    2d72:	99 1f       	adc	r25, r25
    2d74:	6a 95       	dec	r22
    2d76:	e2 f7       	brpl	.-8      	; 0x2d70 <DIO_u8SetPinValue+0xde>
    2d78:	80 95       	com	r24
    2d7a:	82 23       	and	r24, r18
    2d7c:	82 bb       	out	0x12, r24	; 18
    2d7e:	81 e0       	ldi	r24, 0x01	; 1
    2d80:	08 95       	ret
    2d82:	80 e0       	ldi	r24, 0x00	; 0
	} else {
		Local_u8ErrorState = STD_TYPES_NOK;
	}

	return Local_u8ErrorState;
}
    2d84:	08 95       	ret

00002d86 <DIO_u8GetPinValue>:
u8 DIO_u8GetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8* Copy_Pu8ReturnValue) {
    2d86:	fa 01       	movw	r30, r20
	u8 Local_u8ErrorState = STD_TYPES_OK;

	if (Copy_u8PortId <= DIO_u8_PORTD && Copy_u8PinId <= DIO_u8_PIN7
    2d88:	84 30       	cpi	r24, 0x04	; 4
    2d8a:	f8 f4       	brcc	.+62     	; 0x2dca <DIO_u8GetPinValue+0x44>
    2d8c:	68 30       	cpi	r22, 0x08	; 8
    2d8e:	e8 f4       	brcc	.+58     	; 0x2dca <DIO_u8GetPinValue+0x44>
    2d90:	41 15       	cp	r20, r1
    2d92:	51 05       	cpc	r21, r1
    2d94:	d1 f0       	breq	.+52     	; 0x2dca <DIO_u8GetPinValue+0x44>
			&& Copy_Pu8ReturnValue != NULL) {

		switch (Copy_u8PortId) {
    2d96:	81 30       	cpi	r24, 0x01	; 1
    2d98:	49 f0       	breq	.+18     	; 0x2dac <DIO_u8GetPinValue+0x26>
    2d9a:	81 30       	cpi	r24, 0x01	; 1
    2d9c:	28 f0       	brcs	.+10     	; 0x2da8 <DIO_u8GetPinValue+0x22>
    2d9e:	82 30       	cpi	r24, 0x02	; 2
    2da0:	39 f0       	breq	.+14     	; 0x2db0 <DIO_u8GetPinValue+0x2a>
    2da2:	83 30       	cpi	r24, 0x03	; 3
    2da4:	81 f4       	brne	.+32     	; 0x2dc6 <DIO_u8GetPinValue+0x40>
    2da6:	06 c0       	rjmp	.+12     	; 0x2db4 <DIO_u8GetPinValue+0x2e>

		case DIO_u8_PORTA:

			*Copy_Pu8ReturnValue = GET_BIT(DIO_U8_PINA_REG, Copy_u8PinId);
    2da8:	89 b3       	in	r24, 0x19	; 25
    2daa:	05 c0       	rjmp	.+10     	; 0x2db6 <DIO_u8GetPinValue+0x30>

			break;

		case DIO_u8_PORTB:

			*Copy_Pu8ReturnValue = GET_BIT(DIO_U8_PINB_REG, Copy_u8PinId);
    2dac:	86 b3       	in	r24, 0x16	; 22
    2dae:	03 c0       	rjmp	.+6      	; 0x2db6 <DIO_u8GetPinValue+0x30>

			break;

		case DIO_u8_PORTC:

			*Copy_Pu8ReturnValue = GET_BIT(DIO_U8_PINC_REG, Copy_u8PinId);
    2db0:	83 b3       	in	r24, 0x13	; 19
    2db2:	01 c0       	rjmp	.+2      	; 0x2db6 <DIO_u8GetPinValue+0x30>

			break;

		case DIO_u8_PORTD:

			*Copy_Pu8ReturnValue = GET_BIT(DIO_U8_PIND_REG, Copy_u8PinId);
    2db4:	80 b3       	in	r24, 0x10	; 16
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	02 c0       	rjmp	.+4      	; 0x2dbe <DIO_u8GetPinValue+0x38>
    2dba:	95 95       	asr	r25
    2dbc:	87 95       	ror	r24
    2dbe:	6a 95       	dec	r22
    2dc0:	e2 f7       	brpl	.-8      	; 0x2dba <DIO_u8GetPinValue+0x34>
    2dc2:	81 70       	andi	r24, 0x01	; 1
    2dc4:	80 83       	st	Z, r24
    2dc6:	81 e0       	ldi	r24, 0x01	; 1
    2dc8:	08 95       	ret
    2dca:	80 e0       	ldi	r24, 0x00	; 0
	} else {
		Local_u8ErrorState = STD_TYPES_NOK;
	}

	return Local_u8ErrorState;
}
    2dcc:	08 95       	ret

00002dce <KPD_u8GetKeyValueNoWait>:
KPD_U8_C1_PIN_PORT,
KPD_U8_C2_PIN_PORT,
KPD_U8_C3_PIN_PORT,
KPD_U8_C4_PIN_PORT };

u8 KPD_u8GetKeyValueNoWait(u8* Copy_Pu8ReturnResult) {
    2dce:	4f 92       	push	r4
    2dd0:	5f 92       	push	r5
    2dd2:	7f 92       	push	r7
    2dd4:	8f 92       	push	r8
    2dd6:	9f 92       	push	r9
    2dd8:	af 92       	push	r10
    2dda:	bf 92       	push	r11
    2ddc:	cf 92       	push	r12
    2dde:	df 92       	push	r13
    2de0:	ef 92       	push	r14
    2de2:	ff 92       	push	r15
    2de4:	0f 93       	push	r16
    2de6:	1f 93       	push	r17
    2de8:	df 93       	push	r29
    2dea:	cf 93       	push	r28
    2dec:	0f 92       	push	r0
    2dee:	cd b7       	in	r28, 0x3d	; 61
    2df0:	de b7       	in	r29, 0x3e	; 62
    2df2:	4c 01       	movw	r8, r24
	u8 local_u8ErrorState;
	u8 local_u8PinValue = 1;

	if (Copy_Pu8ReturnResult != NULL) {
    2df4:	00 97       	sbiw	r24, 0x00	; 0
    2df6:	11 f4       	brne	.+4      	; 0x2dfc <KPD_u8GetKeyValueNoWait+0x2e>
    2df8:	10 e0       	ldi	r17, 0x00	; 0
    2dfa:	78 c0       	rjmp	.+240    	; 0x2eec <KPD_u8GetKeyValueNoWait+0x11e>
KPD_U8_C3_PIN_PORT,
KPD_U8_C4_PIN_PORT };

u8 KPD_u8GetKeyValueNoWait(u8* Copy_Pu8ReturnResult) {
	u8 local_u8ErrorState;
	u8 local_u8PinValue = 1;
    2dfc:	81 e0       	ldi	r24, 0x01	; 1
    2dfe:	89 83       	std	Y+1, r24	; 0x01
    2e00:	10 e0       	ldi	r17, 0x00	; 0
    2e02:	ee 24       	eor	r14, r14
    2e04:	ff 24       	eor	r15, r15
			DIO_u8_LOW);

			//check each column
			for (u8 col = 0; col < 4; col++) {
				//get pin value
				DIO_u8GetPinValue(KPD_Au8ColsPorts[col], KPD_Au8ColsPins[col],
    2e06:	5e 01       	movw	r10, r28
    2e08:	08 94       	sec
    2e0a:	a1 1c       	adc	r10, r1
    2e0c:	b1 1c       	adc	r11, r1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2e0e:	50 e4       	ldi	r21, 0x40	; 64
    2e10:	45 2e       	mov	r4, r21
    2e12:	5c e9       	ldi	r21, 0x9C	; 156
    2e14:	55 2e       	mov	r5, r21
		local_u8ErrorState = STD_TYPES_NOK;

		for (u8 row = 0; row < 4; row++) {

			//activate only one row
			DIO_u8SetPinValue(KPD_Au8RowsPorts[row], KPD_Au8RowsPins[row],
    2e16:	f7 01       	movw	r30, r14
    2e18:	e9 58       	subi	r30, 0x89	; 137
    2e1a:	ff 4f       	sbci	r31, 0xFF	; 255
    2e1c:	70 80       	ld	r7, Z
    2e1e:	f7 01       	movw	r30, r14
    2e20:	e5 58       	subi	r30, 0x85	; 133
    2e22:	ff 4f       	sbci	r31, 0xFF	; 255
    2e24:	c0 80       	ld	r12, Z
    2e26:	87 2d       	mov	r24, r7
    2e28:	6c 2d       	mov	r22, r12
    2e2a:	40 e0       	ldi	r20, 0x00	; 0
    2e2c:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			DIO_u8_LOW);

			//check each column
			for (u8 col = 0; col < 4; col++) {
				//get pin value
				DIO_u8GetPinValue(KPD_Au8ColsPorts[col], KPD_Au8ColsPins[col],
    2e30:	44 e0       	ldi	r20, 0x04	; 4
    2e32:	d4 2e       	mov	r13, r20
    2e34:	82 e0       	ldi	r24, 0x02	; 2
    2e36:	64 e0       	ldi	r22, 0x04	; 4
    2e38:	a5 01       	movw	r20, r10
    2e3a:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <DIO_u8GetPinValue>
						&local_u8PinValue);

				if (local_u8PinValue == DIO_u8_LOW) {
    2e3e:	89 81       	ldd	r24, Y+1	; 0x01
    2e40:	88 23       	and	r24, r24
    2e42:	19 f4       	brne	.+6      	; 0x2e4a <KPD_u8GetKeyValueNoWait+0x7c>
    2e44:	00 e0       	ldi	r16, 0x00	; 0
    2e46:	10 e0       	ldi	r17, 0x00	; 0
    2e48:	26 c0       	rjmp	.+76     	; 0x2e96 <KPD_u8GetKeyValueNoWait+0xc8>
			DIO_u8_LOW);

			//check each column
			for (u8 col = 0; col < 4; col++) {
				//get pin value
				DIO_u8GetPinValue(KPD_Au8ColsPorts[col], KPD_Au8ColsPins[col],
    2e4a:	35 e0       	ldi	r19, 0x05	; 5
    2e4c:	d3 2e       	mov	r13, r19
    2e4e:	82 e0       	ldi	r24, 0x02	; 2
    2e50:	65 e0       	ldi	r22, 0x05	; 5
    2e52:	a5 01       	movw	r20, r10
    2e54:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <DIO_u8GetPinValue>
						&local_u8PinValue);

				if (local_u8PinValue == DIO_u8_LOW) {
    2e58:	89 81       	ldd	r24, Y+1	; 0x01
    2e5a:	88 23       	and	r24, r24
    2e5c:	19 f4       	brne	.+6      	; 0x2e64 <KPD_u8GetKeyValueNoWait+0x96>
    2e5e:	01 e0       	ldi	r16, 0x01	; 1
    2e60:	10 e0       	ldi	r17, 0x00	; 0
    2e62:	19 c0       	rjmp	.+50     	; 0x2e96 <KPD_u8GetKeyValueNoWait+0xc8>
			DIO_u8_LOW);

			//check each column
			for (u8 col = 0; col < 4; col++) {
				//get pin value
				DIO_u8GetPinValue(KPD_Au8ColsPorts[col], KPD_Au8ColsPins[col],
    2e64:	26 e0       	ldi	r18, 0x06	; 6
    2e66:	d2 2e       	mov	r13, r18
    2e68:	82 e0       	ldi	r24, 0x02	; 2
    2e6a:	66 e0       	ldi	r22, 0x06	; 6
    2e6c:	a5 01       	movw	r20, r10
    2e6e:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <DIO_u8GetPinValue>
						&local_u8PinValue);

				if (local_u8PinValue == DIO_u8_LOW) {
    2e72:	89 81       	ldd	r24, Y+1	; 0x01
    2e74:	88 23       	and	r24, r24
    2e76:	19 f4       	brne	.+6      	; 0x2e7e <KPD_u8GetKeyValueNoWait+0xb0>
    2e78:	02 e0       	ldi	r16, 0x02	; 2
    2e7a:	10 e0       	ldi	r17, 0x00	; 0
    2e7c:	0c c0       	rjmp	.+24     	; 0x2e96 <KPD_u8GetKeyValueNoWait+0xc8>
			DIO_u8_LOW);

			//check each column
			for (u8 col = 0; col < 4; col++) {
				//get pin value
				DIO_u8GetPinValue(KPD_Au8ColsPorts[col], KPD_Au8ColsPins[col],
    2e7e:	97 e0       	ldi	r25, 0x07	; 7
    2e80:	d9 2e       	mov	r13, r25
    2e82:	82 e0       	ldi	r24, 0x02	; 2
    2e84:	67 e0       	ldi	r22, 0x07	; 7
    2e86:	a5 01       	movw	r20, r10
    2e88:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <DIO_u8GetPinValue>
						&local_u8PinValue);

				if (local_u8PinValue == DIO_u8_LOW) {
    2e8c:	89 81       	ldd	r24, Y+1	; 0x01
    2e8e:	88 23       	and	r24, r24
    2e90:	e9 f4       	brne	.+58     	; 0x2ecc <KPD_u8GetKeyValueNoWait+0xfe>
    2e92:	03 e0       	ldi	r16, 0x03	; 3
    2e94:	10 e0       	ldi	r17, 0x00	; 0
    2e96:	c2 01       	movw	r24, r4
    2e98:	01 97       	sbiw	r24, 0x01	; 1
    2e9a:	f1 f7       	brne	.-4      	; 0x2e98 <KPD_u8GetKeyValueNoWait+0xca>
					//debouncing
					_delay_ms(20);

					do {
						DIO_u8GetPinValue(KPD_Au8ColsPorts[col],
    2e9c:	82 e0       	ldi	r24, 0x02	; 2
    2e9e:	6d 2d       	mov	r22, r13
    2ea0:	a5 01       	movw	r20, r10
    2ea2:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <DIO_u8GetPinValue>
								KPD_Au8ColsPins[col], &local_u8PinValue);
					} while (local_u8PinValue == DIO_u8_LOW);
    2ea6:	89 81       	ldd	r24, Y+1	; 0x01
    2ea8:	88 23       	and	r24, r24
    2eaa:	c1 f3       	breq	.-16     	; 0x2e9c <KPD_u8GetKeyValueNoWait+0xce>

					*Copy_Pu8ReturnResult = KPD_Au8Keys[row][col];
    2eac:	f7 01       	movw	r30, r14
    2eae:	ee 0f       	add	r30, r30
    2eb0:	ff 1f       	adc	r31, r31
    2eb2:	ee 0f       	add	r30, r30
    2eb4:	ff 1f       	adc	r31, r31
    2eb6:	e0 0f       	add	r30, r16
    2eb8:	f1 1f       	adc	r31, r17
    2eba:	e1 58       	subi	r30, 0x81	; 129
    2ebc:	ff 4f       	sbci	r31, 0xFF	; 255
    2ebe:	80 81       	ld	r24, Z
    2ec0:	f4 01       	movw	r30, r8
    2ec2:	80 83       	st	Z, r24
    2ec4:	c2 01       	movw	r24, r4
    2ec6:	01 97       	sbiw	r24, 0x01	; 1
    2ec8:	f1 f7       	brne	.-4      	; 0x2ec6 <KPD_u8GetKeyValueNoWait+0xf8>
    2eca:	11 e0       	ldi	r17, 0x01	; 1

					break;
				}
			}
			//deactivate last row
			DIO_u8SetPinValue(KPD_Au8RowsPorts[row], KPD_Au8RowsPins[row],
    2ecc:	87 2d       	mov	r24, r7
    2ece:	6c 2d       	mov	r22, r12
    2ed0:	41 e0       	ldi	r20, 0x01	; 1
    2ed2:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			DIO_u8_HIGH);

			// break if pressed
			if (local_u8PinValue == 0) {
    2ed6:	89 81       	ldd	r24, Y+1	; 0x01
    2ed8:	88 23       	and	r24, r24
    2eda:	41 f0       	breq	.+16     	; 0x2eec <KPD_u8GetKeyValueNoWait+0x11e>
				break;
    2edc:	08 94       	sec
    2ede:	e1 1c       	adc	r14, r1
    2ee0:	f1 1c       	adc	r15, r1
	if (Copy_Pu8ReturnResult != NULL) {

		//*Copy_Pu8ReturnResult = 0xff;
		local_u8ErrorState = STD_TYPES_NOK;

		for (u8 row = 0; row < 4; row++) {
    2ee2:	f4 e0       	ldi	r31, 0x04	; 4
    2ee4:	ef 16       	cp	r14, r31
    2ee6:	f1 04       	cpc	r15, r1
    2ee8:	09 f0       	breq	.+2      	; 0x2eec <KPD_u8GetKeyValueNoWait+0x11e>
    2eea:	95 cf       	rjmp	.-214    	; 0x2e16 <KPD_u8GetKeyValueNoWait+0x48>
	} else {
		local_u8ErrorState = STD_TYPES_NOK;
	}

	return local_u8ErrorState;
}
    2eec:	81 2f       	mov	r24, r17
    2eee:	0f 90       	pop	r0
    2ef0:	cf 91       	pop	r28
    2ef2:	df 91       	pop	r29
    2ef4:	1f 91       	pop	r17
    2ef6:	0f 91       	pop	r16
    2ef8:	ff 90       	pop	r15
    2efa:	ef 90       	pop	r14
    2efc:	df 90       	pop	r13
    2efe:	cf 90       	pop	r12
    2f00:	bf 90       	pop	r11
    2f02:	af 90       	pop	r10
    2f04:	9f 90       	pop	r9
    2f06:	8f 90       	pop	r8
    2f08:	7f 90       	pop	r7
    2f0a:	5f 90       	pop	r5
    2f0c:	4f 90       	pop	r4
    2f0e:	08 95       	ret

00002f10 <LCD_voidWriteHalfComnd>:

}

#elif LCD_MODE == 4
//privates
static void LCD_voidWriteHalfComnd(u8 Copy_u8HalfCmnd) {
    2f10:	1f 93       	push	r17
    2f12:	18 2f       	mov	r17, r24
	//RS
	DIO_u8SetPinValue(LCD_u8_RS_PORT, LCD_u8_RS_PIN, DIO_u8_LOW);
    2f14:	80 e0       	ldi	r24, 0x00	; 0
    2f16:	61 e0       	ldi	r22, 0x01	; 1
    2f18:	40 e0       	ldi	r20, 0x00	; 0
    2f1a:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
	//RW
	DIO_u8SetPinValue(LCD_u8_RW_PORT, LCD_u8_RW_PIN, DIO_u8_LOW);
    2f1e:	80 e0       	ldi	r24, 0x00	; 0
    2f20:	62 e0       	ldi	r22, 0x02	; 2
    2f22:	40 e0       	ldi	r20, 0x00	; 0
    2f24:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>

	//half data
	DIO_u8SetPinValue(LCD_u8_DATA_PIN7_PORT, LCD_u8_DATA_PIN7,
    2f28:	41 2f       	mov	r20, r17
    2f2a:	46 95       	lsr	r20
    2f2c:	46 95       	lsr	r20
    2f2e:	46 95       	lsr	r20
    2f30:	41 70       	andi	r20, 0x01	; 1
    2f32:	80 e0       	ldi	r24, 0x00	; 0
    2f34:	67 e0       	ldi	r22, 0x07	; 7
    2f36:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			Copy_u8HalfCmnd >> 3 & 1);
	DIO_u8SetPinValue(LCD_u8_DATA_PIN6_PORT, LCD_u8_DATA_PIN6,
    2f3a:	41 2f       	mov	r20, r17
    2f3c:	46 95       	lsr	r20
    2f3e:	46 95       	lsr	r20
    2f40:	41 70       	andi	r20, 0x01	; 1
    2f42:	80 e0       	ldi	r24, 0x00	; 0
    2f44:	66 e0       	ldi	r22, 0x06	; 6
    2f46:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			Copy_u8HalfCmnd >> 2 & 1);
	DIO_u8SetPinValue(LCD_u8_DATA_PIN5_PORT, LCD_u8_DATA_PIN5,
    2f4a:	41 2f       	mov	r20, r17
    2f4c:	46 95       	lsr	r20
    2f4e:	41 70       	andi	r20, 0x01	; 1
    2f50:	80 e0       	ldi	r24, 0x00	; 0
    2f52:	65 e0       	ldi	r22, 0x05	; 5
    2f54:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			Copy_u8HalfCmnd >> 1 & 1);
	DIO_u8SetPinValue(LCD_u8_DATA_PIN4_PORT, LCD_u8_DATA_PIN4,
    2f58:	11 70       	andi	r17, 0x01	; 1
    2f5a:	80 e0       	ldi	r24, 0x00	; 0
    2f5c:	64 e0       	ldi	r22, 0x04	; 4
    2f5e:	41 2f       	mov	r20, r17
    2f60:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			Copy_u8HalfCmnd >> 0 & 1);

	DIO_u8SetPinValue(LCD_u8_EN_PORT, LCD_u8_EN_PIN, DIO_u8_HIGH);
    2f64:	80 e0       	ldi	r24, 0x00	; 0
    2f66:	63 e0       	ldi	r22, 0x03	; 3
    2f68:	41 e0       	ldi	r20, 0x01	; 1
    2f6a:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2f6e:	82 e0       	ldi	r24, 0x02	; 2
    2f70:	8a 95       	dec	r24
    2f72:	f1 f7       	brne	.-4      	; 0x2f70 <LCD_voidWriteHalfComnd+0x60>

	_delay_us(1);

	DIO_u8SetPinValue(LCD_u8_EN_PORT, LCD_u8_EN_PIN, DIO_u8_LOW);
    2f74:	80 e0       	ldi	r24, 0x00	; 0
    2f76:	63 e0       	ldi	r22, 0x03	; 3
    2f78:	40 e0       	ldi	r20, 0x00	; 0
    2f7a:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>

}
    2f7e:	1f 91       	pop	r17
    2f80:	08 95       	ret

00002f82 <LCD_voidWriteComnd>:



}

void LCD_voidWriteComnd(u8 Copy_u8Cmnd) {
    2f82:	1f 93       	push	r17
    2f84:	18 2f       	mov	r17, r24
	LCD_voidWriteHalfComnd(Copy_u8Cmnd >> 4 & 0x0f); //high bits
    2f86:	82 95       	swap	r24
    2f88:	8f 70       	andi	r24, 0x0F	; 15
    2f8a:	0e 94 88 17 	call	0x2f10	; 0x2f10 <LCD_voidWriteHalfComnd>
	LCD_voidWriteHalfComnd(Copy_u8Cmnd & 0x0f); //low  bits
    2f8e:	81 2f       	mov	r24, r17
    2f90:	8f 70       	andi	r24, 0x0F	; 15
    2f92:	0e 94 88 17 	call	0x2f10	; 0x2f10 <LCD_voidWriteHalfComnd>
}
    2f96:	1f 91       	pop	r17
    2f98:	08 95       	ret

00002f9a <LCD_u8GoToXY>:
}

u8 LCD_u8GoToXY(u8 Copy_u8LineNumber, u8 Copy_u8CharLocation) {
	u8 local_u8ErrorState = STD_TYPES_OK;

	switch (Copy_u8LineNumber) {
    2f9a:	88 23       	and	r24, r24
    2f9c:	21 f0       	breq	.+8      	; 0x2fa6 <LCD_u8GoToXY+0xc>
    2f9e:	81 30       	cpi	r24, 0x01	; 1
    2fa0:	29 f0       	breq	.+10     	; 0x2fac <LCD_u8GoToXY+0x12>
    2fa2:	80 e0       	ldi	r24, 0x00	; 0
    2fa4:	08 c0       	rjmp	.+16     	; 0x2fb6 <LCD_u8GoToXY+0x1c>
	case LCD_u8_LINE1:
		LCD_voidWriteComnd(0x80 + Copy_u8CharLocation);
    2fa6:	86 2f       	mov	r24, r22
    2fa8:	80 58       	subi	r24, 0x80	; 128
    2faa:	02 c0       	rjmp	.+4      	; 0x2fb0 <LCD_u8GoToXY+0x16>
		break;

	case LCD_u8_LINE2:
		LCD_voidWriteComnd(0xC0 + Copy_u8CharLocation);
    2fac:	86 2f       	mov	r24, r22
    2fae:	80 54       	subi	r24, 0x40	; 64
    2fb0:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <LCD_voidWriteComnd>
    2fb4:	81 e0       	ldi	r24, 0x01	; 1
    2fb6:	9a e6       	ldi	r25, 0x6A	; 106
    2fb8:	9a 95       	dec	r25
    2fba:	f1 f7       	brne	.-4      	; 0x2fb8 <LCD_u8GoToXY+0x1e>


	_delay_us(40);

	return local_u8ErrorState;
}
    2fbc:	08 95       	ret

00002fbe <LCD_voidCursorOFFDataON>:
	LCD_voidWriteHalfComnd(Copy_u8Cmnd & 0x0f); //low  bits
}


void LCD_voidCursorOFFDataON(){
	LCD_voidWriteComnd(0b00001100);
    2fbe:	8c e0       	ldi	r24, 0x0C	; 12
    2fc0:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <LCD_voidWriteComnd>
}
    2fc4:	08 95       	ret

00002fc6 <LCD_Init>:
	DIO_u8SetPinValue(LCD_u8_EN_PORT, LCD_u8_EN_PIN, DIO_u8_LOW);

}
//end privates

void LCD_Init(void) {
    2fc6:	1f 93       	push	r17
    2fc8:	8e e5       	ldi	r24, 0x5E	; 94
    2fca:	91 e0       	ldi	r25, 0x01	; 1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2fcc:	28 ec       	ldi	r18, 0xC8	; 200
    2fce:	30 e0       	ldi	r19, 0x00	; 0
    2fd0:	f9 01       	movw	r30, r18
    2fd2:	31 97       	sbiw	r30, 0x01	; 1
    2fd4:	f1 f7       	brne	.-4      	; 0x2fd2 <LCD_Init+0xc>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2fd6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2fd8:	d9 f7       	brne	.-10     	; 0x2fd0 <LCD_Init+0xa>
	_delay_ms(35);

	//function set
	LCD_voidWriteHalfComnd(0b0010);
    2fda:	82 e0       	ldi	r24, 0x02	; 2
    2fdc:	0e 94 88 17 	call	0x2f10	; 0x2f10 <LCD_voidWriteHalfComnd>

	LCD_voidWriteComnd(0b00101000);
    2fe0:	88 e2       	ldi	r24, 0x28	; 40
    2fe2:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <LCD_voidWriteComnd>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2fe6:	1a e6       	ldi	r17, 0x6A	; 106
    2fe8:	81 2f       	mov	r24, r17
    2fea:	8a 95       	dec	r24
    2fec:	f1 f7       	brne	.-4      	; 0x2fea <LCD_Init+0x24>
	_delay_us(40);
	//display on/off control
	LCD_voidWriteComnd(0b00001101);
    2fee:	8d e0       	ldi	r24, 0x0D	; 13
    2ff0:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <LCD_voidWriteComnd>
    2ff4:	1a 95       	dec	r17
    2ff6:	f1 f7       	brne	.-4      	; 0x2ff4 <LCD_Init+0x2e>
	_delay_us(40);
	//display clear
	LCD_voidWriteComnd(0b00000001);
    2ff8:	81 e0       	ldi	r24, 0x01	; 1
    2ffa:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <LCD_voidWriteComnd>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2ffe:	80 ea       	ldi	r24, 0xA0	; 160
    3000:	9f e0       	ldi	r25, 0x0F	; 15
    3002:	01 97       	sbiw	r24, 0x01	; 1
    3004:	f1 f7       	brne	.-4      	; 0x3002 <LCD_Init+0x3c>
	_delay_ms(2);
	//entry mode
	LCD_voidWriteComnd(0b00000110);
    3006:	86 e0       	ldi	r24, 0x06	; 6
    3008:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <LCD_voidWriteComnd>

}
    300c:	1f 91       	pop	r17
    300e:	08 95       	ret

00003010 <LCD_voidWriteHalfChar>:
	_delay_us(1);

	DIO_u8SetPinValue(LCD_u8_EN_PORT, LCD_u8_EN_PIN, DIO_u8_LOW);

}
static void LCD_voidWriteHalfChar(u8 Copy_u8HalfChar) {
    3010:	1f 93       	push	r17
    3012:	18 2f       	mov	r17, r24
	//RS
	DIO_u8SetPinValue(LCD_u8_RS_PORT, LCD_u8_RS_PIN, DIO_u8_HIGH);
    3014:	80 e0       	ldi	r24, 0x00	; 0
    3016:	61 e0       	ldi	r22, 0x01	; 1
    3018:	41 e0       	ldi	r20, 0x01	; 1
    301a:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
	//RW
	DIO_u8SetPinValue(LCD_u8_RW_PORT, LCD_u8_RW_PIN, DIO_u8_LOW);
    301e:	80 e0       	ldi	r24, 0x00	; 0
    3020:	62 e0       	ldi	r22, 0x02	; 2
    3022:	40 e0       	ldi	r20, 0x00	; 0
    3024:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>

	//half data
	DIO_u8SetPinValue(LCD_u8_DATA_PIN7_PORT, LCD_u8_DATA_PIN7,
    3028:	41 2f       	mov	r20, r17
    302a:	46 95       	lsr	r20
    302c:	46 95       	lsr	r20
    302e:	46 95       	lsr	r20
    3030:	41 70       	andi	r20, 0x01	; 1
    3032:	80 e0       	ldi	r24, 0x00	; 0
    3034:	67 e0       	ldi	r22, 0x07	; 7
    3036:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			Copy_u8HalfChar >> 3 & 1);
	DIO_u8SetPinValue(LCD_u8_DATA_PIN6_PORT, LCD_u8_DATA_PIN6,
    303a:	41 2f       	mov	r20, r17
    303c:	46 95       	lsr	r20
    303e:	46 95       	lsr	r20
    3040:	41 70       	andi	r20, 0x01	; 1
    3042:	80 e0       	ldi	r24, 0x00	; 0
    3044:	66 e0       	ldi	r22, 0x06	; 6
    3046:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			Copy_u8HalfChar >> 2 & 1);
	DIO_u8SetPinValue(LCD_u8_DATA_PIN5_PORT, LCD_u8_DATA_PIN5,
    304a:	41 2f       	mov	r20, r17
    304c:	46 95       	lsr	r20
    304e:	41 70       	andi	r20, 0x01	; 1
    3050:	80 e0       	ldi	r24, 0x00	; 0
    3052:	65 e0       	ldi	r22, 0x05	; 5
    3054:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			Copy_u8HalfChar >> 1 & 1);
	DIO_u8SetPinValue(LCD_u8_DATA_PIN4_PORT, LCD_u8_DATA_PIN4,
    3058:	11 70       	andi	r17, 0x01	; 1
    305a:	80 e0       	ldi	r24, 0x00	; 0
    305c:	64 e0       	ldi	r22, 0x04	; 4
    305e:	41 2f       	mov	r20, r17
    3060:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
			Copy_u8HalfChar >> 0 & 1);

	DIO_u8SetPinValue(LCD_u8_EN_PORT, LCD_u8_EN_PIN, DIO_u8_HIGH);
    3064:	80 e0       	ldi	r24, 0x00	; 0
    3066:	63 e0       	ldi	r22, 0x03	; 3
    3068:	41 e0       	ldi	r20, 0x01	; 1
    306a:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    306e:	82 e0       	ldi	r24, 0x02	; 2
    3070:	8a 95       	dec	r24
    3072:	f1 f7       	brne	.-4      	; 0x3070 <LCD_voidWriteHalfChar+0x60>

	_delay_us(1);

	DIO_u8SetPinValue(LCD_u8_EN_PORT, LCD_u8_EN_PIN, DIO_u8_LOW);
    3074:	80 e0       	ldi	r24, 0x00	; 0
    3076:	63 e0       	ldi	r22, 0x03	; 3
    3078:	40 e0       	ldi	r20, 0x00	; 0
    307a:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>

}
    307e:	1f 91       	pop	r17
    3080:	08 95       	ret

00003082 <LCD_voidWriteChar>:
	//entry mode
	LCD_voidWriteComnd(0b00000110);

}

void LCD_voidWriteChar(u8 Copy_u8Char) {
    3082:	1f 93       	push	r17
    3084:	18 2f       	mov	r17, r24
	LCD_voidWriteHalfChar(Copy_u8Char >> 4 & 0x0f); //high bits
    3086:	82 95       	swap	r24
    3088:	8f 70       	andi	r24, 0x0F	; 15
    308a:	0e 94 08 18 	call	0x3010	; 0x3010 <LCD_voidWriteHalfChar>
	LCD_voidWriteHalfChar(Copy_u8Char & 0x0f); //low  bits
    308e:	81 2f       	mov	r24, r17
    3090:	8f 70       	andi	r24, 0x0F	; 15
    3092:	0e 94 08 18 	call	0x3010	; 0x3010 <LCD_voidWriteHalfChar>



}
    3096:	1f 91       	pop	r17
    3098:	08 95       	ret

0000309a <LCD_voidWriteString>:
	_delay_us(40);

	return local_u8ErrorState;
}

void LCD_voidWriteString(u8* str) {
    309a:	cf 93       	push	r28
    309c:	df 93       	push	r29
    309e:	ec 01       	movw	r28, r24

	if (str != NULL) {
    30a0:	00 97       	sbiw	r24, 0x00	; 0
    30a2:	21 f4       	brne	.+8      	; 0x30ac <LCD_voidWriteString+0x12>
    30a4:	06 c0       	rjmp	.+12     	; 0x30b2 <LCD_voidWriteString+0x18>

		while (*str != '\0') {
			LCD_voidWriteChar(*str);
    30a6:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
			str++;
    30aa:	21 96       	adiw	r28, 0x01	; 1

void LCD_voidWriteString(u8* str) {

	if (str != NULL) {

		while (*str != '\0') {
    30ac:	88 81       	ld	r24, Y
    30ae:	88 23       	and	r24, r24
    30b0:	d1 f7       	brne	.-12     	; 0x30a6 <LCD_voidWriteString+0xc>
			LCD_voidWriteChar(*str);
			str++;
		}

	}
}
    30b2:	df 91       	pop	r29
    30b4:	cf 91       	pop	r28
    30b6:	08 95       	ret

000030b8 <LCD_voidCreateChar>:





void LCD_voidCreateChar(u8 indexInCGRAM, u8* smallPattern) {
    30b8:	cf 93       	push	r28
    30ba:	df 93       	push	r29
    30bc:	eb 01       	movw	r28, r22

	if (smallPattern != NULL && indexInCGRAM < 8) {
    30be:	61 15       	cp	r22, r1
    30c0:	71 05       	cpc	r23, r1
    30c2:	01 f1       	breq	.+64     	; 0x3104 <LCD_voidCreateChar+0x4c>
    30c4:	88 30       	cpi	r24, 0x08	; 8
    30c6:	f0 f4       	brcc	.+60     	; 0x3104 <LCD_voidCreateChar+0x4c>

		//set address counter : CGRAM
		LCD_voidWriteComnd(0x40 + (8 * indexInCGRAM));
    30c8:	88 0f       	add	r24, r24
    30ca:	88 0f       	add	r24, r24
    30cc:	88 0f       	add	r24, r24
    30ce:	80 5c       	subi	r24, 0xC0	; 192
    30d0:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <LCD_voidWriteComnd>
		//draw a pattern
		LCD_voidWriteChar(smallPattern[0]);
    30d4:	88 81       	ld	r24, Y
    30d6:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		LCD_voidWriteChar(smallPattern[1]);
    30da:	89 81       	ldd	r24, Y+1	; 0x01
    30dc:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		LCD_voidWriteChar(smallPattern[2]);
    30e0:	8a 81       	ldd	r24, Y+2	; 0x02
    30e2:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		LCD_voidWriteChar(smallPattern[3]);
    30e6:	8b 81       	ldd	r24, Y+3	; 0x03
    30e8:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		LCD_voidWriteChar(smallPattern[4]);
    30ec:	8c 81       	ldd	r24, Y+4	; 0x04
    30ee:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		LCD_voidWriteChar(smallPattern[5]);
    30f2:	8d 81       	ldd	r24, Y+5	; 0x05
    30f4:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		LCD_voidWriteChar(smallPattern[6]);
    30f8:	8e 81       	ldd	r24, Y+6	; 0x06
    30fa:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		LCD_voidWriteChar(smallPattern[7]);
    30fe:	8f 81       	ldd	r24, Y+7	; 0x07
    3100:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>

//	_delay_ms(1);


	//set address counter : DDRAM
	LCD_u8GoToXY(LCD_u8_LINE1, 0);
    3104:	80 e0       	ldi	r24, 0x00	; 0
    3106:	60 e0       	ldi	r22, 0x00	; 0
    3108:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <LCD_u8GoToXY>

}
    310c:	df 91       	pop	r29
    310e:	cf 91       	pop	r28
    3110:	08 95       	ret

00003112 <TMR_voidInitTMR0>:
#include "Timer_config.h"

void TMR_voidInitTMR0(void) {

	// Timer 0 mode
	CLR_BIT(TMR_u8_TMR0_TCCR0_REG, BIT6);
    3112:	83 b7       	in	r24, 0x33	; 51
    3114:	8f 7b       	andi	r24, 0xBF	; 191
    3116:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(TMR_u8_TMR0_TCCR0_REG, BIT3);
    3118:	83 b7       	in	r24, 0x33	; 51
    311a:	87 7f       	andi	r24, 0xF7	; 247
    311c:	83 bf       	out	0x33, r24	; 51
	// prescaler
	CLR_BIT(TMR_u8_TMR0_TCCR0_REG, BIT2);
    311e:	83 b7       	in	r24, 0x33	; 51
    3120:	8b 7f       	andi	r24, 0xFB	; 251
    3122:	83 bf       	out	0x33, r24	; 51
	SET_BIT(TMR_u8_TMR0_TCCR0_REG, BIT1);
    3124:	83 b7       	in	r24, 0x33	; 51
    3126:	82 60       	ori	r24, 0x02	; 2
    3128:	83 bf       	out	0x33, r24	; 51
	CLR_BIT(TMR_u8_TMR0_TCCR0_REG, BIT0);
    312a:	83 b7       	in	r24, 0x33	; 51
    312c:	8e 7f       	andi	r24, 0xFE	; 254
    312e:	83 bf       	out	0x33, r24	; 51

}
    3130:	08 95       	ret

00003132 <TMR_voidGetTMR0>:

void TMR_voidGetTMR0(u8* value) {
    3132:	fc 01       	movw	r30, r24

	*value = TMR_u8_TMR0_TCNT0_REG;
    3134:	82 b7       	in	r24, 0x32	; 50
    3136:	80 83       	st	Z, r24

}
    3138:	08 95       	ret

0000313a <main>:
//
//		vTaskDelay(SNAKE_SPEED_1MS_TICKS);
//	}
//}

int main() {
    313a:	ef 92       	push	r14
    313c:	ff 92       	push	r15
    313e:	0f 93       	push	r16
    3140:	df 93       	push	r29
    3142:	cf 93       	push	r28
    3144:	cd b7       	in	r28, 0x3d	; 61
    3146:	de b7       	in	r29, 0x3e	; 62
    3148:	28 97       	sbiw	r28, 0x08	; 8
    314a:	0f b6       	in	r0, 0x3f	; 63
    314c:	f8 94       	cli
    314e:	de bf       	out	0x3e, r29	; 62
    3150:	0f be       	out	0x3f, r0	; 63
    3152:	cd bf       	out	0x3d, r28	; 61

	DIO_Init();
    3154:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <DIO_Init>
	TMR_voidInitTMR0();
    3158:	0e 94 89 18 	call	0x3112	; 0x3112 <TMR_voidInitTMR0>
	LCD_Init();
    315c:	0e 94 e3 17 	call	0x2fc6	; 0x2fc6 <LCD_Init>
	LCD_voidCursorOFFDataON();
    3160:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <LCD_voidCursorOFFDataON>

	{
		/// Draw The Game Border

		u8 u8arrBlackChar[8] = { 0b11111, 0b10101, 0b10001, 0b10101, 0b11011,
				0b10101, 0b10001, 0b11111 };
    3164:	de 01       	movw	r26, r28
    3166:	11 96       	adiw	r26, 0x01	; 1
    3168:	ef e8       	ldi	r30, 0x8F	; 143
    316a:	f0 e0       	ldi	r31, 0x00	; 0
    316c:	88 e0       	ldi	r24, 0x08	; 8
    316e:	01 90       	ld	r0, Z+
    3170:	0d 92       	st	X+, r0
    3172:	81 50       	subi	r24, 0x01	; 1
    3174:	e1 f7       	brne	.-8      	; 0x316e <main+0x34>

		LCD_voidCreateChar(7, u8arrBlackChar);
    3176:	87 e0       	ldi	r24, 0x07	; 7
    3178:	be 01       	movw	r22, r28
    317a:	6f 5f       	subi	r22, 0xFF	; 255
    317c:	7f 4f       	sbci	r23, 0xFF	; 255
    317e:	0e 94 5c 18 	call	0x30b8	; 0x30b8 <LCD_voidCreateChar>
    3182:	00 e0       	ldi	r16, 0x00	; 0

		for (u8 i = 0; i < 5; i++) {
			LCD_u8GoToXY(0, i);
    3184:	80 e0       	ldi	r24, 0x00	; 0
    3186:	60 2f       	mov	r22, r16
    3188:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <LCD_u8GoToXY>
			LCD_voidWriteChar(7);
    318c:	87 e0       	ldi	r24, 0x07	; 7
    318e:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		u8 u8arrBlackChar[8] = { 0b11111, 0b10101, 0b10001, 0b10101, 0b11011,
				0b10101, 0b10001, 0b11111 };

		LCD_voidCreateChar(7, u8arrBlackChar);

		for (u8 i = 0; i < 5; i++) {
    3192:	0f 5f       	subi	r16, 0xFF	; 255
    3194:	05 30       	cpi	r16, 0x05	; 5
    3196:	b1 f7       	brne	.-20     	; 0x3184 <main+0x4a>
    3198:	0b e0       	ldi	r16, 0x0B	; 11
			LCD_u8GoToXY(0, i);
			LCD_voidWriteChar(7);
		}

		for (u8 i = 11; i < 16; i++) {
			LCD_u8GoToXY(0, i);
    319a:	80 e0       	ldi	r24, 0x00	; 0
    319c:	60 2f       	mov	r22, r16
    319e:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <LCD_u8GoToXY>
			LCD_voidWriteChar(7);
    31a2:	87 e0       	ldi	r24, 0x07	; 7
    31a4:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		for (u8 i = 0; i < 5; i++) {
			LCD_u8GoToXY(0, i);
			LCD_voidWriteChar(7);
		}

		for (u8 i = 11; i < 16; i++) {
    31a8:	0f 5f       	subi	r16, 0xFF	; 255
    31aa:	00 31       	cpi	r16, 0x10	; 16
    31ac:	b1 f7       	brne	.-20     	; 0x319a <main+0x60>
    31ae:	00 e0       	ldi	r16, 0x00	; 0
			LCD_u8GoToXY(0, i);
			LCD_voidWriteChar(7);
		}

		for (u8 i = 0; i < 16; i++) {
			LCD_u8GoToXY(1, i);
    31b0:	81 e0       	ldi	r24, 0x01	; 1
    31b2:	60 2f       	mov	r22, r16
    31b4:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <LCD_u8GoToXY>
			LCD_voidWriteChar(7);
    31b8:	87 e0       	ldi	r24, 0x07	; 7
    31ba:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>
		for (u8 i = 11; i < 16; i++) {
			LCD_u8GoToXY(0, i);
			LCD_voidWriteChar(7);
		}

		for (u8 i = 0; i < 16; i++) {
    31be:	0f 5f       	subi	r16, 0xFF	; 255
    31c0:	00 31       	cpi	r16, 0x10	; 16
    31c2:	b1 f7       	brne	.-20     	; 0x31b0 <main+0x76>
			LCD_voidWriteChar(7);
		}

	}

	semSnakeArr_1 = xSemaphoreCreateCounting(1, 1);
    31c4:	81 e0       	ldi	r24, 0x01	; 1
    31c6:	61 e0       	ldi	r22, 0x01	; 1
    31c8:	0e 94 0d 08 	call	0x101a	; 0x101a <xQueueCreateCountingSemaphore>
    31cc:	90 93 9a 01 	sts	0x019A, r25
    31d0:	80 93 99 01 	sts	0x0199, r24

	if ((xTaskCreate(voidTaskDirectionBtn, NULL, 90, NULL, 0, NULL) == pdPASS)
    31d4:	80 e2       	ldi	r24, 0x20	; 32
    31d6:	9b e1       	ldi	r25, 0x1B	; 27
    31d8:	60 e0       	ldi	r22, 0x00	; 0
    31da:	70 e0       	ldi	r23, 0x00	; 0
    31dc:	4a e5       	ldi	r20, 0x5A	; 90
    31de:	50 e0       	ldi	r21, 0x00	; 0
    31e0:	20 e0       	ldi	r18, 0x00	; 0
    31e2:	30 e0       	ldi	r19, 0x00	; 0
    31e4:	00 e0       	ldi	r16, 0x00	; 0
    31e6:	ee 24       	eor	r14, r14
    31e8:	ff 24       	eor	r15, r15
    31ea:	0e 94 4c 13 	call	0x2698	; 0x2698 <xTaskCreate>
    31ee:	81 30       	cpi	r24, 0x01	; 1
    31f0:	d9 f4       	brne	.+54     	; 0x3228 <main+0xee>
    31f2:	88 e2       	ldi	r24, 0x28	; 40
    31f4:	9a e1       	ldi	r25, 0x1A	; 26
    31f6:	60 e0       	ldi	r22, 0x00	; 0
    31f8:	70 e0       	ldi	r23, 0x00	; 0
    31fa:	4e e6       	ldi	r20, 0x6E	; 110
    31fc:	50 e0       	ldi	r21, 0x00	; 0
    31fe:	20 e0       	ldi	r18, 0x00	; 0
    3200:	30 e0       	ldi	r19, 0x00	; 0
    3202:	0e 94 4c 13 	call	0x2698	; 0x2698 <xTaskCreate>
    3206:	81 30       	cpi	r24, 0x01	; 1
    3208:	79 f4       	brne	.+30     	; 0x3228 <main+0xee>
    320a:	89 e1       	ldi	r24, 0x19	; 25
    320c:	99 e1       	ldi	r25, 0x19	; 25
    320e:	60 e0       	ldi	r22, 0x00	; 0
    3210:	70 e0       	ldi	r23, 0x00	; 0
    3212:	42 ec       	ldi	r20, 0xC2	; 194
    3214:	51 e0       	ldi	r21, 0x01	; 1
    3216:	20 e0       	ldi	r18, 0x00	; 0
    3218:	30 e0       	ldi	r19, 0x00	; 0
    321a:	0e 94 4c 13 	call	0x2698	; 0x2698 <xTaskCreate>
    321e:	81 30       	cpi	r24, 0x01	; 1
    3220:	19 f4       	brne	.+6      	; 0x3228 <main+0xee>
			&& (xTaskCreate(voidTaskUpdateLCD, NULL, 450, NULL, 0, NULL)
					== pdPASS)) {

		// Start

		vTaskStartScheduler();
    3222:	0e 94 6e 14 	call	0x28dc	; 0x28dc <vTaskStartScheduler>
    3226:	04 c0       	rjmp	.+8      	; 0x3230 <main+0xf6>

	} else {
		// no space found
		LCD_voidWriteString(" NULL ");
    3228:	85 e6       	ldi	r24, 0x65	; 101
    322a:	90 e0       	ldi	r25, 0x00	; 0
    322c:	0e 94 4d 18 	call	0x309a	; 0x309a <LCD_voidWriteString>
    3230:	ff cf       	rjmp	.-2      	; 0x3230 <main+0xf6>

00003232 <voidTaskUpdateLCD>:

		vTaskDelay(SNAKE_SPEED_1MS_TICKS);
	}
}

void voidTaskUpdateLCD(void *pv) {
    3232:	ef 92       	push	r14
    3234:	ff 92       	push	r15
    3236:	1f 93       	push	r17
    3238:	cf 93       	push	r28
    323a:	df 93       	push	r29

		for (Local_u8row = 0; Local_u8row < Glob_u8SnakeLength; Local_u8row++) {

			// equation from (x ,y ) to get the char position

			SET_BIT(
    323c:	64 e0       	ldi	r22, 0x04	; 4
    323e:	e6 2e       	mov	r14, r22
    3240:	f1 2c       	mov	r15, r1
    3242:	c1 e0       	ldi	r28, 0x01	; 1
    3244:	d0 e0       	ldi	r29, 0x00	; 0
	static u8 Local_u8row = 0;
	static u8 Local_u8col = 0;

	while (1) {

		for (Local_u8row = 0; Local_u8row < LCD_SIZE_Y_ROWS; Local_u8row++) {
    3246:	e0 e0       	ldi	r30, 0x00	; 0
    3248:	21 c0       	rjmp	.+66     	; 0x328c <voidTaskUpdateLCD+0x5a>
			for (Local_u8col = 0; Local_u8col < LCD_SIZE_X_COLS;
					Local_u8col++) {

				Glob_arrCharLCD[Local_u8row][Local_u8col].arrChar[0] = 0;
    324a:	f0 e0       	ldi	r31, 0x00	; 0
    324c:	53 e0       	ldi	r21, 0x03	; 3
    324e:	ee 0f       	add	r30, r30
    3250:	ff 1f       	adc	r31, r31
    3252:	5a 95       	dec	r21
    3254:	e1 f7       	brne	.-8      	; 0x324e <voidTaskUpdateLCD+0x1c>
    3256:	cf 01       	movw	r24, r30
    3258:	8f 59       	subi	r24, 0x9F	; 159
    325a:	9e 4f       	sbci	r25, 0xFE	; 254
    325c:	dc 01       	movw	r26, r24
    325e:	1c 92       	st	X, r1
				Glob_arrCharLCD[Local_u8row][Local_u8col].arrChar[1] = 0;
    3260:	11 96       	adiw	r26, 0x01	; 1
    3262:	1c 92       	st	X, r1
				Glob_arrCharLCD[Local_u8row][Local_u8col].arrChar[2] = 0;
    3264:	df 01       	movw	r26, r30
    3266:	ad 59       	subi	r26, 0x9D	; 157
    3268:	be 4f       	sbci	r27, 0xFE	; 254
    326a:	1c 92       	st	X, r1
				Glob_arrCharLCD[Local_u8row][Local_u8col].arrChar[3] = 0;
    326c:	dc 01       	movw	r26, r24
    326e:	13 96       	adiw	r26, 0x03	; 3
    3270:	1c 92       	st	X, r1
    3272:	13 97       	sbiw	r26, 0x03	; 3
				Glob_arrCharLCD[Local_u8row][Local_u8col].arrChar[4] = 0;
    3274:	eb 59       	subi	r30, 0x9B	; 155
    3276:	fe 4f       	sbci	r31, 0xFE	; 254
    3278:	10 82       	st	Z, r1
				Glob_arrCharLCD[Local_u8row][Local_u8col].arrChar[5] = 0;
    327a:	15 96       	adiw	r26, 0x05	; 5
    327c:	1c 92       	st	X, r1
    327e:	15 97       	sbiw	r26, 0x05	; 5
				Glob_arrCharLCD[Local_u8row][Local_u8col].arrChar[6] = 0;
    3280:	16 96       	adiw	r26, 0x06	; 6
    3282:	1c 92       	st	X, r1
    3284:	16 97       	sbiw	r26, 0x06	; 6
				Glob_arrCharLCD[Local_u8row][Local_u8col].arrChar[7] = 0;
    3286:	17 96       	adiw	r26, 0x07	; 7
    3288:	1c 92       	st	X, r1
    328a:	e2 2f       	mov	r30, r18
    328c:	2e 2f       	mov	r18, r30
    328e:	2f 5f       	subi	r18, 0xFF	; 255
	static u8 Local_u8col = 0;

	while (1) {

		for (Local_u8row = 0; Local_u8row < LCD_SIZE_Y_ROWS; Local_u8row++) {
			for (Local_u8col = 0; Local_u8col < LCD_SIZE_X_COLS;
    3290:	28 30       	cpi	r18, 0x08	; 8
    3292:	d9 f6       	brne	.-74     	; 0x324a <voidTaskUpdateLCD+0x18>
    3294:	87 e0       	ldi	r24, 0x07	; 7
	static u8 Local_u8row = 0;
	static u8 Local_u8col = 0;

	while (1) {

		for (Local_u8row = 0; Local_u8row < LCD_SIZE_Y_ROWS; Local_u8row++) {
    3296:	80 93 3b 01 	sts	0x013B, r24
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	80 93 3c 01 	sts	0x013C, r24
			}
		}

		/// Modify the Glob_arrCharLCD[][]

		xSemaphoreTake(semSnakeArr_1, portMAX_DELAY);
    32a0:	80 91 99 01 	lds	r24, 0x0199
    32a4:	90 91 9a 01 	lds	r25, 0x019A
    32a8:	6f ef       	ldi	r22, 0xFF	; 255
    32aa:	7f ef       	ldi	r23, 0xFF	; 255
    32ac:	0e 94 86 05 	call	0xb0c	; 0xb0c <xQueueSemaphoreTake>
    32b0:	90 e0       	ldi	r25, 0x00	; 0
    32b2:	40 c0       	rjmp	.+128    	; 0x3334 <voidTaskUpdateLCD+0x102>

		for (Local_u8row = 0; Local_u8row < Glob_u8SnakeLength; Local_u8row++) {

			// equation from (x ,y ) to get the char position

			SET_BIT(
    32b4:	89 2f       	mov	r24, r25
    32b6:	90 e0       	ldi	r25, 0x00	; 0
    32b8:	dc 01       	movw	r26, r24
    32ba:	aa 0f       	add	r26, r26
    32bc:	bb 1f       	adc	r27, r27
    32be:	a8 0f       	add	r26, r24
    32c0:	b9 1f       	adc	r27, r25
    32c2:	ad 5b       	subi	r26, 0xBD	; 189
    32c4:	be 4f       	sbci	r27, 0xFE	; 254
    32c6:	11 96       	adiw	r26, 0x01	; 1
    32c8:	4c 91       	ld	r20, X
    32ca:	11 97       	sbiw	r26, 0x01	; 1
    32cc:	8c 91       	ld	r24, X
    32ce:	11 96       	adiw	r26, 0x01	; 1
    32d0:	2c 91       	ld	r18, X
    32d2:	11 97       	sbiw	r26, 0x01	; 1
    32d4:	46 95       	lsr	r20
    32d6:	46 95       	lsr	r20
    32d8:	46 95       	lsr	r20
    32da:	50 e0       	ldi	r21, 0x00	; 0
    32dc:	65 e0       	ldi	r22, 0x05	; 5
    32de:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <__udivmodqi4>
    32e2:	30 e0       	ldi	r19, 0x00	; 0
    32e4:	20 95       	com	r18
    32e6:	30 95       	com	r19
    32e8:	27 70       	andi	r18, 0x07	; 7
    32ea:	30 70       	andi	r19, 0x00	; 0
    32ec:	fa 01       	movw	r30, r20
    32ee:	93 e0       	ldi	r25, 0x03	; 3
    32f0:	ee 0f       	add	r30, r30
    32f2:	ff 1f       	adc	r31, r31
    32f4:	9a 95       	dec	r25
    32f6:	e1 f7       	brne	.-8      	; 0x32f0 <voidTaskUpdateLCD+0xbe>
    32f8:	e4 1b       	sub	r30, r20
    32fa:	f5 0b       	sbc	r31, r21
    32fc:	e8 0f       	add	r30, r24
    32fe:	f1 1d       	adc	r31, r1
    3300:	83 e0       	ldi	r24, 0x03	; 3
    3302:	ee 0f       	add	r30, r30
    3304:	ff 1f       	adc	r31, r31
    3306:	8a 95       	dec	r24
    3308:	e1 f7       	brne	.-8      	; 0x3302 <voidTaskUpdateLCD+0xd0>
    330a:	e2 0f       	add	r30, r18
    330c:	f3 1f       	adc	r31, r19
    330e:	ef 59       	subi	r30, 0x9F	; 159
    3310:	fe 4f       	sbci	r31, 0xFE	; 254
    3312:	20 81       	ld	r18, Z
    3314:	8c 91       	ld	r24, X
    3316:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <__udivmodqi4>
    331a:	a7 01       	movw	r20, r14
    331c:	49 1b       	sub	r20, r25
    331e:	51 09       	sbc	r21, r1
    3320:	de 01       	movw	r26, r28
    3322:	04 2e       	mov	r0, r20
    3324:	02 c0       	rjmp	.+4      	; 0x332a <voidTaskUpdateLCD+0xf8>
    3326:	aa 0f       	add	r26, r26
    3328:	bb 1f       	adc	r27, r27
    332a:	0a 94       	dec	r0
    332c:	e2 f7       	brpl	.-8      	; 0x3326 <voidTaskUpdateLCD+0xf4>
    332e:	2a 2b       	or	r18, r26
    3330:	20 83       	st	Z, r18
    3332:	91 2f       	mov	r25, r17

		/// Modify the Glob_arrCharLCD[][]

		xSemaphoreTake(semSnakeArr_1, portMAX_DELAY);

		for (Local_u8row = 0; Local_u8row < Glob_u8SnakeLength; Local_u8row++) {
    3334:	80 91 76 00 	lds	r24, 0x0076
    3338:	19 2f       	mov	r17, r25
    333a:	1f 5f       	subi	r17, 0xFF	; 255
    333c:	98 17       	cp	r25, r24
    333e:	08 f4       	brcc	.+2      	; 0x3342 <voidTaskUpdateLCD+0x110>
    3340:	b9 cf       	rjmp	.-142    	; 0x32b4 <voidTaskUpdateLCD+0x82>
    3342:	90 93 3c 01 	sts	0x013C, r25
//
		}

		/// check apple for display

		if ((Glob_pointApple.x != EMPTY) && (Glob_pointApple.y != EMPTY)) {
    3346:	80 91 73 00 	lds	r24, 0x0073
    334a:	8f 3f       	cpi	r24, 0xFF	; 255
    334c:	c9 f1       	breq	.+114    	; 0x33c0 <voidTaskUpdateLCD+0x18e>
    334e:	80 91 74 00 	lds	r24, 0x0074
    3352:	8f 3f       	cpi	r24, 0xFF	; 255
    3354:	a9 f1       	breq	.+106    	; 0x33c0 <voidTaskUpdateLCD+0x18e>
			SET_BIT(
    3356:	40 91 74 00 	lds	r20, 0x0074
    335a:	80 91 73 00 	lds	r24, 0x0073
    335e:	20 91 74 00 	lds	r18, 0x0074
    3362:	46 95       	lsr	r20
    3364:	46 95       	lsr	r20
    3366:	46 95       	lsr	r20
    3368:	50 e0       	ldi	r21, 0x00	; 0
    336a:	65 e0       	ldi	r22, 0x05	; 5
    336c:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <__udivmodqi4>
    3370:	30 e0       	ldi	r19, 0x00	; 0
    3372:	20 95       	com	r18
    3374:	30 95       	com	r19
    3376:	27 70       	andi	r18, 0x07	; 7
    3378:	30 70       	andi	r19, 0x00	; 0
    337a:	fa 01       	movw	r30, r20
    337c:	73 e0       	ldi	r23, 0x03	; 3
    337e:	ee 0f       	add	r30, r30
    3380:	ff 1f       	adc	r31, r31
    3382:	7a 95       	dec	r23
    3384:	e1 f7       	brne	.-8      	; 0x337e <voidTaskUpdateLCD+0x14c>
    3386:	e4 1b       	sub	r30, r20
    3388:	f5 0b       	sbc	r31, r21
    338a:	e8 0f       	add	r30, r24
    338c:	f1 1d       	adc	r31, r1
    338e:	43 e0       	ldi	r20, 0x03	; 3
    3390:	ee 0f       	add	r30, r30
    3392:	ff 1f       	adc	r31, r31
    3394:	4a 95       	dec	r20
    3396:	e1 f7       	brne	.-8      	; 0x3390 <voidTaskUpdateLCD+0x15e>
    3398:	e2 0f       	add	r30, r18
    339a:	f3 1f       	adc	r31, r19
    339c:	ef 59       	subi	r30, 0x9F	; 159
    339e:	fe 4f       	sbci	r31, 0xFE	; 254
    33a0:	20 81       	ld	r18, Z
    33a2:	80 91 73 00 	lds	r24, 0x0073
    33a6:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <__udivmodqi4>
    33aa:	a7 01       	movw	r20, r14
    33ac:	49 1b       	sub	r20, r25
    33ae:	51 09       	sbc	r21, r1
    33b0:	de 01       	movw	r26, r28
    33b2:	02 c0       	rjmp	.+4      	; 0x33b8 <voidTaskUpdateLCD+0x186>
    33b4:	aa 0f       	add	r26, r26
    33b6:	bb 1f       	adc	r27, r27
    33b8:	4a 95       	dec	r20
    33ba:	e2 f7       	brpl	.-8      	; 0x33b4 <voidTaskUpdateLCD+0x182>
    33bc:	2a 2b       	or	r18, r26
    33be:	20 83       	st	Z, r18
					(Glob_arrCharLCD[(Glob_pointApple.y / 8)][(Glob_pointApple.x
							/ 5)].arrChar[7 - (Glob_pointApple.y % 8)]),
					(4 - (Glob_pointApple.x % 5)));
		}

		xSemaphoreGive(semSnakeArr_1);
    33c0:	80 91 99 01 	lds	r24, 0x0199
    33c4:	90 91 9a 01 	lds	r25, 0x019A
    33c8:	60 e0       	ldi	r22, 0x00	; 0
    33ca:	70 e0       	ldi	r23, 0x00	; 0
    33cc:	40 e0       	ldi	r20, 0x00	; 0
    33ce:	50 e0       	ldi	r21, 0x00	; 0
    33d0:	20 e0       	ldi	r18, 0x00	; 0
    33d2:	0e 94 d0 06 	call	0xda0	; 0xda0 <xQueueGenericSend>

		/// start update LCD (writing)

		for (Local_u8row = 0; Local_u8row < LCD_SIZE_Y_ROWS; Local_u8row++) {
    33d6:	10 92 3c 01 	sts	0x013C, r1
    33da:	31 c0       	rjmp	.+98     	; 0x343e <voidTaskUpdateLCD+0x20c>
			for (Local_u8col = 0; Local_u8col < LCD_SIZE_X_COLS;
    33dc:	10 92 3b 01 	sts	0x013B, r1
    33e0:	25 c0       	rjmp	.+74     	; 0x342c <voidTaskUpdateLCD+0x1fa>
					Local_u8col++) {

				LCD_voidCreateChar(Local_u8col,
    33e2:	90 e0       	ldi	r25, 0x00	; 0
    33e4:	bc 01       	movw	r22, r24
    33e6:	33 e0       	ldi	r19, 0x03	; 3
    33e8:	66 0f       	add	r22, r22
    33ea:	77 1f       	adc	r23, r23
    33ec:	3a 95       	dec	r19
    33ee:	e1 f7       	brne	.-8      	; 0x33e8 <voidTaskUpdateLCD+0x1b6>
    33f0:	68 1b       	sub	r22, r24
    33f2:	79 0b       	sbc	r23, r25
    33f4:	62 0f       	add	r22, r18
    33f6:	71 1d       	adc	r23, r1
    33f8:	83 e0       	ldi	r24, 0x03	; 3
    33fa:	66 0f       	add	r22, r22
    33fc:	77 1f       	adc	r23, r23
    33fe:	8a 95       	dec	r24
    3400:	e1 f7       	brne	.-8      	; 0x33fa <voidTaskUpdateLCD+0x1c8>
    3402:	6f 59       	subi	r22, 0x9F	; 159
    3404:	7e 4f       	sbci	r23, 0xFE	; 254
    3406:	82 2f       	mov	r24, r18
    3408:	0e 94 5c 18 	call	0x30b8	; 0x30b8 <LCD_voidCreateChar>
						Glob_arrCharLCD[Local_u8row][Local_u8col].arrChar);
				LCD_u8GoToXY(Local_u8row, (Local_u8col + 5)); // 5>> represents the shift on LCD
    340c:	60 91 3b 01 	lds	r22, 0x013B
    3410:	6b 5f       	subi	r22, 0xFB	; 251
    3412:	80 91 3c 01 	lds	r24, 0x013C
    3416:	0e 94 cd 17 	call	0x2f9a	; 0x2f9a <LCD_u8GoToXY>
				LCD_voidWriteChar(Local_u8col);
    341a:	80 91 3b 01 	lds	r24, 0x013B
    341e:	0e 94 41 18 	call	0x3082	; 0x3082 <LCD_voidWriteChar>

		/// start update LCD (writing)

		for (Local_u8row = 0; Local_u8row < LCD_SIZE_Y_ROWS; Local_u8row++) {
			for (Local_u8col = 0; Local_u8col < LCD_SIZE_X_COLS;
					Local_u8col++) {
    3422:	80 91 3b 01 	lds	r24, 0x013B
    3426:	8f 5f       	subi	r24, 0xFF	; 255
    3428:	80 93 3b 01 	sts	0x013B, r24
		xSemaphoreGive(semSnakeArr_1);

		/// start update LCD (writing)

		for (Local_u8row = 0; Local_u8row < LCD_SIZE_Y_ROWS; Local_u8row++) {
			for (Local_u8col = 0; Local_u8col < LCD_SIZE_X_COLS;
    342c:	20 91 3b 01 	lds	r18, 0x013B
    3430:	80 91 3c 01 	lds	r24, 0x013C
    3434:	27 30       	cpi	r18, 0x07	; 7
    3436:	a8 f2       	brcs	.-86     	; 0x33e2 <voidTaskUpdateLCD+0x1b0>

		xSemaphoreGive(semSnakeArr_1);

		/// start update LCD (writing)

		for (Local_u8row = 0; Local_u8row < LCD_SIZE_Y_ROWS; Local_u8row++) {
    3438:	8f 5f       	subi	r24, 0xFF	; 255
    343a:	80 93 3c 01 	sts	0x013C, r24
    343e:	80 91 3c 01 	lds	r24, 0x013C
    3442:	88 23       	and	r24, r24
    3444:	59 f2       	breq	.-106    	; 0x33dc <voidTaskUpdateLCD+0x1aa>
				LCD_u8GoToXY(Local_u8row, (Local_u8col + 5)); // 5>> represents the shift on LCD
				LCD_voidWriteChar(Local_u8col);
			}
		}

		vTaskDelay(SNAKE_SPEED_1MS_TICKS);
    3446:	88 ec       	ldi	r24, 0xC8	; 200
    3448:	90 e0       	ldi	r25, 0x00	; 0
    344a:	0e 94 1a 11 	call	0x2234	; 0x2234 <vTaskDelay>
    344e:	fb ce       	rjmp	.-522    	; 0x3246 <voidTaskUpdateLCD+0x14>

00003450 <voidTaskMoveSnake>:

	}

}

void voidTaskMoveSnake(void *pv) {
    3450:	df 92       	push	r13
    3452:	ef 92       	push	r14
    3454:	ff 92       	push	r15
    3456:	0f 93       	push	r16
    3458:	1f 93       	push	r17
    345a:	df 93       	push	r29
    345c:	cf 93       	push	r28
    345e:	0f 92       	push	r0
    3460:	cd b7       	in	r28, 0x3d	; 61
    3462:	de b7       	in	r29, 0x3e	; 62

	// Init the Snake points
	{

		// the starting position of Snake
		u8 temp = Glob_u8SnakeLength;
    3464:	20 91 76 00 	lds	r18, 0x0076

		for (Local_u8i = 0; Local_u8i < Glob_u8SnakeLength; Local_u8i++) {
    3468:	10 92 40 01 	sts	0x0140, r1
    346c:	90 e0       	ldi	r25, 0x00	; 0
			Glob_pointArrSnake[Local_u8i].x = temp--;
			Glob_pointArrSnake[Local_u8i].y = 5;
    346e:	45 e0       	ldi	r20, 0x05	; 5
    3470:	10 c0       	rjmp	.+32     	; 0x3492 <voidTaskMoveSnake+0x42>

		// the starting position of Snake
		u8 temp = Glob_u8SnakeLength;

		for (Local_u8i = 0; Local_u8i < Glob_u8SnakeLength; Local_u8i++) {
			Glob_pointArrSnake[Local_u8i].x = temp--;
    3472:	89 2f       	mov	r24, r25
    3474:	90 e0       	ldi	r25, 0x00	; 0
    3476:	fc 01       	movw	r30, r24
    3478:	ee 0f       	add	r30, r30
    347a:	ff 1f       	adc	r31, r31
    347c:	e8 0f       	add	r30, r24
    347e:	f9 1f       	adc	r31, r25
    3480:	ed 5b       	subi	r30, 0xBD	; 189
    3482:	fe 4f       	sbci	r31, 0xFE	; 254
    3484:	20 83       	st	Z, r18
    3486:	21 50       	subi	r18, 0x01	; 1
			Glob_pointArrSnake[Local_u8i].y = 5;
    3488:	41 83       	std	Z+1, r20	; 0x01
			Glob_pointArrSnake[Local_u8i].direc = Glob_enumSnakeDirection;
    348a:	80 91 3a 01 	lds	r24, 0x013A
    348e:	82 83       	std	Z+2, r24	; 0x02
    3490:	93 2f       	mov	r25, r19
	{

		// the starting position of Snake
		u8 temp = Glob_u8SnakeLength;

		for (Local_u8i = 0; Local_u8i < Glob_u8SnakeLength; Local_u8i++) {
    3492:	80 91 76 00 	lds	r24, 0x0076
    3496:	39 2f       	mov	r19, r25
    3498:	3f 5f       	subi	r19, 0xFF	; 255
    349a:	98 17       	cp	r25, r24
    349c:	50 f3       	brcs	.-44     	; 0x3472 <voidTaskMoveSnake+0x22>
    349e:	90 93 40 01 	sts	0x0140, r25
				Glob_pointArrSnake[Local_u8i].x %= (LCD_SIZE_X_COLS * 5);
				break;
			case SnakeDirection_Left:
				Glob_pointArrSnake[Local_u8i].x--;
				if (Glob_pointArrSnake[Local_u8i].x == EMPTY) {
					Glob_pointArrSnake[Local_u8i].x = (LCD_SIZE_X_COLS * 5) - 1;
    34a2:	e2 e2       	ldi	r30, 0x22	; 34
    34a4:	ee 2e       	mov	r14, r30
				Glob_pointArrSnake[Local_u8i].y %= (LCD_SIZE_Y_ROWS * 8);
				break;
			case SnakeDirection_Down:
				Glob_pointArrSnake[Local_u8i].y--;
				if (Glob_pointArrSnake[Local_u8i].y == EMPTY) {
					Glob_pointArrSnake[Local_u8i].y = (LCD_SIZE_Y_ROWS * 8) - 1;
    34a6:	77 e0       	ldi	r23, 0x07	; 7
    34a8:	d7 2e       	mov	r13, r23

			u8 temp;

			// get a random number

			TMR_voidGetTMR0(&temp);
    34aa:	8e 01       	movw	r16, r28
    34ac:	0f 5f       	subi	r16, 0xFF	; 255
    34ae:	1f 4f       	sbci	r17, 0xFF	; 255
							Local_pointSnakeOldTail;

				}

				// to create a new one
				Glob_pointApple.x = EMPTY;
    34b0:	ff 24       	eor	r15, r15
    34b2:	fa 94       	dec	r15
		}
	}

	while (1) {

		xSemaphoreTake(semSnakeArr_1, portMAX_DELAY);
    34b4:	80 91 99 01 	lds	r24, 0x0199
    34b8:	90 91 9a 01 	lds	r25, 0x019A
    34bc:	6f ef       	ldi	r22, 0xFF	; 255
    34be:	7f ef       	ldi	r23, 0xFF	; 255
    34c0:	0e 94 86 05 	call	0xb0c	; 0xb0c <xQueueSemaphoreTake>

		/// Moving

		// store the tail of snake for future growth

		Local_pointSnakeOldTail = Glob_pointArrSnake[(Glob_u8SnakeLength - 1)];
    34c4:	80 91 76 00 	lds	r24, 0x0076
    34c8:	90 e0       	ldi	r25, 0x00	; 0
    34ca:	01 97       	sbiw	r24, 0x01	; 1
    34cc:	fc 01       	movw	r30, r24
    34ce:	ee 0f       	add	r30, r30
    34d0:	ff 1f       	adc	r31, r31
    34d2:	e8 0f       	add	r30, r24
    34d4:	f9 1f       	adc	r31, r25
    34d6:	ad e3       	ldi	r26, 0x3D	; 61
    34d8:	b1 e0       	ldi	r27, 0x01	; 1
    34da:	ed 5b       	subi	r30, 0xBD	; 189
    34dc:	fe 4f       	sbci	r31, 0xFE	; 254
    34de:	83 e0       	ldi	r24, 0x03	; 3
    34e0:	01 90       	ld	r0, Z+
    34e2:	0d 92       	st	X+, r0
    34e4:	81 50       	subi	r24, 0x01	; 1
    34e6:	e1 f7       	brne	.-8      	; 0x34e0 <voidTaskMoveSnake+0x90>

		// update the direction for all point

		for (Local_u8i = (Glob_u8SnakeLength - 1); Local_u8i > 0; Local_u8i--) {
    34e8:	40 91 76 00 	lds	r20, 0x0076
    34ec:	14 c0       	rjmp	.+40     	; 0x3516 <voidTaskMoveSnake+0xc6>
			Glob_pointArrSnake[Local_u8i].direc = Glob_pointArrSnake[Local_u8i
    34ee:	24 2f       	mov	r18, r20
    34f0:	30 e0       	ldi	r19, 0x00	; 0
    34f2:	c9 01       	movw	r24, r18
    34f4:	01 97       	sbiw	r24, 0x01	; 1
    34f6:	fc 01       	movw	r30, r24
    34f8:	ee 0f       	add	r30, r30
    34fa:	ff 1f       	adc	r31, r31
    34fc:	e8 0f       	add	r30, r24
    34fe:	f9 1f       	adc	r31, r25
    3500:	ed 5b       	subi	r30, 0xBD	; 189
    3502:	fe 4f       	sbci	r31, 0xFE	; 254
    3504:	82 81       	ldd	r24, Z+2	; 0x02
    3506:	f9 01       	movw	r30, r18
    3508:	ee 0f       	add	r30, r30
    350a:	ff 1f       	adc	r31, r31
    350c:	e2 0f       	add	r30, r18
    350e:	f3 1f       	adc	r31, r19
    3510:	ed 5b       	subi	r30, 0xBD	; 189
    3512:	fe 4f       	sbci	r31, 0xFE	; 254
    3514:	82 83       	std	Z+2, r24	; 0x02
    3516:	41 50       	subi	r20, 0x01	; 1

		Local_pointSnakeOldTail = Glob_pointArrSnake[(Glob_u8SnakeLength - 1)];

		// update the direction for all point

		for (Local_u8i = (Glob_u8SnakeLength - 1); Local_u8i > 0; Local_u8i--) {
    3518:	51 f7       	brne	.-44     	; 0x34ee <voidTaskMoveSnake+0x9e>
			Glob_pointArrSnake[Local_u8i].direc = Glob_pointArrSnake[Local_u8i
					- 1].direc;
		}

		Glob_pointArrSnake[0].direc = Glob_enumSnakeDirection;
    351a:	80 91 3a 01 	lds	r24, 0x013A
    351e:	80 93 45 01 	sts	0x0145, r24
    3522:	20 e0       	ldi	r18, 0x00	; 0
    3524:	33 c0       	rjmp	.+102    	; 0x358c <voidTaskMoveSnake+0x13c>

		// update the values of points

		for (Local_u8i = 0; Local_u8i < Glob_u8SnakeLength; Local_u8i++) {
			switch (Glob_pointArrSnake[Local_u8i].direc) {
    3526:	82 2f       	mov	r24, r18
    3528:	90 e0       	ldi	r25, 0x00	; 0
    352a:	fc 01       	movw	r30, r24
    352c:	ee 0f       	add	r30, r30
    352e:	ff 1f       	adc	r31, r31
    3530:	e8 0f       	add	r30, r24
    3532:	f9 1f       	adc	r31, r25
    3534:	ed 5b       	subi	r30, 0xBD	; 189
    3536:	fe 4f       	sbci	r31, 0xFE	; 254
    3538:	82 81       	ldd	r24, Z+2	; 0x02
    353a:	81 30       	cpi	r24, 0x01	; 1
    353c:	81 f0       	breq	.+32     	; 0x355e <voidTaskMoveSnake+0x10e>
    353e:	81 30       	cpi	r24, 0x01	; 1
    3540:	28 f0       	brcs	.+10     	; 0x354c <voidTaskMoveSnake+0xfc>
    3542:	82 30       	cpi	r24, 0x02	; 2
    3544:	a1 f0       	breq	.+40     	; 0x356e <voidTaskMoveSnake+0x11e>
    3546:	83 30       	cpi	r24, 0x03	; 3
    3548:	01 f5       	brne	.+64     	; 0x358a <voidTaskMoveSnake+0x13a>
    354a:	18 c0       	rjmp	.+48     	; 0x357c <voidTaskMoveSnake+0x12c>
			case SnakeDirection_Right:
				Glob_pointArrSnake[Local_u8i].x++;
    354c:	80 81       	ld	r24, Z
    354e:	8f 5f       	subi	r24, 0xFF	; 255
    3550:	80 83       	st	Z, r24
				Glob_pointArrSnake[Local_u8i].x %= (LCD_SIZE_X_COLS * 5);
    3552:	80 81       	ld	r24, Z
    3554:	63 e2       	ldi	r22, 0x23	; 35
    3556:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <__udivmodqi4>
    355a:	90 83       	st	Z, r25
    355c:	16 c0       	rjmp	.+44     	; 0x358a <voidTaskMoveSnake+0x13a>
				break;
			case SnakeDirection_Left:
				Glob_pointArrSnake[Local_u8i].x--;
    355e:	80 81       	ld	r24, Z
    3560:	81 50       	subi	r24, 0x01	; 1
    3562:	80 83       	st	Z, r24
				if (Glob_pointArrSnake[Local_u8i].x == EMPTY) {
    3564:	80 81       	ld	r24, Z
    3566:	8f 3f       	cpi	r24, 0xFF	; 255
    3568:	81 f4       	brne	.+32     	; 0x358a <voidTaskMoveSnake+0x13a>
					Glob_pointArrSnake[Local_u8i].x = (LCD_SIZE_X_COLS * 5) - 1;
    356a:	e0 82       	st	Z, r14
    356c:	0e c0       	rjmp	.+28     	; 0x358a <voidTaskMoveSnake+0x13a>
				}
				break;
			case SnakeDirection_Up:
				Glob_pointArrSnake[Local_u8i].y++;
    356e:	81 81       	ldd	r24, Z+1	; 0x01
    3570:	8f 5f       	subi	r24, 0xFF	; 255
    3572:	81 83       	std	Z+1, r24	; 0x01
				Glob_pointArrSnake[Local_u8i].y %= (LCD_SIZE_Y_ROWS * 8);
    3574:	81 81       	ldd	r24, Z+1	; 0x01
    3576:	87 70       	andi	r24, 0x07	; 7
    3578:	81 83       	std	Z+1, r24	; 0x01
    357a:	07 c0       	rjmp	.+14     	; 0x358a <voidTaskMoveSnake+0x13a>
				break;
			case SnakeDirection_Down:
				Glob_pointArrSnake[Local_u8i].y--;
    357c:	81 81       	ldd	r24, Z+1	; 0x01
    357e:	81 50       	subi	r24, 0x01	; 1
    3580:	81 83       	std	Z+1, r24	; 0x01
				if (Glob_pointArrSnake[Local_u8i].y == EMPTY) {
    3582:	81 81       	ldd	r24, Z+1	; 0x01
    3584:	8f 3f       	cpi	r24, 0xFF	; 255
    3586:	09 f4       	brne	.+2      	; 0x358a <voidTaskMoveSnake+0x13a>
					Glob_pointArrSnake[Local_u8i].y = (LCD_SIZE_Y_ROWS * 8) - 1;
    3588:	d1 82       	std	Z+1, r13	; 0x01
    358a:	2f 5f       	subi	r18, 0xFF	; 255

		Glob_pointArrSnake[0].direc = Glob_enumSnakeDirection;

		// update the values of points

		for (Local_u8i = 0; Local_u8i < Glob_u8SnakeLength; Local_u8i++) {
    358c:	80 91 76 00 	lds	r24, 0x0076
    3590:	28 17       	cp	r18, r24
    3592:	48 f2       	brcs	.-110    	; 0x3526 <voidTaskMoveSnake+0xd6>
    3594:	20 93 40 01 	sts	0x0140, r18
		}

		/// Eating an apple

		// is there an apple ?
		if ((Glob_pointApple.x == EMPTY) || (Glob_pointApple.y == EMPTY)) {
    3598:	80 91 73 00 	lds	r24, 0x0073
    359c:	8f 3f       	cpi	r24, 0xFF	; 255
    359e:	21 f0       	breq	.+8      	; 0x35a8 <voidTaskMoveSnake+0x158>
    35a0:	80 91 74 00 	lds	r24, 0x0074
    35a4:	8f 3f       	cpi	r24, 0xFF	; 255
    35a6:	89 f4       	brne	.+34     	; 0x35ca <voidTaskMoveSnake+0x17a>

			u8 temp;

			// get a random number

			TMR_voidGetTMR0(&temp);
    35a8:	c8 01       	movw	r24, r16
    35aa:	0e 94 99 18 	call	0x3132	; 0x3132 <TMR_voidGetTMR0>
			Glob_pointApple.x = temp % (LCD_SIZE_X_COLS * 5);
    35ae:	89 81       	ldd	r24, Y+1	; 0x01
    35b0:	63 e2       	ldi	r22, 0x23	; 35
    35b2:	0e 94 74 1b 	call	0x36e8	; 0x36e8 <__udivmodqi4>
    35b6:	90 93 73 00 	sts	0x0073, r25

			// get a random number

			TMR_voidGetTMR0(&temp);
    35ba:	c8 01       	movw	r24, r16
    35bc:	0e 94 99 18 	call	0x3132	; 0x3132 <TMR_voidGetTMR0>
			Glob_pointApple.y = temp % (LCD_SIZE_Y_ROWS * 8);
    35c0:	89 81       	ldd	r24, Y+1	; 0x01
    35c2:	87 70       	andi	r24, 0x07	; 7
    35c4:	80 93 74 00 	sts	0x0074, r24
    35c8:	2b c0       	rjmp	.+86     	; 0x3620 <voidTaskMoveSnake+0x1d0>
		} else {

			// check if corrent eating

			// head of snake
			if ((Glob_pointArrSnake[0].x == Glob_pointApple.x)
    35ca:	90 91 43 01 	lds	r25, 0x0143
    35ce:	80 91 73 00 	lds	r24, 0x0073
    35d2:	98 17       	cp	r25, r24
    35d4:	29 f5       	brne	.+74     	; 0x3620 <voidTaskMoveSnake+0x1d0>
    35d6:	90 91 44 01 	lds	r25, 0x0144
    35da:	80 91 74 00 	lds	r24, 0x0074
    35de:	98 17       	cp	r25, r24
    35e0:	f9 f4       	brne	.+62     	; 0x3620 <voidTaskMoveSnake+0x1d0>
					&& (Glob_pointArrSnake[0].y == Glob_pointApple.y)) {

				// succss

				if (Glob_u8SnakeLength < MAX_SNAKE) {
    35e2:	80 91 76 00 	lds	r24, 0x0076
    35e6:	8a 30       	cpi	r24, 0x0A	; 10
    35e8:	b8 f4       	brcc	.+46     	; 0x3618 <voidTaskMoveSnake+0x1c8>
					Glob_u8SnakeLength++;
    35ea:	80 91 76 00 	lds	r24, 0x0076
    35ee:	8f 5f       	subi	r24, 0xFF	; 255
    35f0:	80 93 76 00 	sts	0x0076, r24

					Glob_pointArrSnake[(Glob_u8SnakeLength - 1)] =
    35f4:	80 91 76 00 	lds	r24, 0x0076
    35f8:	90 e0       	ldi	r25, 0x00	; 0
    35fa:	01 97       	sbiw	r24, 0x01	; 1
    35fc:	fc 01       	movw	r30, r24
    35fe:	ee 0f       	add	r30, r30
    3600:	ff 1f       	adc	r31, r31
    3602:	e8 0f       	add	r30, r24
    3604:	f9 1f       	adc	r31, r25
    3606:	ed 5b       	subi	r30, 0xBD	; 189
    3608:	fe 4f       	sbci	r31, 0xFE	; 254
    360a:	ad e3       	ldi	r26, 0x3D	; 61
    360c:	b1 e0       	ldi	r27, 0x01	; 1
    360e:	83 e0       	ldi	r24, 0x03	; 3
    3610:	0d 90       	ld	r0, X+
    3612:	01 92       	st	Z+, r0
    3614:	81 50       	subi	r24, 0x01	; 1
    3616:	e1 f7       	brne	.-8      	; 0x3610 <voidTaskMoveSnake+0x1c0>
							Local_pointSnakeOldTail;

				}

				// to create a new one
				Glob_pointApple.x = EMPTY;
    3618:	f0 92 73 00 	sts	0x0073, r15
				Glob_pointApple.y = EMPTY;
    361c:	f0 92 74 00 	sts	0x0074, r15

			}

		}

		xSemaphoreGive(semSnakeArr_1);
    3620:	80 91 99 01 	lds	r24, 0x0199
    3624:	90 91 9a 01 	lds	r25, 0x019A
    3628:	60 e0       	ldi	r22, 0x00	; 0
    362a:	70 e0       	ldi	r23, 0x00	; 0
    362c:	40 e0       	ldi	r20, 0x00	; 0
    362e:	50 e0       	ldi	r21, 0x00	; 0
    3630:	20 e0       	ldi	r18, 0x00	; 0
    3632:	0e 94 d0 06 	call	0xda0	; 0xda0 <xQueueGenericSend>

		vTaskDelay(SNAKE_SPEED_1MS_TICKS);
    3636:	88 ec       	ldi	r24, 0xC8	; 200
    3638:	90 e0       	ldi	r25, 0x00	; 0
    363a:	0e 94 1a 11 	call	0x2234	; 0x2234 <vTaskDelay>
    363e:	3a cf       	rjmp	.-396    	; 0x34b4 <voidTaskMoveSnake+0x64>

00003640 <voidTaskDirectionBtn>:
 * Desc:
 *  Task to update any change into LCD
 * */
void voidTaskUpdateLCD(void *pv);

void voidTaskDirectionBtn(void *pv) {
    3640:	ff 92       	push	r15
    3642:	0f 93       	push	r16
    3644:	1f 93       	push	r17
				Glob_enumSnakeDirection = SnakeDirection_Up;
			}

		} else if (Local_u8BtnValue == '5') {
			if (Glob_enumSnakeDirection != SnakeDirection_Up) {
				Glob_enumSnakeDirection = SnakeDirection_Down;
    3646:	b3 e0       	ldi	r27, 0x03	; 3
    3648:	fb 2e       	mov	r15, r27
				Glob_enumSnakeDirection = SnakeDirection_Left;
			}

		} else if (Local_u8BtnValue == '2') {
			if (Glob_enumSnakeDirection != SnakeDirection_Down) {
				Glob_enumSnakeDirection = SnakeDirection_Up;
    364a:	02 e0       	ldi	r16, 0x02	; 2
			}

		} else if (Local_u8BtnValue == '4') {

			if (Glob_enumSnakeDirection != SnakeDirection_Right) {
				Glob_enumSnakeDirection = SnakeDirection_Left;
    364c:	11 e0       	ldi	r17, 0x01	; 1

	static u8 Local_u8BtnValue = 0;

	while (1) {

		KPD_u8GetKeyValueNoWait(&Local_u8BtnValue);
    364e:	81 e4       	ldi	r24, 0x41	; 65
    3650:	91 e0       	ldi	r25, 0x01	; 1
    3652:	0e 94 e7 16 	call	0x2dce	; 0x2dce <KPD_u8GetKeyValueNoWait>

		xSemaphoreTake(semSnakeArr_1, portMAX_DELAY);
    3656:	80 91 99 01 	lds	r24, 0x0199
    365a:	90 91 9a 01 	lds	r25, 0x019A
    365e:	6f ef       	ldi	r22, 0xFF	; 255
    3660:	7f ef       	ldi	r23, 0xFF	; 255
    3662:	0e 94 86 05 	call	0xb0c	; 0xb0c <xQueueSemaphoreTake>

		if (Local_u8BtnValue == '6') {
    3666:	80 91 41 01 	lds	r24, 0x0141
    366a:	86 33       	cpi	r24, 0x36	; 54
    366c:	39 f4       	brne	.+14     	; 0x367c <voidTaskDirectionBtn+0x3c>

			if (Glob_enumSnakeDirection != SnakeDirection_Left) {
    366e:	80 91 3a 01 	lds	r24, 0x013A
    3672:	81 30       	cpi	r24, 0x01	; 1
    3674:	e9 f0       	breq	.+58     	; 0x36b0 <voidTaskDirectionBtn+0x70>
				Glob_enumSnakeDirection = SnakeDirection_Right;
    3676:	10 92 3a 01 	sts	0x013A, r1
    367a:	1a c0       	rjmp	.+52     	; 0x36b0 <voidTaskDirectionBtn+0x70>
			}

		} else if (Local_u8BtnValue == '4') {
    367c:	84 33       	cpi	r24, 0x34	; 52
    367e:	39 f4       	brne	.+14     	; 0x368e <voidTaskDirectionBtn+0x4e>

			if (Glob_enumSnakeDirection != SnakeDirection_Right) {
    3680:	80 91 3a 01 	lds	r24, 0x013A
    3684:	88 23       	and	r24, r24
    3686:	a1 f0       	breq	.+40     	; 0x36b0 <voidTaskDirectionBtn+0x70>
				Glob_enumSnakeDirection = SnakeDirection_Left;
    3688:	10 93 3a 01 	sts	0x013A, r17
    368c:	11 c0       	rjmp	.+34     	; 0x36b0 <voidTaskDirectionBtn+0x70>
			}

		} else if (Local_u8BtnValue == '2') {
    368e:	82 33       	cpi	r24, 0x32	; 50
    3690:	39 f4       	brne	.+14     	; 0x36a0 <voidTaskDirectionBtn+0x60>
			if (Glob_enumSnakeDirection != SnakeDirection_Down) {
    3692:	80 91 3a 01 	lds	r24, 0x013A
    3696:	83 30       	cpi	r24, 0x03	; 3
    3698:	59 f0       	breq	.+22     	; 0x36b0 <voidTaskDirectionBtn+0x70>
				Glob_enumSnakeDirection = SnakeDirection_Up;
    369a:	00 93 3a 01 	sts	0x013A, r16
    369e:	08 c0       	rjmp	.+16     	; 0x36b0 <voidTaskDirectionBtn+0x70>
			}

		} else if (Local_u8BtnValue == '5') {
    36a0:	85 33       	cpi	r24, 0x35	; 53
    36a2:	31 f4       	brne	.+12     	; 0x36b0 <voidTaskDirectionBtn+0x70>
			if (Glob_enumSnakeDirection != SnakeDirection_Up) {
    36a4:	80 91 3a 01 	lds	r24, 0x013A
    36a8:	82 30       	cpi	r24, 0x02	; 2
    36aa:	11 f0       	breq	.+4      	; 0x36b0 <voidTaskDirectionBtn+0x70>
				Glob_enumSnakeDirection = SnakeDirection_Down;
    36ac:	f0 92 3a 01 	sts	0x013A, r15
			}

		}

		xSemaphoreGive(semSnakeArr_1);
    36b0:	80 91 99 01 	lds	r24, 0x0199
    36b4:	90 91 9a 01 	lds	r25, 0x019A
    36b8:	60 e0       	ldi	r22, 0x00	; 0
    36ba:	70 e0       	ldi	r23, 0x00	; 0
    36bc:	40 e0       	ldi	r20, 0x00	; 0
    36be:	50 e0       	ldi	r21, 0x00	; 0
    36c0:	20 e0       	ldi	r18, 0x00	; 0
    36c2:	0e 94 d0 06 	call	0xda0	; 0xda0 <xQueueGenericSend>

		if (Local_u8BtnValue != 0) {
    36c6:	80 91 41 01 	lds	r24, 0x0141
    36ca:	88 23       	and	r24, r24
    36cc:	11 f0       	breq	.+4      	; 0x36d2 <voidTaskDirectionBtn+0x92>
			Local_u8BtnValue = 0;
    36ce:	10 92 41 01 	sts	0x0141, r1
		}

		vTaskDelay(100);
    36d2:	84 e6       	ldi	r24, 0x64	; 100
    36d4:	90 e0       	ldi	r25, 0x00	; 0
    36d6:	0e 94 1a 11 	call	0x2234	; 0x2234 <vTaskDelay>
    36da:	b9 cf       	rjmp	.-142    	; 0x364e <voidTaskDirectionBtn+0xe>

000036dc <vApplicationStackOverflowHook>:
/*
 * Desc:
 *  if overflow error will be happend
 * */
void vApplicationStackOverflowHook(TaskHandle_t xTask, char * pcTaskName) {
	DIO_u8SetPinValue(DIO_u8_PORTA, DIO_u8_PIN0, 1);
    36dc:	80 e0       	ldi	r24, 0x00	; 0
    36de:	60 e0       	ldi	r22, 0x00	; 0
    36e0:	41 e0       	ldi	r20, 0x01	; 1
    36e2:	0e 94 49 16 	call	0x2c92	; 0x2c92 <DIO_u8SetPinValue>
}
    36e6:	08 95       	ret

000036e8 <__udivmodqi4>:
    36e8:	99 1b       	sub	r25, r25
    36ea:	79 e0       	ldi	r23, 0x09	; 9
    36ec:	04 c0       	rjmp	.+8      	; 0x36f6 <__udivmodqi4_ep>

000036ee <__udivmodqi4_loop>:
    36ee:	99 1f       	adc	r25, r25
    36f0:	96 17       	cp	r25, r22
    36f2:	08 f0       	brcs	.+2      	; 0x36f6 <__udivmodqi4_ep>
    36f4:	96 1b       	sub	r25, r22

000036f6 <__udivmodqi4_ep>:
    36f6:	88 1f       	adc	r24, r24
    36f8:	7a 95       	dec	r23
    36fa:	c9 f7       	brne	.-14     	; 0x36ee <__udivmodqi4_loop>
    36fc:	80 95       	com	r24
    36fe:	08 95       	ret

00003700 <__udivmodhi4>:
    3700:	aa 1b       	sub	r26, r26
    3702:	bb 1b       	sub	r27, r27
    3704:	51 e1       	ldi	r21, 0x11	; 17
    3706:	07 c0       	rjmp	.+14     	; 0x3716 <__udivmodhi4_ep>

00003708 <__udivmodhi4_loop>:
    3708:	aa 1f       	adc	r26, r26
    370a:	bb 1f       	adc	r27, r27
    370c:	a6 17       	cp	r26, r22
    370e:	b7 07       	cpc	r27, r23
    3710:	10 f0       	brcs	.+4      	; 0x3716 <__udivmodhi4_ep>
    3712:	a6 1b       	sub	r26, r22
    3714:	b7 0b       	sbc	r27, r23

00003716 <__udivmodhi4_ep>:
    3716:	88 1f       	adc	r24, r24
    3718:	99 1f       	adc	r25, r25
    371a:	5a 95       	dec	r21
    371c:	a9 f7       	brne	.-22     	; 0x3708 <__udivmodhi4_loop>
    371e:	80 95       	com	r24
    3720:	90 95       	com	r25
    3722:	bc 01       	movw	r22, r24
    3724:	cd 01       	movw	r24, r26
    3726:	08 95       	ret

00003728 <malloc>:
    3728:	cf 93       	push	r28
    372a:	df 93       	push	r29
    372c:	bc 01       	movw	r22, r24
    372e:	82 30       	cpi	r24, 0x02	; 2
    3730:	91 05       	cpc	r25, r1
    3732:	10 f4       	brcc	.+4      	; 0x3738 <malloc+0x10>
    3734:	62 e0       	ldi	r22, 0x02	; 2
    3736:	70 e0       	ldi	r23, 0x00	; 0
    3738:	a0 91 9d 01 	lds	r26, 0x019D
    373c:	b0 91 9e 01 	lds	r27, 0x019E
    3740:	ed 01       	movw	r28, r26
    3742:	e0 e0       	ldi	r30, 0x00	; 0
    3744:	f0 e0       	ldi	r31, 0x00	; 0
    3746:	40 e0       	ldi	r20, 0x00	; 0
    3748:	50 e0       	ldi	r21, 0x00	; 0
    374a:	21 c0       	rjmp	.+66     	; 0x378e <malloc+0x66>
    374c:	88 81       	ld	r24, Y
    374e:	99 81       	ldd	r25, Y+1	; 0x01
    3750:	86 17       	cp	r24, r22
    3752:	97 07       	cpc	r25, r23
    3754:	69 f4       	brne	.+26     	; 0x3770 <malloc+0x48>
    3756:	8a 81       	ldd	r24, Y+2	; 0x02
    3758:	9b 81       	ldd	r25, Y+3	; 0x03
    375a:	30 97       	sbiw	r30, 0x00	; 0
    375c:	19 f0       	breq	.+6      	; 0x3764 <malloc+0x3c>
    375e:	93 83       	std	Z+3, r25	; 0x03
    3760:	82 83       	std	Z+2, r24	; 0x02
    3762:	04 c0       	rjmp	.+8      	; 0x376c <malloc+0x44>
    3764:	90 93 9e 01 	sts	0x019E, r25
    3768:	80 93 9d 01 	sts	0x019D, r24
    376c:	fe 01       	movw	r30, r28
    376e:	34 c0       	rjmp	.+104    	; 0x37d8 <malloc+0xb0>
    3770:	68 17       	cp	r22, r24
    3772:	79 07       	cpc	r23, r25
    3774:	38 f4       	brcc	.+14     	; 0x3784 <malloc+0x5c>
    3776:	41 15       	cp	r20, r1
    3778:	51 05       	cpc	r21, r1
    377a:	19 f0       	breq	.+6      	; 0x3782 <malloc+0x5a>
    377c:	84 17       	cp	r24, r20
    377e:	95 07       	cpc	r25, r21
    3780:	08 f4       	brcc	.+2      	; 0x3784 <malloc+0x5c>
    3782:	ac 01       	movw	r20, r24
    3784:	fe 01       	movw	r30, r28
    3786:	8a 81       	ldd	r24, Y+2	; 0x02
    3788:	9b 81       	ldd	r25, Y+3	; 0x03
    378a:	9c 01       	movw	r18, r24
    378c:	e9 01       	movw	r28, r18
    378e:	20 97       	sbiw	r28, 0x00	; 0
    3790:	e9 f6       	brne	.-70     	; 0x374c <malloc+0x24>
    3792:	41 15       	cp	r20, r1
    3794:	51 05       	cpc	r21, r1
    3796:	a9 f1       	breq	.+106    	; 0x3802 <malloc+0xda>
    3798:	ca 01       	movw	r24, r20
    379a:	86 1b       	sub	r24, r22
    379c:	97 0b       	sbc	r25, r23
    379e:	04 97       	sbiw	r24, 0x04	; 4
    37a0:	08 f4       	brcc	.+2      	; 0x37a4 <malloc+0x7c>
    37a2:	ba 01       	movw	r22, r20
    37a4:	e0 e0       	ldi	r30, 0x00	; 0
    37a6:	f0 e0       	ldi	r31, 0x00	; 0
    37a8:	2a c0       	rjmp	.+84     	; 0x37fe <malloc+0xd6>
    37aa:	8d 91       	ld	r24, X+
    37ac:	9c 91       	ld	r25, X
    37ae:	11 97       	sbiw	r26, 0x01	; 1
    37b0:	84 17       	cp	r24, r20
    37b2:	95 07       	cpc	r25, r21
    37b4:	f9 f4       	brne	.+62     	; 0x37f4 <malloc+0xcc>
    37b6:	64 17       	cp	r22, r20
    37b8:	75 07       	cpc	r23, r21
    37ba:	81 f4       	brne	.+32     	; 0x37dc <malloc+0xb4>
    37bc:	12 96       	adiw	r26, 0x02	; 2
    37be:	8d 91       	ld	r24, X+
    37c0:	9c 91       	ld	r25, X
    37c2:	13 97       	sbiw	r26, 0x03	; 3
    37c4:	30 97       	sbiw	r30, 0x00	; 0
    37c6:	19 f0       	breq	.+6      	; 0x37ce <malloc+0xa6>
    37c8:	93 83       	std	Z+3, r25	; 0x03
    37ca:	82 83       	std	Z+2, r24	; 0x02
    37cc:	04 c0       	rjmp	.+8      	; 0x37d6 <malloc+0xae>
    37ce:	90 93 9e 01 	sts	0x019E, r25
    37d2:	80 93 9d 01 	sts	0x019D, r24
    37d6:	fd 01       	movw	r30, r26
    37d8:	32 96       	adiw	r30, 0x02	; 2
    37da:	4f c0       	rjmp	.+158    	; 0x387a <malloc+0x152>
    37dc:	ca 01       	movw	r24, r20
    37de:	86 1b       	sub	r24, r22
    37e0:	97 0b       	sbc	r25, r23
    37e2:	fd 01       	movw	r30, r26
    37e4:	e8 0f       	add	r30, r24
    37e6:	f9 1f       	adc	r31, r25
    37e8:	61 93       	st	Z+, r22
    37ea:	71 93       	st	Z+, r23
    37ec:	02 97       	sbiw	r24, 0x02	; 2
    37ee:	8d 93       	st	X+, r24
    37f0:	9c 93       	st	X, r25
    37f2:	43 c0       	rjmp	.+134    	; 0x387a <malloc+0x152>
    37f4:	fd 01       	movw	r30, r26
    37f6:	82 81       	ldd	r24, Z+2	; 0x02
    37f8:	93 81       	ldd	r25, Z+3	; 0x03
    37fa:	9c 01       	movw	r18, r24
    37fc:	d9 01       	movw	r26, r18
    37fe:	10 97       	sbiw	r26, 0x00	; 0
    3800:	a1 f6       	brne	.-88     	; 0x37aa <malloc+0x82>
    3802:	80 91 9b 01 	lds	r24, 0x019B
    3806:	90 91 9c 01 	lds	r25, 0x019C
    380a:	89 2b       	or	r24, r25
    380c:	41 f4       	brne	.+16     	; 0x381e <malloc+0xf6>
    380e:	80 91 6e 00 	lds	r24, 0x006E
    3812:	90 91 6f 00 	lds	r25, 0x006F
    3816:	90 93 9c 01 	sts	0x019C, r25
    381a:	80 93 9b 01 	sts	0x019B, r24
    381e:	40 91 70 00 	lds	r20, 0x0070
    3822:	50 91 71 00 	lds	r21, 0x0071
    3826:	41 15       	cp	r20, r1
    3828:	51 05       	cpc	r21, r1
    382a:	41 f4       	brne	.+16     	; 0x383c <malloc+0x114>
    382c:	4d b7       	in	r20, 0x3d	; 61
    382e:	5e b7       	in	r21, 0x3e	; 62
    3830:	80 91 6c 00 	lds	r24, 0x006C
    3834:	90 91 6d 00 	lds	r25, 0x006D
    3838:	48 1b       	sub	r20, r24
    383a:	59 0b       	sbc	r21, r25
    383c:	20 91 9b 01 	lds	r18, 0x019B
    3840:	30 91 9c 01 	lds	r19, 0x019C
    3844:	24 17       	cp	r18, r20
    3846:	35 07       	cpc	r19, r21
    3848:	b0 f4       	brcc	.+44     	; 0x3876 <malloc+0x14e>
    384a:	ca 01       	movw	r24, r20
    384c:	82 1b       	sub	r24, r18
    384e:	93 0b       	sbc	r25, r19
    3850:	86 17       	cp	r24, r22
    3852:	97 07       	cpc	r25, r23
    3854:	80 f0       	brcs	.+32     	; 0x3876 <malloc+0x14e>
    3856:	ab 01       	movw	r20, r22
    3858:	4e 5f       	subi	r20, 0xFE	; 254
    385a:	5f 4f       	sbci	r21, 0xFF	; 255
    385c:	84 17       	cp	r24, r20
    385e:	95 07       	cpc	r25, r21
    3860:	50 f0       	brcs	.+20     	; 0x3876 <malloc+0x14e>
    3862:	42 0f       	add	r20, r18
    3864:	53 1f       	adc	r21, r19
    3866:	50 93 9c 01 	sts	0x019C, r21
    386a:	40 93 9b 01 	sts	0x019B, r20
    386e:	f9 01       	movw	r30, r18
    3870:	61 93       	st	Z+, r22
    3872:	71 93       	st	Z+, r23
    3874:	02 c0       	rjmp	.+4      	; 0x387a <malloc+0x152>
    3876:	e0 e0       	ldi	r30, 0x00	; 0
    3878:	f0 e0       	ldi	r31, 0x00	; 0
    387a:	cf 01       	movw	r24, r30
    387c:	df 91       	pop	r29
    387e:	cf 91       	pop	r28
    3880:	08 95       	ret

00003882 <free>:
    3882:	cf 93       	push	r28
    3884:	df 93       	push	r29
    3886:	00 97       	sbiw	r24, 0x00	; 0
    3888:	09 f4       	brne	.+2      	; 0x388c <free+0xa>
    388a:	50 c0       	rjmp	.+160    	; 0x392c <free+0xaa>
    388c:	ec 01       	movw	r28, r24
    388e:	22 97       	sbiw	r28, 0x02	; 2
    3890:	1b 82       	std	Y+3, r1	; 0x03
    3892:	1a 82       	std	Y+2, r1	; 0x02
    3894:	a0 91 9d 01 	lds	r26, 0x019D
    3898:	b0 91 9e 01 	lds	r27, 0x019E
    389c:	10 97       	sbiw	r26, 0x00	; 0
    389e:	09 f1       	breq	.+66     	; 0x38e2 <free+0x60>
    38a0:	40 e0       	ldi	r20, 0x00	; 0
    38a2:	50 e0       	ldi	r21, 0x00	; 0
    38a4:	ac 17       	cp	r26, r28
    38a6:	bd 07       	cpc	r27, r29
    38a8:	08 f1       	brcs	.+66     	; 0x38ec <free+0x6a>
    38aa:	bb 83       	std	Y+3, r27	; 0x03
    38ac:	aa 83       	std	Y+2, r26	; 0x02
    38ae:	fe 01       	movw	r30, r28
    38b0:	21 91       	ld	r18, Z+
    38b2:	31 91       	ld	r19, Z+
    38b4:	e2 0f       	add	r30, r18
    38b6:	f3 1f       	adc	r31, r19
    38b8:	ae 17       	cp	r26, r30
    38ba:	bf 07       	cpc	r27, r31
    38bc:	79 f4       	brne	.+30     	; 0x38dc <free+0x5a>
    38be:	8d 91       	ld	r24, X+
    38c0:	9c 91       	ld	r25, X
    38c2:	11 97       	sbiw	r26, 0x01	; 1
    38c4:	28 0f       	add	r18, r24
    38c6:	39 1f       	adc	r19, r25
    38c8:	2e 5f       	subi	r18, 0xFE	; 254
    38ca:	3f 4f       	sbci	r19, 0xFF	; 255
    38cc:	39 83       	std	Y+1, r19	; 0x01
    38ce:	28 83       	st	Y, r18
    38d0:	12 96       	adiw	r26, 0x02	; 2
    38d2:	8d 91       	ld	r24, X+
    38d4:	9c 91       	ld	r25, X
    38d6:	13 97       	sbiw	r26, 0x03	; 3
    38d8:	9b 83       	std	Y+3, r25	; 0x03
    38da:	8a 83       	std	Y+2, r24	; 0x02
    38dc:	41 15       	cp	r20, r1
    38de:	51 05       	cpc	r21, r1
    38e0:	71 f4       	brne	.+28     	; 0x38fe <free+0x7c>
    38e2:	d0 93 9e 01 	sts	0x019E, r29
    38e6:	c0 93 9d 01 	sts	0x019D, r28
    38ea:	20 c0       	rjmp	.+64     	; 0x392c <free+0xaa>
    38ec:	12 96       	adiw	r26, 0x02	; 2
    38ee:	8d 91       	ld	r24, X+
    38f0:	9c 91       	ld	r25, X
    38f2:	13 97       	sbiw	r26, 0x03	; 3
    38f4:	ad 01       	movw	r20, r26
    38f6:	00 97       	sbiw	r24, 0x00	; 0
    38f8:	11 f0       	breq	.+4      	; 0x38fe <free+0x7c>
    38fa:	dc 01       	movw	r26, r24
    38fc:	d3 cf       	rjmp	.-90     	; 0x38a4 <free+0x22>
    38fe:	fa 01       	movw	r30, r20
    3900:	d3 83       	std	Z+3, r29	; 0x03
    3902:	c2 83       	std	Z+2, r28	; 0x02
    3904:	21 91       	ld	r18, Z+
    3906:	31 91       	ld	r19, Z+
    3908:	e2 0f       	add	r30, r18
    390a:	f3 1f       	adc	r31, r19
    390c:	ce 17       	cp	r28, r30
    390e:	df 07       	cpc	r29, r31
    3910:	69 f4       	brne	.+26     	; 0x392c <free+0xaa>
    3912:	88 81       	ld	r24, Y
    3914:	99 81       	ldd	r25, Y+1	; 0x01
    3916:	28 0f       	add	r18, r24
    3918:	39 1f       	adc	r19, r25
    391a:	2e 5f       	subi	r18, 0xFE	; 254
    391c:	3f 4f       	sbci	r19, 0xFF	; 255
    391e:	fa 01       	movw	r30, r20
    3920:	31 83       	std	Z+1, r19	; 0x01
    3922:	20 83       	st	Z, r18
    3924:	8a 81       	ldd	r24, Y+2	; 0x02
    3926:	9b 81       	ldd	r25, Y+3	; 0x03
    3928:	93 83       	std	Z+3, r25	; 0x03
    392a:	82 83       	std	Z+2, r24	; 0x02
    392c:	df 91       	pop	r29
    392e:	cf 91       	pop	r28
    3930:	08 95       	ret

00003932 <memcpy>:
    3932:	fb 01       	movw	r30, r22
    3934:	dc 01       	movw	r26, r24
    3936:	02 c0       	rjmp	.+4      	; 0x393c <memcpy+0xa>
    3938:	01 90       	ld	r0, Z+
    393a:	0d 92       	st	X+, r0
    393c:	41 50       	subi	r20, 0x01	; 1
    393e:	50 40       	sbci	r21, 0x00	; 0
    3940:	d8 f7       	brcc	.-10     	; 0x3938 <memcpy+0x6>
    3942:	08 95       	ret

00003944 <_exit>:
    3944:	f8 94       	cli

00003946 <__stop_program>:
    3946:	ff cf       	rjmp	.-2      	; 0x3946 <__stop_program>
